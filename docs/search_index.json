[["index.html", "scRNA-Seq 前言", " scRNA-Seq 苏总华 2025-04-08 前言 单细胞测序分析笔记。 我不是代码的创作者，我只是代码的搬运工。 "],["seurat-教程.html", "第 1 章 Seurat 教程 1.1 数据和R包准备 1.2 读取数据 1.3 质控 1.4 找高变基因 (HVG) 1.5 标准化和降维 1.6 找 marker 基因 1.7 根据marker基因确定细胞", " 第 1 章 Seurat 教程 1.1 数据和R包准备 代码：https://satijalab.org/seurat/articles/pbmc3k_tutorial 数据：https://cf.10xgenomics.com/samples/cell/pbmc3k/pbmc3k_filtered_gene_bc_matrices.tar.gz rm(list = ls()) library(dplyr) library(Seurat) library(patchwork) 1.2 读取数据 10X的输入数据是固定的三个文件，在工作目录下新建01_data/，把三个文件放进去。 pbmc.data &lt;- Read10X(data.dir = &quot;01_data/&quot;) dim(pbmc.data) ## [1] 32738 2700 pbmc.data[c(&quot;CD3D&quot;, &quot;TCL1A&quot;, &quot;MS4A1&quot;), 1:30] ## 3 x 30 sparse Matrix of class &quot;dgCMatrix&quot; ## ## CD3D 4 . 10 . . 1 2 3 1 . . 2 7 1 . . 1 3 . 2 3 . . . . . 3 4 1 5 ## TCL1A . . . . . . . . 1 . . . . . . . . . . . . 1 . . . . . . . . ## MS4A1 . 6 . . . . . . 1 1 1 . . . . . . . . . 36 1 2 . . 2 . . . . range(pbmc.data) ## [1] 0 419 pbmc &lt;- CreateSeuratObject(counts = pbmc.data, project = &quot;pbmc3k&quot;, min.cells = 3, min.features = 200) pbmc ## An object of class Seurat ## 13714 features across 2700 samples within 1 assay ## Active assay: RNA (13714 features, 0 variable features) ## 1 layer present: counts 一个基因至少要在3个细胞里面有表达，才被保留； 一个细胞里面至少要表达两百个基因，才被保留。 1.3 质控 这里是对细胞进行的质控，指标是： 线粒体基因含量不能过高； nFeature_RNA 不能过高或过低 为什么？ nFeature_RNA是每个细胞中检测到的基因数量。nCount_RNA是细胞内检测到的分子总数。nFeature_RNA过低，表示该细胞可能已死/将死或是空液滴。太高的nCount_RNA和/或nFeature_RNA表明“细胞”实际上可以是两个或多个细胞。结合线粒体基因count数除去异常值，即可除去大多数双峰/死细胞/空液滴，因此它们过滤是常见的预处理步骤。 参考自：https://www.biostars.org/p/407036/ 1.3.1 查看三个指标 head(pbmc@meta.data) ## orig.ident nCount_RNA nFeature_RNA ## AAACATACAACCAC-1 pbmc3k 2419 779 ## AAACATTGAGCTAC-1 pbmc3k 4903 1352 ## AAACATTGATCAGC-1 pbmc3k 3147 1129 ## AAACCGTGCTTCCG-1 pbmc3k 2639 960 ## AAACCGTGTATGCG-1 pbmc3k 980 521 ## AAACGCACTGGTAC-1 pbmc3k 2163 781 pbmc[[&quot;percent.mt&quot;]] &lt;- PercentageFeatureSet(pbmc, pattern = &quot;^MT-&quot;) head(pbmc@meta.data) ## orig.ident nCount_RNA nFeature_RNA percent.mt ## AAACATACAACCAC-1 pbmc3k 2419 779 3.0177759 ## AAACATTGAGCTAC-1 pbmc3k 4903 1352 3.7935958 ## AAACATTGATCAGC-1 pbmc3k 3147 1129 0.8897363 ## AAACCGTGCTTCCG-1 pbmc3k 2639 960 1.7430845 ## AAACCGTGTATGCG-1 pbmc3k 980 521 1.2244898 ## AAACGCACTGGTAC-1 pbmc3k 2163 781 1.6643551 VlnPlot(pbmc, features = c(&quot;nFeature_RNA&quot;, &quot;nCount_RNA&quot;, &quot;percent.mt&quot;), ncol = 3,pt.size = 0.5) 根据这个三个图，确定了这个数据的过滤标准： nFeature_RNA在200~2500之间；线粒体基因占比在5%以下。 1.3.2 三个指标之间的相关性 plot1 &lt;- FeatureScatter(pbmc, feature1 = &quot;nCount_RNA&quot;, feature2 = &quot;percent.mt&quot;) plot2 &lt;- FeatureScatter(pbmc, feature1 = &quot;nCount_RNA&quot;, feature2 = &quot;nFeature_RNA&quot;) plot1 + plot2 1.3.3 过滤 dim(pbmc) ## [1] 13714 2700 pbmc &lt;- subset(pbmc, subset = nFeature_RNA &gt; 200 &amp; nFeature_RNA &lt; 2500 &amp; percent.mt &lt; 5) dim(pbmc) ## [1] 13714 2638 1.4 找高变基因 (HVG) pbmc &lt;- NormalizeData(pbmc) pbmc &lt;- FindVariableFeatures(pbmc) top10 &lt;- head(VariableFeatures(pbmc), 10);top10 ## [1] &quot;PPBP&quot; &quot;LYZ&quot; &quot;S100A9&quot; &quot;IGLL5&quot; &quot;GNLY&quot; &quot;FTL&quot; &quot;PF4&quot; &quot;FTH1&quot; ## [9] &quot;GNG11&quot; &quot;S100A8&quot; 这里选了2000个，把前十个在图上标记出来。 plot1 &lt;- VariableFeaturePlot(pbmc) plot2 &lt;- LabelPoints(plot = plot1, points = top10, repel = TRUE) plot2 1.5 标准化和降维 1.5.1 线性降维PCA pbmc &lt;- ScaleData(pbmc, features = rownames(pbmc)) pbmc &lt;- RunPCA(pbmc, features = VariableFeatures(pbmc)) VizDimLoadings(pbmc, dims = 1:2, reduction = &quot;pca&quot;) #每个主成分对应基因的热图 DimHeatmap(pbmc, dims = 1:15, cells = 500) # 应该选多少个主成分进行后续分析 ElbowPlot(pbmc) # 限速步骤 f = &quot;jc.Rdata&quot; if(!file.exists(f)){ pbmc &lt;- JackStraw(pbmc, num.replicate = 100) pbmc &lt;- ScoreJackStraw(pbmc, dims = 1:20) save(pbmc,file = f) } load(f) JackStrawPlot(pbmc, dims = 1:20) #PC1和2 PCAPlot(pbmc) + NoLegend() DimPlot(pbmc, reduction = &quot;pca&quot;)+ NoLegend() # 结合JackStrawPlot和ElbowPlot，挑选10个PC，所以这里dims定义为1:10 pbmc &lt;- FindNeighbors(pbmc, dims = 1:10) pbmc &lt;- FindClusters(pbmc, resolution = 0.5) #分辨率 ## Modularity Optimizer version 1.3.0 by Ludo Waltman and Nees Jan van Eck ## ## Number of nodes: 2638 ## Number of edges: 95927 ## ## Running Louvain algorithm... ## Maximum modularity in 10 random starts: 0.8728 ## Number of communities: 9 ## Elapsed time: 0 seconds # 结果聚成几类，用Idents查看 length(levels(Idents(pbmc))) ## [1] 9 1.5.2 UMAP 和 t-sne PCA是线性降维，这两个是非线性降维。 pbmc &lt;- RunUMAP(pbmc, dims = 1:10) DimPlot(pbmc, reduction = &quot;umap&quot;) 1.6 找 marker 基因 啥叫marker基因呢。和差异基因里面的上调基因有点类似，某个基因在某一簇细胞里表达量都很高，在其他簇表达量很低，那么这个基因就是这簇细胞的象征。 找全部cluster的maker基因 pbmc.markers &lt;- FindAllMarkers(pbmc, only.pos = TRUE, min.pct = 0.25) pbmc.markers %&gt;% group_by(cluster) %&gt;% top_n(n = 2, wt = avg_log2FC) ## # A tibble: 18 × 7 ## # Groups: cluster [9] ## p_val avg_log2FC pct.1 pct.2 p_val_adj cluster gene ## &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;fct&gt; &lt;chr&gt; ## 1 9.57e- 88 2.40 0.447 0.108 1.31e- 83 0 CCR7 ## 2 1.35e- 51 2.14 0.342 0.103 1.86e- 47 0 LEF1 ## 3 7.07e-139 7.28 0.299 0.004 9.70e-135 1 FOLR3 ## 4 3.38e-121 6.74 0.277 0.006 4.64e-117 1 S100A12 ## 5 2.97e- 58 2.09 0.42 0.111 4.07e- 54 2 AQP3 ## 6 5.03e- 34 1.87 0.263 0.07 6.90e- 30 2 CD40LG ## 7 2.40e-272 7.38 0.564 0.009 3.29e-268 3 LINC00926 ## 8 2.75e-237 7.14 0.488 0.007 3.76e-233 3 VPREB3 ## 9 7.25e-165 4.41 0.577 0.055 9.95e-161 4 GZMK ## 10 3.27e- 88 3.74 0.419 0.061 4.48e- 84 4 GZMH ## 11 1.69e-212 5.43 0.506 0.01 2.32e-208 5 CDKN1C ## 12 8.23e-168 5.88 0.37 0.005 1.13e-163 5 CKB ## 13 8.10e-179 6.22 0.471 0.013 1.11e-174 6 AKR1C3 ## 14 5.38e-112 6.07 0.29 0.007 7.38e-108 6 SH2D1B ## 15 1.48e-220 7.63 0.812 0.011 2.03e-216 7 FCER1A ## 16 1.46e-207 8.03 0.5 0.002 2.00e-203 7 SERPINF1 ## 17 0 14.4 0.615 0 0 8 LY6G6F ## 18 7.32e-222 13.9 0.385 0 1.00e-217 8 RP11-879F14.2 1.6.1 比较某个基因在几个cluster之间的表达量 小提琴图 VlnPlot(pbmc, features = c(&quot;PPBP&quot;, &quot;S100A9&quot;)) 在umap图上标记 FeaturePlot(pbmc, features = c(&quot;MS4A1&quot;, &quot;GNLY&quot;, &quot;CD3E&quot;, &quot;CD14&quot;, &quot;FCER1A&quot;, &quot;FCGR3A&quot;, &quot;LYZ&quot;, &quot;PPBP&quot;, &quot;CD8A&quot;)) top10 &lt;- pbmc.markers %&gt;% group_by(cluster) %&gt;% top_n(n = 10, wt = avg_log2FC) 1.6.2 marker基因的热图 library(ggplot2) DoHeatmap(pbmc, features = top10$gene) + NoLegend() DotPlot(pbmc,features = unique(top10$gene))+RotatedAxis() RidgePlot(pbmc,features = &quot;RPS12&quot;) 1.7 根据marker基因确定细胞 a = read.delim(&quot;../supp/markers.txt&quot;, header = F) gt = split(a[,2],a[,1]) # unstack(a[,c(2,1)]) DotPlot(pbmc, features = gt,cols = &quot;RdYlBu&quot;) + RotatedAxis() new.cluster.ids &lt;- c(&quot;Naive CD4 T&quot;, &quot;CD14+ Mono&quot;, &quot;Memory CD4 T&quot;, &quot;B&quot;, &quot;CD8 T&quot;, &quot;FCGR3A+ Mono&quot;, &quot;NK&quot;, &quot;DC&quot;, &quot;Platelet&quot;) names(new.cluster.ids) &lt;- levels(pbmc) seu.obj &lt;- RenameIdents(pbmc, new.cluster.ids) p1 &lt;- DimPlot(seu.obj, reduction = &quot;umap&quot;, label = TRUE, pt.size = 0.5) + NoLegend() p1 "],["单样本分析.html", "第 2 章 单样本分析 2.1 创建Seurat对象 2.2 降维聚类分群 2.3 maker 基因 2.4 maker 基因可视化 2.5 注释亚群", " 第 2 章 单样本分析 2.1 创建Seurat对象 #https://www.ncbi.nlm.nih.gov/pmc/articles/PMC10039079/ #untar(&quot;GSE218208_RAW.tar&quot;) rm(list = ls()) a = data.table::fread(&quot;GSM6736629_10x-PBMC-1_ds0.1974_CountMatrix.tsv.gz&quot;,data.table = F) a[1:4,1:4] ## alias:gene AAACCCAAGTAGGGTC AAACCCACACCATTCC AAACCCATCTACACTT ## 1 TSPAN6:ENSG00000000003 0 0 0 ## 2 DPM1:ENSG00000000419 0 1 0 ## 3 SCYL3:ENSG00000000457 0 0 0 ## 4 C1orf112:ENSG00000000460 0 0 0 library(tidyverse) a$`alias:gene` = str_split(a$`alias:gene`,&quot;:&quot;,simplify = T)[,1] #str_split_i(a$`alias:gene`,&quot;:&quot;,i = 1) a = distinct(a,`alias:gene`,.keep_all = T) a = column_to_rownames(a,var = &quot;alias:gene&quot;) a[1:4,1:4] ## AAACCCAAGTAGGGTC AAACCCACACCATTCC AAACCCATCTACACTT AAACGAAAGCACGTCC ## TSPAN6 0 0 0 0 ## DPM1 0 1 0 0 ## SCYL3 0 0 0 0 ## C1orf112 0 0 0 0 library(Seurat) pbmc &lt;- CreateSeuratObject(counts = a, project = &quot;a&quot;, min.cells = 3, min.features = 200) 2.1.0.1 2.质控 pbmc[[&quot;percent.mt&quot;]] &lt;- PercentageFeatureSet(pbmc, pattern = &quot;^MT-&quot;) head(pbmc@meta.data, 3) ## orig.ident nCount_RNA nFeature_RNA percent.mt ## AAACCCAAGTAGGGTC a 10768 3213 7.030089 ## AAACCCACACCATTCC a 4102 1676 5.046319 ## AAACCCATCTACACTT a 4694 1740 6.305922 VlnPlot(pbmc, features = c(&quot;nFeature_RNA&quot;, &quot;nCount_RNA&quot;, &quot;percent.mt&quot;), ncol = 3, pt.size = 0.5) pbmc = subset(pbmc,nFeature_RNA &lt; 4200 &amp; nCount_RNA &lt; 18000 &amp; percent.mt &lt; 18) 2.2 降维聚类分群 f = &quot;obj.Rdata&quot; if(!file.exists(f)){ pbmc = pbmc %&gt;% NormalizeData() %&gt;% FindVariableFeatures() %&gt;% ScaleData(features = rownames(.)) %&gt;% RunPCA(features = VariableFeatures(.)) %&gt;% FindNeighbors(dims = 1:15) %&gt;% FindClusters(resolution = 0.5) %&gt;% RunUMAP(dims = 1:15) %&gt;% RunTSNE(dims = 1:15) save(pbmc,file = f) } load(f) ElbowPlot(pbmc) p1 &lt;- DimPlot(pbmc, reduction = &quot;umap&quot;,label = T)+NoLegend();p1 2.3 maker 基因 library(dplyr) f = &quot;markers.Rdata&quot; if(!file.exists(f)){ pbmc.markers &lt;- FindAllMarkers(pbmc, only.pos = TRUE,min.pct = 0.25) save(pbmc.markers,file = f) } load(f) mks = pbmc.markers %&gt;% group_by(cluster) %&gt;% top_n(n = 2, wt = avg_log2FC) g = unique(mks$gene) 2.4 maker 基因可视化 DoHeatmap(pbmc, features = g) + NoLegend()+ scale_fill_gradientn(colors = c(&quot;#2fa1dd&quot;, &quot;white&quot;, &quot;#f87669&quot;)) DotPlot(pbmc, features = g,cols = &quot;RdYlBu&quot;) + RotatedAxis() VlnPlot(pbmc, features = g[1:3]) FeaturePlot(pbmc, features = g[1:4]) 2.5 注释亚群 手动注释 a = read.delim(&quot;../supp/markers.txt&quot;,header = F) gt = split(a[,2],a[,1]) DotPlot(pbmc, features = gt,cols = &quot;RdYlBu&quot;) + RotatedAxis() writeLines(paste0(0:11,&quot;,&quot;)) ## 0, ## 1, ## 2, ## 3, ## 4, ## 5, ## 6, ## 7, ## 8, ## 9, ## 10, ## 11, celltype = read.table(&quot;anno.txt&quot;,sep = &quot;,&quot;) #自己照着DotPlot图填的 celltype ## V1 V2 ## 1 0 Naive CD4 T ## 2 1 CD14+ Mono ## 3 2 B ## 4 3 CD8 T ## 5 4 NK ## 6 5 Naive CD4 T ## 7 6 Naive CD4 T ## 8 7 FCGR3A+ Mono ## 9 8 CD14+ Mono ## 10 9 Platelet ## 11 10 DC ## 12 11 DC new.cluster.ids &lt;- celltype$V2 names(new.cluster.ids) &lt;- levels(pbmc) seu.obj &lt;- RenameIdents(pbmc, new.cluster.ids) save(seu.obj,file = &quot;seu.obj.Rdata&quot;) p2 &lt;- DimPlot(seu.obj, reduction = &quot;umap&quot;, label = TRUE, pt.size = 0.5) + NoLegend() p2 自动注释 library(celldex) library(SingleR) ls(&quot;package:celldex&quot;) ## [1] &quot;BlueprintEncodeData&quot; &quot;DatabaseImmuneCellExpressionData&quot; ## [3] &quot;defineTextQuery&quot; &quot;fetchLatestVersion&quot; ## [5] &quot;fetchMetadata&quot; &quot;fetchReference&quot; ## [7] &quot;HumanPrimaryCellAtlasData&quot; &quot;ImmGenData&quot; ## [9] &quot;listReferences&quot; &quot;listVersions&quot; ## [11] &quot;MonacoImmuneData&quot; &quot;MouseRNAseqData&quot; ## [13] &quot;NovershternHematopoieticData&quot; &quot;saveReference&quot; ## [15] &quot;searchReferences&quot; &quot;surveyReferences&quot; f = &quot;../supp/single_ref/ref_BlueprintEncode.RData&quot; if(!file.exists(f)){ ref &lt;- celldex::BlueprintEncodeData() save(ref,file = f) } ref &lt;- get(load(f)) library(BiocParallel) scRNA = pbmc test = scRNA@assays$RNA$data pred.scRNA &lt;- SingleR(test = test, ref = ref, labels = ref$label.main, clusters = scRNA@active.ident) pred.scRNA$pruned.labels ## [1] &quot;CD4+ T-cells&quot; &quot;Monocytes&quot; &quot;B-cells&quot; &quot;CD8+ T-cells&quot; &quot;NK cells&quot; ## [6] &quot;CD4+ T-cells&quot; &quot;CD4+ T-cells&quot; &quot;Monocytes&quot; &quot;Monocytes&quot; &quot;Monocytes&quot; ## [11] &quot;DC&quot; &quot;Monocytes&quot; #查看注释准确性 plotScoreHeatmap(pred.scRNA, clusters=pred.scRNA@rownames, fontsize.row = 9,show_colnames = T) new.cluster.ids &lt;- pred.scRNA$pruned.labels names(new.cluster.ids) &lt;- levels(scRNA) levels(scRNA) ## [1] &quot;0&quot; &quot;1&quot; &quot;2&quot; &quot;3&quot; &quot;4&quot; &quot;5&quot; &quot;6&quot; &quot;7&quot; &quot;8&quot; &quot;9&quot; &quot;10&quot; &quot;11&quot; scRNA &lt;- RenameIdents(scRNA,new.cluster.ids) levels(scRNA) ## [1] &quot;CD4+ T-cells&quot; &quot;Monocytes&quot; &quot;B-cells&quot; &quot;CD8+ T-cells&quot; &quot;NK cells&quot; ## [6] &quot;DC&quot; p3 &lt;- DimPlot(scRNA, reduction = &quot;umap&quot;,label = T,pt.size = 0.5) + NoLegend() p2+p3 "],["单细胞二次分群.html", "第 3 章 单细胞二次分群 3.1 示例数据 3.2 二次分群 3.3 marker基因及其可视化 3.4 放回原来的Seurat对象里面", " 第 3 章 单细胞二次分群 背景知识 Seurat里的FindClusters函数设置的resolution数值越大，分群的数量就越多，但是当单细胞数量太多的时候，会遇到resolution再变大，分群的数量也不再增加的情况。一次分群分不开时就会需要二次分群。 3.1 示例数据 这里的示例数据seu.obj.Rdata是GSE218208降维聚类分群的结果，因为文件太大，没有直接放进文件夹里，如果load报错就自己运行一下隔壁GSE218208的代码得到这个文件再跑。 rm(list = ls()) library(Seurat) library(dplyr) load(&quot;../2.GSE218208/seu.obj.Rdata&quot;) p1 = DimPlot(seu.obj, reduction = &quot;umap&quot;,label=T)+NoLegend() p1 3.2 二次分群 这里以树突细胞(DC)为例进行二次分群，想要切换别的细胞类型直接修改下面的my_sub即可。 核心就是提取感兴趣的亚群的细胞，后面就是标准流程和可视化了，没有区别 my_sub = &quot;DC&quot; #⭐ sub.cells &lt;- subset(seu.obj, idents = my_sub) f = &quot;obj.Rdata&quot; if(!file.exists(f)){ sub.cells = sub.cells %&gt;% NormalizeData() %&gt;% FindVariableFeatures() %&gt;% ScaleData(features = rownames(.)) %&gt;% RunPCA(features = VariableFeatures(.)) %&gt;% FindNeighbors(dims = 1:15) %&gt;% FindClusters(resolution = 0.5) %&gt;% RunUMAP(dims = 1:15) save(sub.cells,file = f) } ## Modularity Optimizer version 1.3.0 by Ludo Waltman and Nees Jan van Eck ## ## Number of nodes: 88 ## Number of edges: 1998 ## ## Running Louvain algorithm... ## Maximum modularity in 10 random starts: 0.7358 ## Number of communities: 2 ## Elapsed time: 0 seconds load(f) DimPlot(sub.cells, reduction = &#39;umap&#39;,label = T)+NoLegend() 3.3 marker基因及其可视化 sub.cells.markers &lt;- FindAllMarkers(sub.cells, only.pos = TRUE, min.pct = 0.25, logfc.threshold = 0.25) top10 &lt;- sub.cells.markers %&gt;% group_by(cluster) %&gt;% top_n(n = 10, wt = avg_log2FC) %&gt;% pull(gene);top10 ## [1] &quot;LYZ&quot; &quot;TIMP1&quot; &quot;GPAT3&quot; &quot;ITGAX&quot; &quot;SAMSN1&quot; &quot;OLR1&quot; &quot;FPR3&quot; ## [8] &quot;EREG&quot; &quot;FCN1&quot; &quot;AKAP12&quot; &quot;JCHAIN&quot; &quot;IGKC&quot; &quot;MZB1&quot; &quot;PACSIN1&quot; ## [15] &quot;WNT10A&quot; &quot;MAP1A&quot; &quot;VASH2&quot; &quot;NIBAN3&quot; &quot;SMPD3&quot; &quot;TNFRSF4&quot; VlnPlot(sub.cells, features = top10) RidgePlot(sub.cells, features = top10) FeaturePlot(sub.cells, features = top10) DotPlot(sub.cells,features = top10)+ RotatedAxis() DoHeatmap(sub.cells, features = top10) + NoLegend() 3.4 放回原来的Seurat对象里面 上面的umap图是感兴趣的单独的展示，也可以把它放回原来的seurat对象里。 sub.cells@meta.data$celltype = paste0(&quot;M&quot;,sub.cells$seurat_clusters) seu.obj$celltype = as.character(Idents(seu.obj)) seu.obj$celltype = ifelse(seu.obj$celltype==my_sub, sub.cells$celltype[match(colnames(seu.obj),colnames(sub.cells))], seu.obj$celltype) Idents(seu.obj) = seu.obj$celltype p2 = DimPlot(seu.obj,label = T)+NoLegend() p1+p2 "],["多样本分析.html", "第 4 章 多样本分析 4.1 整理数据 4.2 批量读取 4.3 质控指标 4.4 整合降维聚类分群 4.5 注释 4.6 分组可视化及组件细胞比例比较 4.7 差异分析 4.8 伪bulk 转录组差异分析", " 第 4 章 多样本分析 这篇文章介绍的是有分组的单细胞数据怎样分析，数据来自GEO的GSE231920，有3个treat，3个control样本，代码完整，可以自行下载数据跑一跑，但请注意细胞数量是6w，对计算资源要求较高，自己的电脑跑不动，需要在服务器上跑。 4.1 整理数据 因为数据组织的不是每个样本一个文件夹的形式，所以需要自行整理，参考代码如下，注意这段改名的代码不要反复运行： GSE231920_RAW.tar是从GEO页面上下载的补充文件，太大了没放进文件夹里，可以自己下载。 #untar(&quot;GSE231920_RAW.tar&quot;,exdir = &quot;GSE231920_RAW&quot;) #unlink(&quot;GSE231920_RAW.tar&quot;) if(!require(&quot;multtest&quot;))BiocManager::install(&#39;multtest&#39;,update = F,ask = F) if(!require(&quot;metap&quot;))install.packages(&#39;metap&#39;,update = F,ask = F) library(stringr) fs = paste0(&quot;GSE231920_RAW/&quot;,dir(&quot;GSE231920_RAW/&quot;)) fs samples = dir(&quot;GSE231920_RAW/&quot;) %&gt;% str_split_i(&quot;_&quot;,2) %&gt;% unique();samples if(!dir.exists(&quot;01_data&quot;))dir.create(&quot;01_data&quot;) #为每个样本创建单独的文件夹 lapply(samples, function(s){ ns = paste0(&quot;01_data/&quot;,s) if(!file.exists(ns))dir.create(ns,recursive = T) }) #每个样本的三个文件复制到单独的文件夹 lapply(fs, function(s){ #s = fs[1] for(i in 1:length(samples)){ #i = 1 if(str_detect(s,samples[[i]])){ file.copy(s,paste0(&quot;01_data/&quot;,samples[[i]])) } } }) #文件名字修改 on = paste0(&quot;01_data/&quot;,dir(&quot;01_data/&quot;,recursive = T));on nn = str_remove(on,&quot;GSM\\\\d+_sample\\\\d_&quot;);nn file.rename(on,nn) 代码主要参考： https://satijalab.org/seurat/articles/integration_introduction 4.2 批量读取 rm(list = ls()) library(Seurat) rf = &quot;sce.all.Rdata&quot; if(!file.exists(rf)){ f = dir(&quot;01_data/&quot;) scelist = list() for(i in 1:length(f)){ pda &lt;- Read10X(paste0(&quot;01_data/&quot;,f[[i]])) scelist[[i]] &lt;- CreateSeuratObject(counts = pda, project = f[[i]]) print(dim(scelist[[i]])) } sce.all = merge(scelist[[1]],scelist[-1]) sce.all = JoinLayers(sce.all) #⭐抽样 set.seed(313) sce.all = subset(sce.all,downsample=500)#每个样本抽500个细胞 save(sce.all,file = rf) } load(rf) head(sce.all@meta.data) table(sce.all$orig.ident) sum(table(Idents(sce.all))) 4.3 质控指标 sce.all[[&quot;percent.mt&quot;]] &lt;- PercentageFeatureSet(sce.all, pattern = &quot;^MT-&quot;) sce.all[[&quot;percent.rp&quot;]] &lt;- PercentageFeatureSet(sce.all, pattern = &quot;^RP[SL]&quot;) sce.all[[&quot;percent.hb&quot;]] &lt;- PercentageFeatureSet(sce.all, pattern = &quot;^HB[^(P)]&quot;) head(sce.all@meta.data, 3) VlnPlot(sce.all, features = c(&quot;nFeature_RNA&quot;, &quot;nCount_RNA&quot;, &quot;percent.mt&quot;, &quot;percent.rp&quot;, &quot;percent.hb&quot;), ncol = 3,pt.size = 0, group.by = &quot;orig.ident&quot;) sce.all = subset(sce.all,percent.mt&lt;25) 4.4 整合降维聚类分群 f = &quot;obj.Rdata&quot; library(harmony) if(!file.exists(f)){ sce.all = sce.all %&gt;% NormalizeData() %&gt;% FindVariableFeatures() %&gt;% ScaleData(features = rownames(.)) %&gt;% RunPCA(pc.genes = VariableFeatures(.)) %&gt;% RunHarmony(&quot;orig.ident&quot;) %&gt;% FindNeighbors(dims = 1:15, reduction = &quot;harmony&quot;) %&gt;% FindClusters(resolution = 0.5) %&gt;% RunUMAP(dims = 1:15,reduction = &quot;harmony&quot;) %&gt;% RunTSNE(dims = 1:15,reduction = &quot;harmony&quot;) save(sce.all,file = f) } load(f) ElbowPlot(sce.all) UMAPPlot(sce.all,label = T) TSNEPlot(sce.all,label = T) 4.5 注释 ⭐这里用了两个参考数据 library(celldex) library(SingleR) ls(&quot;package:celldex&quot;) f = &quot;../supp/single_ref/ref_BlueprintEncode.RData&quot; if(!file.exists(f)){ ref &lt;- celldex::ref_BlueprintEncode() save(ref,file = f) } f2 = &quot;../supp/single_ref/ref_HumanPrimaryCellAtlasData.RData&quot; if(!file.exists(f2)){ ref &lt;- celldex::HumanPrimaryCellAtlasData() save(ref,file = f2) } ref &lt;- list(get(load(f)), get(load(f2))) library(BiocParallel) scRNA = sce.all test = scRNA@assays$RNA$data pred.scRNA &lt;- SingleR(test = test, ref = ref, labels = list(ref[[1]]$label.main,ref[[2]]$label.main), clusters = scRNA@active.ident) pred.scRNA$pruned.labels #查看注释准确性 #plotScoreHeatmap(pred.scRNA, clusters=pred.scRNA@rownames, fontsize.row = 9,show_colnames = T) new.cluster.ids &lt;- pred.scRNA$pruned.labels new.cluster.ids[is.na(new.cluster.ids)] = &quot;unknown&quot; names(new.cluster.ids) &lt;- levels(scRNA) levels(scRNA) scRNA &lt;- RenameIdents(scRNA,new.cluster.ids) levels(scRNA) p2 &lt;- DimPlot(scRNA, reduction = &quot;umap&quot;,label = T,pt.size = 0.5) + NoLegend() p2 4.6 分组可视化及组件细胞比例比较 scRNA$seurat_annotations = Idents(scRNA) table(scRNA$orig.ident) library(tinyarray) pd = geo_download(&quot;GSE231920&quot;)$pd pd$title scRNA$group = ifelse(scRNA$orig.ident %in% c(&quot;sample1&quot;,&quot;sample2&quot;,&quot;sample3&quot;), &quot;treat&quot;,&quot;control&quot;) DimPlot(scRNA, reduction = &quot;umap&quot;, group.by = &quot;group&quot;) 可以计算每个亚群的细胞数量和占全部细胞的比例 # 每种细胞的数量和比例 cell_counts &lt;- table(Idents(scRNA)) cell.all &lt;- cbind(cell_counts = cell_counts, cell_Freq = round(prop.table(cell_counts)*100,2)) #各组中每种细胞的数量和比例 cell.num.group &lt;- table(Idents(scRNA), scRNA$group) cell.freq.group &lt;- round(prop.table(cell.num.group, margin = 2) *100,2) cell.all = cbind(cell.all,cell.num.group,cell.freq.group) cell.all = cell.all[,c(1,3,4,2,5,6)] colnames(cell.all) = paste(rep(c(&quot;all&quot;,&quot;control&quot;,&quot;treat&quot;),times = 2), rep(c(&quot;count&quot;,&quot;freq&quot;),each = 3),sep = &quot;_&quot;) cell.all 4.7 差异分析 找某种细胞在不同组间的差异基因 table(scRNA$seurat_annotations) sub.markers &lt;- FindConservedMarkers(scRNA, ident.1 = &quot;NK cells&quot;, grouping.var = &quot;group&quot;, min.pct = 0.25, logfc.threshold = 0.25,verbose = F) head(sub.markers) 组间比较的气泡图 markers.to.plot = c(&quot;CD3D&quot;, &quot;CREM&quot;, &quot;HSPH1&quot;, &quot;SELL&quot;, &quot;GIMAP5&quot;, &quot;CACYBP&quot;, &quot;GNLY&quot;, &quot;NKG7&quot;, &quot;CCL5&quot;, &quot;CD8A&quot;, &quot;MS4A1&quot;, &quot;CD79A&quot;, &quot;MIR155HG&quot;, &quot;NME1&quot;, &quot;FCGR3A&quot;, &quot;VMO1&quot;, &quot;CCL2&quot;, &quot;S100A9&quot;, &quot;HLA-DQA1&quot;, &quot;GPR183&quot;, &quot;PPBP&quot;, &quot;GNG11&quot;, &quot;HBA2&quot;, &quot;HBB&quot;, &quot;TSPAN13&quot;, &quot;IL3RA&quot;, &quot;PRSS57&quot;) #一组感兴趣的基因 #如果idents有NA会报错https://github.com/satijalab/seurat/issues/8772 #scRNA &lt;- subset(scRNA, seurat_annotations %in% na.omit(scRNA$seurat_annotations)) DotPlot(scRNA, features = markers.to.plot, cols = c(&quot;blue&quot;, &quot;red&quot;), dot.scale = 8, split.by = &quot;group&quot;) + RotatedAxis() FeaturePlot(scRNA, features = c(&quot;CD3D&quot;, &quot;GNLY&quot;, &quot;IFI6&quot;), split.by = &quot;group&quot;, max.cutoff = 3, cols = c(&quot;grey&quot;, &quot;red&quot;), reduction = &quot;umap&quot;) plots &lt;- VlnPlot(scRNA, features = c(&quot;LYZ&quot;, &quot;ISG15&quot;, &quot;CXCL10&quot;), split.by = &quot;group&quot;, group.by = &quot;seurat_annotations&quot;, pt.size = 0, combine = FALSE) library(patchwork) wrap_plots(plots = plots, ncol = 1) 4.8 伪bulk 转录组差异分析 每个组要有多个样本才能做 https://satijalab.org/seurat/articles/parsebio_sketch_integration bulk &lt;- AggregateExpression(scRNA, return.seurat = T, slot = &quot;counts&quot;, assays = &quot;RNA&quot;, group.by = c(&quot;seurat_annotations&quot;,&quot;orig.ident&quot;, &quot;group&quot;)) sub &lt;- subset(bulk, seurat_annotations == &quot;CD8+ T-cells&quot;) Idents(sub) &lt;- &quot;group&quot; de_markers &lt;- FindMarkers(sub, ident.1 = &quot;treat&quot;, ident.2 = &quot;control&quot;, slot = &quot;counts&quot;, test.use = &quot;DESeq2&quot;, verbose = F) de_markers$gene &lt;- rownames(de_markers) k1 = de_markers$avg_log2FC&lt; -1 &amp; de_markers$p_val &lt;0.01 k2 = de_markers$avg_log2FC&gt; 1 &amp; de_markers$p_val &lt;0.01 de_markers$change &lt;- ifelse(k1,&quot;down&quot;,ifelse(k2,&quot;up&quot;,&quot;not&quot;)) library(ggplot2) library(ggrepel) ggplot(de_markers, aes(avg_log2FC, -log10(p_val),color = change)) + geom_point(size = 2, alpha = 0.5) + geom_vline(xintercept = c(1,-1),linetype = 4)+ geom_hline(yintercept = -log10(0.01),linetype = 4)+ scale_color_manual(values = c(&quot;blue&quot;,&quot;grey&quot;,&quot;red&quot;))+ theme_bw() + ylab(&quot;-log10(unadjusted p-value)&quot;) "],["单样本拟时序分析.html", "第 5 章 单样本拟时序分析 5.1 构建细胞发育轨迹 5.2 绘图展示", " 第 5 章 单样本拟时序分析 ** 背景知识 ** 做拟时序分析是为了探索自己感兴趣的几种细胞之间的发育关系，一般不是用全部类型的细胞来做的。 如果让ai来说拟时序的目的那就比我说的多: &gt; 拟时序分析（Pseudo-time analysis）是一种用于理解细胞状态和细胞命运变化的计算生物学方法。这种分析通常用于单细胞测序数据，其目的是重建细胞发育或疾病进程中的时间序列，即使实际的时间信息不可用。以下是进行拟时序分析的几个主要目的： 1. 细胞状态推断：通过分析单个细胞的基因表达模式，推断细胞在生物学过程中所处的状态。 2. 细胞轨迹追踪：重建细胞从一种状态转变到另一种状态的路径，这有助于理解细胞分化、发育或疾病进展的过程。 3. 细胞命运预测：预测细胞随时间可能采取的发育轨迹，尤其是在干细胞分化或癌症发展的研究中。 4. 动态过程建模：创建细胞状态变化的动态模型，这有助于揭示细胞行为的内在规律和调控机制。 5. 细胞亚群识别：在复杂的细胞群体中识别不同的细胞亚群，并理解它们在生物学过程中的作用。 6. 基因调控网络推断：通过分析基因表达随“拟时间”的变化，推断基因调控网络和信号传导途径。 7. 疾病机理探索：在疾病研究中，拟时序分析有助于揭示疾病发生和发展的分子机制。 8. 药物作用机制研究：通过观察药物处理前后细胞状态的变化，研究药物的作用机制和效果。 拟时序分析是一种强大的工具，它可以帮助研究者在没有直接时间标记的情况下，通过基因表达数据来探索细胞状态的变化和动态过程。这种方法在单细胞生物学、发育生物学、癌症生物学和神经科学等领域有着广泛的应用。 本篇代码是处理单样本数据的，下一篇是多样本的。 rm(list = ls()) library(Seurat) library(monocle) library(dplyr) load(&quot;../2.GSE218208/seu.obj.Rdata&quot;) DimPlot(seu.obj,label = T) table(Idents(seu.obj)) ## ## Naive CD4 T CD14+ Mono B CD8 T NK FCGR3A+ Mono ## 1675 1206 598 406 337 125 ## Platelet DC ## 48 88 这里的示例数据seu.obj.Rdata是GSE218208降维聚类分群的结果，因为文件太大，没有直接放进文件夹里，如果load报错就自己运行一下隔壁GSE218208的代码得到这个文件再跑。 seu.obj$celltype = as.character(Idents(seu.obj)) 👆将注释的结果添加到了meta表格里面成为了celltype列。 为了节省计算资源我们还是抽样，实战时不能抽样哦。你跑完我的代码换个别的细胞类型跑跑看。注意差异分析那里加上了存在即跳过的代码，换了输入数据是要删除Rdata重新跑，或者是换一个工作目录跑。 scRNA = subset(seu.obj,idents = c(&quot;CD14+ Mono&quot;,&quot;FCGR3A+ Mono&quot;)) set.seed(1234) scRNA = subset(scRNA,downsample = 100)#每种细胞抽100个 提取想要研究的两种细胞。 因为monocle和seurat是两个不同的体系，所以需要将seurat对象转换为monocle可以接受的CellDataSet对象。虽然monocle3已经出来很久了，但大家都不约而同的选择monocle2，大概就是习惯了吧。。 ct &lt;- scRNA@assays$RNA$counts gene_ann &lt;- data.frame( gene_short_name = row.names(ct), row.names = row.names(ct) ) pd &lt;- new(&quot;AnnotatedDataFrame&quot;, data=scRNA@meta.data) fd &lt;- new(&quot;AnnotatedDataFrame&quot;, data=gene_ann) sc_cds &lt;- newCellDataSet( ct, phenoData = pd, featureData =fd, expressionFamily = negbinomial.size(), lowerDetectionLimit=1) sc_cds ## CellDataSet (storageMode: environment) ## assayData: 25988 features, 200 samples ## element names: exprs ## protocolData: none ## phenoData ## sampleNames: AAACCCAAGTAGGGTC AAAGGTAGTCTTGAGT ... TTTGGAGAGTCCCAGC ## (200 total) ## varLabels: orig.ident nCount_RNA ... Size_Factor (8 total) ## varMetadata: labelDescription ## featureData ## featureNames: TSPAN6 DPM1 ... AL357874.3 (25988 total) ## fvarLabels: gene_short_name ## fvarMetadata: labelDescription ## experimentData: use &#39;experimentData(object)&#39; ## Annotation: 5.1 构建细胞发育轨迹 选择基因有不同的策略，比如 1.使用seurat给出的高变化基因 2.按照平均表达量大于某个数字(比如0.1，官网用的是这个)的基因 3.使用不同细胞类型之间的差异基因，differentialGeneTest计算。 我们默认使用的是最后一个策略。 sc_cds &lt;- estimateSizeFactors(sc_cds) sc_cds &lt;- estimateDispersions(sc_cds) table(scRNA@meta.data$celltype) ## ## CD14+ Mono FCGR3A+ Mono ## 100 100 fdif = &quot;diff_test_res.Rdata&quot; if(!file.exists(fdif)){ diff_test_res &lt;- differentialGeneTest(sc_cds, fullModelFormulaStr = &quot;~celltype&quot;, cores = 4) save(diff_test_res,file = fdif) } load(fdif) ordering_genes &lt;- row.names (subset(diff_test_res, qval &lt; 0.01)) #然后是查看基因，设置为排序要使用的基因 head(ordering_genes) ## [1] &quot;CD99&quot; &quot;CASP10&quot; &quot;SLC25A5&quot; &quot;MCUB&quot; &quot;ITGAL&quot; &quot;TNFRSF12A&quot; sc_cds &lt;- setOrderingFilter(sc_cds, ordering_genes) plot_ordering_genes(sc_cds) #降维 sc_cds &lt;- reduceDimension(sc_cds) #细胞排序 sc_cds &lt;- orderCells(sc_cds) 5.2 绘图展示 发育轨迹图 library(ggsci) p1 = plot_cell_trajectory(sc_cds)+ scale_color_nejm() p2 = plot_cell_trajectory(sc_cds, color_by = &#39;Pseudotime&#39;) p3 = plot_cell_trajectory(sc_cds, color_by = &#39;celltype&#39;) + scale_color_npg() library(patchwork) p2+p1/p3 这三种着色方式放在一起非常的带劲，很清晰的展示了pseudotime、state和celltype是怎样变化的。 经典的拟时序热图 展示了一些基因是如何随着时间轨迹的变化而渐变的，这个渐变不同于findmarkers，是体现变化过程的，而不是直接给出差异表达的基因。 gene_to_cluster = diff_test_res %&gt;% arrange(qval) %&gt;% head(50) %&gt;% pull(gene_short_name);head(gene_to_cluster) ## [1] &quot;S100A9&quot; &quot;S100A8&quot; &quot;FCGR3A&quot; &quot;VMO1&quot; &quot;TIMP1&quot; &quot;MS4A7&quot; plot_pseudotime_heatmap(sc_cds[gene_to_cluster,], num_clusters = nlevels(Idents(scRNA)), show_rownames = TRUE, cores = 4,return_heatmap = TRUE, hmcols = colorRampPalette(c(&quot;navy&quot;, &quot;white&quot;, &quot;firebrick3&quot;))(100)) 用感兴趣的基因给轨迹图着色，gs可以换成你想换的基因 gs = head(gene_to_cluster) plot_cell_trajectory(sc_cds,markers=gs, use_color_gradient=T) 也可以是jitter plot_genes_jitter(sc_cds[gs,], grouping = &quot;celltype&quot;, color_by = &quot;celltype&quot;, nrow= 3, ncol = NULL ) "],["多样本拟时序分析.html", "第 6 章 多样本拟时序分析 6.1 构建细胞发育轨迹 6.2 绘图展示", " 第 6 章 多样本拟时序分析 ** 背景知识** 做拟时序分析是为了探索自己感兴趣的几种细胞之间的发育关系，一般不是用全部类型的细胞来做的。例如本例中选择了CD14和CD16单核细胞。 如果让ai来说拟时序的目的那就比我说的多: &gt; 拟时序分析（Pseudo-time analysis）是一种用于理解细胞状态和细胞命运变化的计算生物学方法。这种分析通常用于单细胞测序数据，其目的是重建细胞发育或疾病进程中的时间序列，即使实际的时间信息不可用。以下是进行拟时序分析的几个主要目的： 1. 细胞状态推断：通过分析单个细胞的基因表达模式，推断细胞在生物学过程中所处的状态。 2. 细胞轨迹追踪：重建细胞从一种状态转变到另一种状态的路径，这有助于理解细胞分化、发育或疾病进展的过程。 3. 细胞命运预测：预测细胞随时间可能采取的发育轨迹，尤其是在干细胞分化或癌症发展的研究中。 4. 动态过程建模：创建细胞状态变化的动态模型，这有助于揭示细胞行为的内在规律和调控机制。 5. 细胞亚群识别：在复杂的细胞群体中识别不同的细胞亚群，并理解它们在生物学过程中的作用。 6. 基因调控网络推断：通过分析基因表达随“拟时间”的变化，推断基因调控网络和信号传导途径。 7. 疾病机理探索：在疾病研究中，拟时序分析有助于揭示疾病发生和发展的分子机制。 8. 药物作用机制研究：通过观察药物处理前后细胞状态的变化，研究药物的作用机制和效果。 拟时序分析是一种强大的工具，它可以帮助研究者在没有直接时间标记的情况下，通过基因表达数据来探索细胞状态的变化和动态过程。这种方法在单细胞生物学、发育生物学、癌症生物学和神经科学等领域有着广泛的应用。 今天的代码是处理多样本数据的，单样本的在前一篇。 使用的数据sce.all.Rdata是Seurat降维聚类分群注释的结果，有两个样本。 rm(list = ls()) library(Seurat) library(monocle) library(dplyr) load(&quot;sce.all.Rdata&quot;) DimPlot(sce.all,label = T)+NoLegend() table(sce.all$celltype) ## ## B B Activated CD14 Mono CD16 Mono CD4 Memory T CD4 Naive T ## 100 100 100 100 100 100 ## CD8 T DC Mk NK pDC T activated ## 100 100 100 100 100 100 本文的输入数据是seurat做完降维聚类分群注释的数据，为了节省计算资源，我已经抽样减少细胞数量了。并将注释的结果添加到了meta表格里面成为了celltype列。 我这里只是举例，没有考虑背景知识，提取两种细胞： scRNA = subset(sce.all,idents = c(&quot;CD14 Mono&quot;,&quot;CD16 Mono&quot;)) table(scRNA$celltype) ## ## CD14 Mono CD16 Mono ## 100 100 table(scRNA$orig.ident) ## ## IMMUNE_CTRL IMMUNE_STIM ## 105 95 因为monocle和seurat是两个不同的体系，所以需要将seurat对象转换为monocle可以接受的CellDataSet对象。虽然monocle3已经出来很久了，但大家都不约而同的选择monocle2，大概就是习惯了吧。。 ct &lt;- scRNA@assays$RNA$counts gene_ann &lt;- data.frame( gene_short_name = row.names(ct), row.names = row.names(ct) ) pd &lt;- new(&quot;AnnotatedDataFrame&quot;, data=scRNA@meta.data) fd &lt;- new(&quot;AnnotatedDataFrame&quot;, data=gene_ann) sc_cds &lt;- newCellDataSet( ct, phenoData = pd, featureData =fd, expressionFamily = negbinomial.size(), lowerDetectionLimit=1) sc_cds ## CellDataSet (storageMode: environment) ## assayData: 14053 features, 200 samples ## element names: exprs ## protocolData: none ## phenoData ## sampleNames: AAACGGCTTACTCT.1 AAATACTGGTTCTT.1 ... TTGGAGTGCTCGAA.11 ## (200 total) ## varLabels: orig.ident nCount_RNA ... Size_Factor (19 total) ## varMetadata: labelDescription ## featureData ## featureNames: AL627309.1 RP11-206L10.2 ... LRRC3DN (14053 total) ## fvarLabels: gene_short_name ## fvarMetadata: labelDescription ## experimentData: use &#39;experimentData(object)&#39; ## Annotation: 6.1 构建细胞发育轨迹 选择基因有不同的策略，比如 1.使用seurat给出的高变化基因 2.按照平均表达量大于某个数字(比如0.1，官网用的是这个)的基因 3.使用不同细胞类型之间的差异基因，differentialGeneTest计算。 我们默认使用的是最后一个策略。 sc_cds &lt;- estimateSizeFactors(sc_cds) sc_cds &lt;- estimateDispersions(sc_cds) table(scRNA@meta.data$celltype) ## ## CD14 Mono CD16 Mono ## 100 100 fdif = &quot;diff_test_res.Rdata&quot; if(!file.exists(fdif)){ diff_test_res &lt;- differentialGeneTest(sc_cds, fullModelFormulaStr = &quot; ~ celltype + orig.ident&quot;, reducedModelFormulaStr = &quot; ~ orig.ident&quot;, cores = 4) save(diff_test_res,file = fdif) } load(fdif) ordering_genes &lt;- row.names (subset(diff_test_res, qval &lt; 0.01)) #然后是查看基因，设置为排序要使用的基因 head(ordering_genes) ## [1] &quot;C1QA&quot; &quot;C1QB&quot; &quot;SH3BGRL3&quot; &quot;MARCKSL1&quot; &quot;YBX1&quot; &quot;TMEM59&quot; sc_cds &lt;- setOrderingFilter(sc_cds, ordering_genes) plot_ordering_genes(sc_cds) #降维 sc_cds &lt;- reduceDimension(sc_cds,residualModelFormulaStr = &quot;~orig.ident&quot;) #细胞排序 sc_cds &lt;- orderCells(sc_cds) 6.2 绘图展示 发育轨迹图 library(ggsci) p1 = plot_cell_trajectory(sc_cds)+ scale_color_nejm() p2 = plot_cell_trajectory(sc_cds, color_by = &#39;Pseudotime&#39;) p3 = plot_cell_trajectory(sc_cds, color_by = &#39;celltype&#39;) + scale_color_npg() library(patchwork) p2+p1/p3 这三种着色方式放在一起非常的带劲，很清晰的展示了pseudotime、state和celltype是怎样变化的。 以orig.ident着色可以看出，不同样本中的细胞基本是均匀分布在轨迹上的，说明前面的代码很好的去除了样本间的批次效应 plot_cell_trajectory(sc_cds, color_by = &#39;orig.ident&#39;) 经典的拟时序热图 展示了一些基因是如何随着时间轨迹的变化而渐变的，这个渐变不同于findmarkers，是体现变化过程的，而不是直接给出差异表达的基因。 gene_to_cluster = diff_test_res %&gt;% arrange(qval) %&gt;% head(50) %&gt;% pull(gene_short_name);head(gene_to_cluster) ## [1] &quot;VMO1&quot; &quot;CCL2&quot; &quot;CCL7&quot; &quot;S100A8&quot; &quot;FCGR3A&quot; &quot;S100A9&quot; plot_pseudotime_heatmap(sc_cds[gene_to_cluster,], num_clusters = nlevels(Idents(scRNA)), show_rownames = TRUE, cores = 4,return_heatmap = TRUE, hmcols = colorRampPalette(c(&quot;navy&quot;, &quot;white&quot;, &quot;firebrick3&quot;))(100)) 用感兴趣的基因给轨迹图着色，gs可以换成你想换的基因 gs = head(gene_to_cluster) plot_cell_trajectory(sc_cds,markers=gs, use_color_gradient=T) 也可以是jitter plot_genes_jitter(sc_cds[gs,], grouping = &quot;celltype&quot;, color_by = &quot;celltype&quot;, nrow= 3, ncol = NULL ) "],["细胞通讯分析.html", "第 7 章 细胞通讯分析 7.1 R包和数据 7.2 了解参考数据 7.3 构建cellchat对象 7.4 细胞通讯网络分析 7.5 画图展示 7.6 细胞通讯模式和信号网络", " 第 7 章 细胞通讯分析 背景知识 细胞通讯是单细胞数据高级分析中比较常见的一个，我们习惯使用的R包是CellChat。 这个是CellChat的一手教程： https://htmlpreview.github.io/?https://github.com/jinworks/CellChat/blob/master/tutorial/CellChat-vignette.html 让AI来告诉我们做细胞通讯分析的用途： 细胞通讯分析是生物学研究中的一个重要领域，它涉及研究细胞之间如何通过信号传递来协调它们的功能和行为。以下是一些细胞通讯分析的主要用途： 疾病诊断和治疗：了解细胞如何交流可以帮助诊断和治疗疾病，特别是那些与细胞通讯失调有关的疾病，如癌症、自身免疫疾病和神经退行性疾病。 药物开发：通过研究细胞间通讯的机制，可以发现新的药物靶点，从而开发出更有效的治疗药物。 发育生物学：细胞通讯在胚胎发育和组织形成中起着关键作用。研究这些过程有助于我们理解正常和异常发育的机制。 组织工程：在组织工程中，细胞通讯对于细胞的增殖、分化和组织结构的形成至关重要。 细胞信号传导研究：细胞通讯分析有助于揭示细胞内信号传导的复杂网络，这对于理解细胞如何响应外界刺激非常重要。 生物防御机制：研究细胞如何通过通讯来协调免疫反应，可以帮助我们更好地理解生物体如何抵御病原体。 神经科学：在神经科学领域，细胞通讯分析有助于我们理解大脑如何通过神经细胞间的信号传递来处理信息。 生物信息学和系统生物学：通过分析细胞通讯网络，可以构建生物系统的数学模型，帮助我们从系统层面理解生物过程。 环境生物学：研究细胞如何响应环境变化，例如温度、光照和化学物质，可以揭示生物如何适应环境。 农业和植物科学：在植物科学中，了解植物细胞如何通过通讯来协调生长、发育和对环境的响应，对于提高作物产量和抗逆性至关重要。 细胞通讯分析是一个多学科交叉的领域，它结合了分子生物学、细胞生物学、生物化学、生物信息学和其他学科的知识和技术。通过这种分析，科学家可以更深入地理解生命过程，并开发出新的生物技术和治疗方法。 7.1 R包和数据 使用的数据sce.all.Rdata是Seurat降维聚类分群注释的结果，有两个样本。和多样本拟时序用的是同一个数据。 rm(list = ls()) if(!require(NMF))install.packages(&quot;NMF&quot;,update = F,ask = F) if(!require(presto))devtools::install_local(&#39;presto-master.zip&#39;,upgrade = F,dependencies = T) if(!require(CellChat))devtools::install_local(&quot;CellChat-main/&quot;,upgrade = F,dependencies = T) if(!require(ggalluvial))install.packages(&quot;ggalluvial&quot;,update = F,ask = F) library(CellChat) library(ggplot2) library(Seurat) library(ggalluvial) load(&quot;../5.monocle_mulitisample/sce.all.Rdata&quot;) table(Idents(sce.all)) ## ## CD14 Mono pDC CD4 Memory T T activated CD4 Naive T CD8 T ## 100 100 100 100 100 100 ## Mk B Activated B DC CD16 Mono NK ## 100 100 100 100 100 100 scRNA = sce.all 因为细胞通讯更更更费计算资源，我们还是抽样，实战中不能抽样的。 set.seed(112) scRNA = subset(scRNA,downsample = 100) table(Idents(scRNA)) ## ## CD14 Mono pDC CD4 Memory T T activated CD4 Naive T CD8 T ## 100 100 100 100 100 100 ## Mk B Activated B DC CD16 Mono NK ## 100 100 100 100 100 100 7.2 了解参考数据 CellChatDB.human,CellChatDB.mouse分别是人和小鼠的配受体数据库 str(CellChatDB.human,max.level = 1) ## List of 4 ## $ interaction:&#39;data.frame&#39;: 1939 obs. of 11 variables: ## $ complex :&#39;data.frame&#39;: 157 obs. of 4 variables: ## $ cofactor :&#39;data.frame&#39;: 31 obs. of 16 variables: ## $ geneInfo :&#39;data.frame&#39;: 41787 obs. of 6 variables: table(CellChatDB.human$interaction$annotation) ## ## Cell-Cell Contact ECM-Receptor Secreted Signaling ## 319 421 1199 PPI.human和PPI.mouse是稀疏矩阵，是STRING数据库里高等级证据的相互作用关系组成的0-1矩阵。 class(PPI.human) ## [1] &quot;dgCMatrix&quot; ## attr(,&quot;package&quot;) ## [1] &quot;Matrix&quot; dim(PPI.human) ## [1] 4815 4815 table(as.numeric(PPI.human)) ## ## 0 1 ## 23156523 27702 7.3 构建cellchat对象 seurat对象可以直接转换。在@DB加上要使用的配体受体数据库，注意物种 cellchat &lt;- createCellChat(sce.all, group.by = &quot;ident&quot;, assay = &quot;RNA&quot;) ## [1] &quot;Create a CellChat object from a Seurat object&quot; ## The `meta.data` slot in the Seurat object is used as cell meta information ## Set cell identities for the new CellChat object ## The cell groups used for CellChat analysis are CD14 Mono pDC CD4 Memory T T activated CD4 Naive T CD8 T Mk B Activated B DC CD16 Mono NK cellchat@DB &lt;- subsetDB(CellChatDB.human, search = &quot;Secreted Signaling&quot;) #search可以选择的值是： table(CellChatDB.human$interaction$annotation) # 提取数据库支持的基因的表达矩阵子集 cellchat &lt;- subsetData(cellchat) dim(cellchat@data.signaling) ## [1] 337 1200 7.4 细胞通讯网络分析 # 识别过表达基因 cellchat &lt;- identifyOverExpressedGenes(cellchat) # 识别配体-受体对 cellchat &lt;- identifyOverExpressedInteractions(cellchat) # 将配体、受体投射到PPI网络 cellchat &lt;- projectData(cellchat, PPI.human)#慢 ## 推测细胞通讯网络 cellchat &lt;- computeCommunProb(cellchat) #慢 ## triMean is used for calculating the average gene expression per cell group. ## [1] &quot;&gt;&gt;&gt; Run CellChat on sc/snRNA-seq data &lt;&lt;&lt; [2025-04-07 20:21:48.305586]&quot; ## [1] &quot;&gt;&gt;&gt; CellChat inference is done. Parameter values are stored in `object@options$parameter` &lt;&lt;&lt; [2025-04-07 20:22:10.138138]&quot; cellchat &lt;- computeCommunProbPathway(cellchat) cellchat &lt;- aggregateNet(cellchat) 7.5 画图展示 分析出来的重要信号通路如下 cellchat@netP$pathways ## [1] &quot;GALECTIN&quot; &quot;CCL&quot; &quot;ANNEXIN&quot; &quot;CXCL&quot; &quot;IL1&quot; 每个通路都可以画多种图出来，图中线的颜色与发射信号的细胞一致，线的粗细代表的是信号强弱，线越粗信号越强。点的大小一般是按照每种细胞的数量来分配。 pathways.show是要画的信号通路，可以换成cellchat@netP$pathways显示的其他通路 pathways.show &lt;- &quot;GALECTIN&quot; 7.5.0.0.1 hierarchy plot groupSize &lt;- as.numeric(table(cellchat@idents)) vertex.receiver = seq(1,nlevels(scRNA)/2);vertex.receiver ## [1] 1 2 3 4 5 6 netVisual_aggregate(cellchat, signaling = pathways.show, layout = &quot;hierarchy&quot;, vertex.receiver = vertex.receiver, vertex.weight = groupSize) 这个图分了两张子图，其实是分两次说明了所有细胞类型之间的互作。两张子图的差别是中间的圆圈，第一张子图中，第二列的圆圈意义同第一列，第二张子图中，第二列的圆圈意义同第三列，从”Target”这个单词的颜色和哪个”source”一致可以看出。 互作方向也有了，是从两边的source到中间的target。 7.5.1 circle plot circle plot 只是换了一个布局，一张图展示出来。 par(mfrow = c(1,1), xpd=TRUE,mar = c(2, 2, 2, 2)) netVisual_aggregate(cellchat, signaling = pathways.show, layout = &quot;circle&quot;, vertex.receiver = vertex.receiver, vertex.weight = groupSize) 7.5.2 chord plot 弦图还是很有细节的，内圈小短线代表发射出的信号被谁接收，和接受者颜色一致，发射端是平的且有小短线，接收端是尖的。 netVisual_aggregate(cellchat, signaling = pathways.show, layout = &quot;chord&quot;, vertex.receiver = vertex.receiver, vertex.weight = groupSize) 7.5.3 heatmap 热图，纵坐标是发射端，横坐标是接收端，有颜色代表横纵坐标所指的两类细胞之间有通讯，颜色深浅代表通讯概率。右侧和上方的条形图是该行/列通讯概率之和 netVisual_heatmap(cellchat, signaling = pathways.show, color.heatmap = &quot;Reds&quot;) 计算配体-受体对信号网络的贡献度 netAnalysis_contribution(cellchat, signaling = pathways.show) 7.5.4 热图-展示每一类细胞是什么角色 分析细胞在信号网络中角色：发送者、接收者、调解者和影响者。 cellchat &lt;- netAnalysis_computeCentrality(cellchat, slot.name = &quot;netP&quot;) # the slot &#39;netP&#39; means the inferred intercellular communication network of signaling pathways netAnalysis_signalingRole_network(cellchat, signaling = pathways.show, width = 12, height = 5, font.size = 10) 7.5.5 气泡图-显示所有的显著的配体-受体对 只有p&lt;0.05的才会被画出来，颜色仍然是通讯概率，圈的大小是按照p值，p值越小圈越大。 #可以分开，也可以合到一起 netVisual_bubble(cellchat, sources.use = 1, targets.use = 1:nlevels(scRNA), remove.isolate = FALSE) #从第一类细胞到全部细胞 netVisual_bubble(cellchat, sources.use = 1:nlevels(scRNA), targets.use = 1:nlevels(scRNA), remove.isolate = FALSE)#从全部细胞到全部细胞 7.6 细胞通讯模式和信号网络 传出模式，揭示了发射端细胞如何相互协调，以及它们如何与某些信号通路协调以驱动通信。 传入模式，显示接收端细胞如何相互协调，以及它们如何与某些信号通路协调以响应输入信号。 7.6.1 选择合适的partten（细胞通讯模式）的数量 library(NMF) selectK(cellchat, pattern = &quot;outgoing&quot;) selectK(cellchat, pattern = &quot;incoming&quot;) 在帮助文档里面有解释：For a range of the number of patterns, a suitable number of patterns is the one at which Cophenetic and Silhouette values begin to drop suddenly。 这两个指标都是评估聚类稳定性的，二者都突然下降的值对应的横坐标就是合适的聚类数 这里是用parttern-细胞，parttern-通路矩阵画的热图。identifyCommunicationPatterns函数识别通讯模式，并画出热图 #传出 cellchat &lt;- identifyCommunicationPatterns(cellchat, pattern = &quot;outgoing&quot;, k = 3)# k是parttern的数量，根据上图选择的，嫌麻烦也可以用默认值5 #传入 cellchat &lt;- identifyCommunicationPatterns(cellchat, pattern = &quot;incoming&quot;, k = 3)# k是parttern的数量，根据上图选择的，嫌麻烦也可以用默认值5 用桑基图和气泡图展示每种细胞传入/传出的信号都是属于哪些通路的 # 桑基图 netAnalysis_river(cellchat, pattern = &quot;outgoing&quot;) netAnalysis_river(cellchat, pattern = &quot;incoming&quot;) # 气泡图 netAnalysis_dot(cellchat, pattern = &quot;outgoing&quot;,dot.size = 4) netAnalysis_dot(cellchat, pattern = &quot;incoming&quot;,dot.size = 4) 气泡图的颜色是按照细胞类型来分配，大小按照每个通路对每个细胞类型的贡献程度分配。 "],["gsva-分析.html", "第 8 章 GSVA 分析 8.1 加载数据和R包 8.2 做GSVA 8.3 热图可视化", " 第 8 章 GSVA 分析 单细胞数据的GSVA和芯片、bulk转录组的GSVA没有本质区别，就使用AverageExpression获取平均表达量得到新的表达矩阵再计算即可。 8.1 加载数据和R包 获得每种细胞的平均表达量. 这里的示例数据seu.obj.Rdata是GSE218208降维聚类分群的结果，因为文件太大，没有直接放进文件夹里，如果load报错就自己运行一下隔壁GSE218208的代码得到这个文件再跑。 rm(list = ls()) library(Seurat) library(GSVA) library(clusterProfiler) load(&quot;../2.GSE218208/seu.obj.Rdata&quot;) table(Idents(seu.obj)) ## ## Naive CD4 T CD14+ Mono B CD8 T NK FCGR3A+ Mono ## 1675 1206 598 406 337 125 ## Platelet DC ## 48 88 exp = AverageExpression(seu.obj)[[1]] #exp = AggregateExpression(seu.obj)[[1]] exp = as.matrix(exp) exp = exp[rowSums(exp)&gt;0,] exp[1:4,1:4] ## Naive CD4 T CD14+ Mono B CD8 T ## TSPAN6 0.01890007 0.000000000 0.00000000 0.00446691 ## DPM1 0.50764534 0.398461857 0.52602493 0.49951298 ## SCYL3 0.10701976 0.049771894 0.10397003 0.12101561 ## C1orf112 0.02653607 0.005093801 0.05426134 0.02747031 Seurat v5 提示建议用AggregateExpression做伪bulk转录组分析，那个是用来求和的，目前查到的文献和教程都是使用平均值，这里就木有改动. 8.2 做GSVA gmt文件下载自GSEA-msigdb官网 h_df = read.gmt(&quot;h.all.v2023.2.Hs.symbols.gmt&quot;)[,c(2,1)] h_list = unstack(h_df) # ES = gsva(exp, h_list) #⭐R 语言版本4.3运行这一句，代替下面的两句 gsvapar &lt;- gsvaParam(exp, h_list, maxDiff=TRUE) ES &lt;- gsva(gsvapar) ES[1:4,1:4] 8.3 热图可视化 library(pheatmap) pheatmap(ES, scale = &quot;row&quot;,angle_col = &quot;45&quot;, color = colorRampPalette(c(&quot;navy&quot;, &quot;white&quot;, &quot;firebrick3&quot;))(50)) "],["细胞周期.html", "第 9 章 细胞周期 9.1 读取数据并做好前期的质控 9.2 计算细胞周期评分 9.3 比较两个数据的细胞周期评分和PCA 9.4 比较去除和不去处细胞周期影响的下游注释", " 第 9 章 细胞周期 怎么知道我的单细胞数据需不需要去除细胞周期的影响呢 背景知识 尘封的高中生物学知识，细胞的有丝分裂，分为分裂期（M）和分裂间期（G1，S，G2），细胞处于不同的细胞周期时，代谢活跃状态和染色体的状态大不相同，直接比较表达量是不公平的。 在一些数据中，细胞周期的影响很大，大到每个周期的细胞各自聚成一簇，严重影响下游的聚类和分群。有的数据中，细胞周期的影响非常之低，可以忽略不记。 Seurat有自带的方法，根据在各个周期高表达的基因来计算细胞周期评分，根据评分的高低来推断细胞属于什么周期。 让我们来康一康如何探索细胞周期，以及有影响和没影响的数据各自长什么样。 9.1 读取数据并做好前期的质控 来自Seurat Vignette的示例数据 https://satijalab.org/seurat/articles/cell_cycle_vignette 9.1.1 GSE218208 #untar(&quot;GSE218208_RAW.tar&quot;) rm(list = ls()) a = data.table::fread(&quot;GSM6736629_10x-PBMC-1_ds0.1974_CountMatrix.tsv.gz&quot;,data.table = F) a[1:4,1:4] ## alias:gene AAACCCAAGTAGGGTC AAACCCACACCATTCC AAACCCATCTACACTT ## 1 TSPAN6:ENSG00000000003 0 0 0 ## 2 DPM1:ENSG00000000419 0 1 0 ## 3 SCYL3:ENSG00000000457 0 0 0 ## 4 C1orf112:ENSG00000000460 0 0 0 library(tidyverse) a$`alias:gene` = str_split_i(a$`alias:gene`,&quot;:&quot;,i = 1) a = distinct(a,`alias:gene`,.keep_all = T) a = column_to_rownames(a,var = &quot;alias:gene&quot;) a[1:4,1:4] ## AAACCCAAGTAGGGTC AAACCCACACCATTCC AAACCCATCTACACTT AAACGAAAGCACGTCC ## TSPAN6 0 0 0 0 ## DPM1 0 1 0 0 ## SCYL3 0 0 0 0 ## C1orf112 0 0 0 0 library(Seurat) pbmc &lt;- CreateSeuratObject(counts = a, project = &quot;a&quot;, min.cells = 3, min.features = 200) pbmc[[&quot;percent.mt&quot;]] &lt;- PercentageFeatureSet(pbmc, pattern = &quot;^MT-&quot;) head(pbmc@meta.data, 3) ## orig.ident nCount_RNA nFeature_RNA percent.mt ## AAACCCAAGTAGGGTC a 10768 3213 7.030089 ## AAACCCACACCATTCC a 4102 1676 5.046319 ## AAACCCATCTACACTT a 4694 1740 6.305922 VlnPlot(pbmc, features = c(&quot;nFeature_RNA&quot;, &quot;nCount_RNA&quot;, &quot;percent.mt&quot;), ncol = 3,pt.size = 0.5) pbmc = subset(pbmc,nFeature_RNA &lt; 4200 &amp; nCount_RNA &lt; 18000 &amp; percent.mt &lt; 10) 9.1.2 marrow exp.mat &lt;- read.delim(&quot;nestorawa_forcellcycle_expressionMatrix.txt&quot;,row.names = 1) marrow &lt;- CreateSeuratObject(counts = exp.mat, project = &quot;b&quot;, min.cells = 3, min.features = 200) marrow[[&quot;percent.mt&quot;]] &lt;- PercentageFeatureSet(marrow, pattern = &quot;^MT-&quot;) head(marrow@meta.data, 3) ## orig.ident nCount_RNA nFeature_RNA percent.mt ## Prog_013 Prog 2563086 10208 5.187809 ## Prog_019 Prog 3030619 9990 5.965877 ## Prog_031 Prog 1293487 10192 5.664456 VlnPlot(marrow, features = c(&quot;nFeature_RNA&quot;, &quot;nCount_RNA&quot;, &quot;percent.mt&quot;), ncol = 3,pt.size = 0.5) #从图上可以看出这个数据已经过滤了 9.2 计算细胞周期评分 check_cc = function(ob){ s.genes &lt;- intersect(cc.genes$s.genes,rownames(ob)) g2m.genes &lt;- intersect(cc.genes$g2m.genes,rownames(ob)) ob = ob %&gt;% NormalizeData() %&gt;% FindVariableFeatures() %&gt;% CellCycleScoring(s.features = s.genes, g2m.features = g2m.genes) %&gt;% ScaleData(features = rownames(.)) %&gt;% RunPCA(features = c(s.genes,g2m.genes)) return(ob) } ob1 = check_cc(pbmc) head(ob1@meta.data) ## orig.ident nCount_RNA nFeature_RNA percent.mt S.Score ## AAACCCAAGTAGGGTC a 10768 3213 7.030089 -0.049741327 ## AAACCCACACCATTCC a 4102 1676 5.046319 0.077834857 ## AAACCCATCTACACTT a 4694 1740 6.305922 -0.042199858 ## AAACGAAAGCACGTCC a 5584 2055 4.512894 -0.005870195 ## AAACGAAGTTCAAACC a 2917 1548 2.673980 -0.036017674 ## AAACGAAGTTGGACTT a 3755 1408 5.219707 -0.008708112 ## G2M.Score Phase ## AAACCCAAGTAGGGTC -0.078938340 G1 ## AAACCCACACCATTCC -0.036964594 S ## AAACCCATCTACACTT -0.033518345 G1 ## AAACGAAAGCACGTCC -0.026582838 G1 ## AAACGAAGTTCAAACC 0.006352434 G2M ## AAACGAAGTTGGACTT -0.060231178 G1 9.3 比较两个数据的细胞周期评分和PCA 可以看到这个函数处理完后，meta.data里面多了4列，分别是s和g2m的评分以及推断的细胞周期。 table(ob1$Phase) ## ## G1 G2M S ## 1821 1224 1294 ob2 = check_cc(marrow) table(ob2$Phase) ## ## G1 G2M S ## 279 183 312 PCAPlot(ob1,group.by = &quot;Phase&quot;)+ PCAPlot(ob2,group.by = &quot;Phase&quot;) 这样的比较不太直观，把坐标调到相同范围 library(patchwork) PCAPlot(ob1,group.by = &quot;Phase&quot;)+ PCAPlot(ob2,group.by = &quot;Phase&quot;)&amp; xlim(-10,10)&amp; ylim(-10,10) 再比较一下S.Score和G2M.Score p1 = VlnPlot(ob1,&quot;S.Score&quot;,group.by = &quot;Phase&quot;) p2 = VlnPlot(ob2,&quot;S.Score&quot;,group.by = &quot;Phase&quot;) wrap_plots(p1,p2,nrow = 1) &amp; ylim(-0.6,0.6) p1 = VlnPlot(ob1,&quot;G2M.Score&quot;,group.by = &quot;Phase&quot;) p2 = VlnPlot(ob2,&quot;G2M.Score&quot;,group.by = &quot;Phase&quot;) wrap_plots(p1,p2,nrow = 1) &amp; ylim(-0.5,1) 这个周期的判断还是比较粗暴的，哪个分高就是那个周期，两个分都是负的那就G1期。 因此虽然GSE218208的数据也是有周期区别，但是分数相差很小，影响很小。 所以像这样的大多数点都集中在0点附近的数据，就可以不用去除细胞周期的影响！ ok，你不踏实。那我们来比较一下去除和不去除细胞周期影响的下游注释看有没有区别吧。 9.4 比较去除和不去处细胞周期影响的下游注释 9.4.1 不考虑细胞周期的降维聚类分群 f = &quot;ob1.Rdata&quot; if(!file.exists(f)){ ob1 = pbmc %&gt;% NormalizeData() %&gt;% FindVariableFeatures() %&gt;% ScaleData(features = rownames(.)) %&gt;% RunPCA(features = VariableFeatures(.)) %&gt;% FindNeighbors(dims = 1:15) %&gt;% FindClusters(resolution = 0.5) %&gt;% RunUMAP(dims = 1:15) %&gt;% RunTSNE(dims = 1:15) save(ob1,file = f) } ## Modularity Optimizer version 1.3.0 by Ludo Waltman and Nees Jan van Eck ## ## Number of nodes: 4339 ## Number of edges: 151523 ## ## Running Louvain algorithm... ## Maximum modularity in 10 random starts: 0.8942 ## Number of communities: 12 ## Elapsed time: 0 seconds load(f) 9.4.2 考虑细胞周期的降维聚类分群 s.genes &lt;- intersect(cc.genes$s.genes,rownames(pbmc)) g2m.genes &lt;- intersect(cc.genes$g2m.genes,rownames(pbmc)) f = &quot;ob2.Rdata&quot; if(!file.exists(f)){ ob2 = pbmc %&gt;% NormalizeData() %&gt;% FindVariableFeatures() %&gt;% CellCycleScoring(s.features = s.genes, g2m.features = g2m.genes) %&gt;% ScaleData(vars.to.regress = c(&quot;S.Score&quot;, &quot;G2M.Score&quot;),features = rownames(.)) %&gt;% #运行极其慢 RunPCA(features = VariableFeatures(.)) %&gt;% FindNeighbors(dims = 1:15) %&gt;% FindClusters(resolution = 0.5) %&gt;% RunUMAP(dims = 1:15) %&gt;% RunTSNE(dims = 1:15) save(ob2,file = f) } ## Modularity Optimizer version 1.3.0 by Ludo Waltman and Nees Jan van Eck ## ## Number of nodes: 4339 ## Number of edges: 146175 ## ## Running Louvain algorithm... ## Maximum modularity in 10 random starts: 0.8902 ## Number of communities: 13 ## Elapsed time: 0 seconds load(f) p1 &lt;- DimPlot(ob1, reduction = &quot;umap&quot;,label = T)+NoLegend() p2 &lt;- DimPlot(ob2, reduction = &quot;umap&quot;,label = T)+NoLegend() p1+p2 简单点用singleR来注释 library(celldex) library(SingleR) ls(&quot;package:celldex&quot;) ## [1] &quot;BlueprintEncodeData&quot; &quot;DatabaseImmuneCellExpressionData&quot; ## [3] &quot;defineTextQuery&quot; &quot;fetchLatestVersion&quot; ## [5] &quot;fetchMetadata&quot; &quot;fetchReference&quot; ## [7] &quot;HumanPrimaryCellAtlasData&quot; &quot;ImmGenData&quot; ## [9] &quot;listReferences&quot; &quot;listVersions&quot; ## [11] &quot;MonacoImmuneData&quot; &quot;MouseRNAseqData&quot; ## [13] &quot;NovershternHematopoieticData&quot; &quot;saveReference&quot; ## [15] &quot;searchReferences&quot; &quot;surveyReferences&quot; f = &quot;../supp/single_ref/ref_Human_all.RData&quot; if(!file.exists(f)){ ref &lt;- celldex::HumanPrimaryCellAtlasData() save(ref,file = f) } ref &lt;- get(load(f)) library(BiocParallel) scRNA = ob1 test = scRNA@assays$RNA$data pred.scRNA &lt;- SingleR(test = test, ref = ref, labels = ref$label.main, clusters = scRNA@active.ident) new.cluster.ids &lt;- pred.scRNA$pruned.labels names(new.cluster.ids) &lt;- levels(scRNA) scRNA &lt;- RenameIdents(scRNA,new.cluster.ids) p3 &lt;- DimPlot(scRNA, reduction = &quot;umap&quot;,label = T,pt.size = 0.5) + NoLegend() m = scRNA 解释一下为什么会有scRNA = ob1,m = scRNA这样的代码： 当然是为了少改代码犯错误啦。两次注释的代码是一样的，如果把scRNA这个变量名替换掉就麻烦，别说可以全部替换，万一你替换的变量名称是函数或者文件名等东西的一部分，那不还得报错还得改回去？所以移花接木另行赋值是个更好的选择。 scRNA = ob2 test = scRNA@assays$RNA$data pred.scRNA &lt;- SingleR(test = test, ref = ref, labels = ref$label.main, clusters = scRNA@active.ident) new.cluster.ids &lt;- pred.scRNA$pruned.labels names(new.cluster.ids) &lt;- levels(scRNA) scRNA &lt;- RenameIdents(scRNA,new.cluster.ids) p4 &lt;- DimPlot(scRNA, reduction = &quot;umap&quot;,label = T,pt.size = 0.5) + NoLegend() p3+p4 # table(Idents(m)==Idents(scRNA)) 去不去除当然还是有区别的，只不过影响不大，可以忽略不计啊。 "],["404.html", "Page not found", " Page not found The page you requested cannot be found (perhaps it was moved or renamed). You may want to try searching to find the page's new location, or use the table of contents to find the page you are looking for. "]]
