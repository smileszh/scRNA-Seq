[["index.html", "scRNA-Seq 前言", " scRNA-Seq 苏总华 2025-04-14 前言 单细胞测序分析笔记。 我不是代码的创作者，我只是代码的搬运工。 "],["seurat-标准处理流程.html", "第 1 章 Seurat 标准处理流程 1.1 设置 Seurat 对象 1.2 QC 和选择细胞进行进一步分析 1.3 数据标准化 1.4 高度可变特征的识别（特征选择） 1.5 缩放数据 1.6 线性降维 1.7 确定数据集的“维度” 1.8 细胞聚类 1.9 运行非线性降维（UMAP/tSNE） 1.10 寻找差异表达的特征（聚类 Marker） 1.11 根据 marker 基因确定细胞", " 第 1 章 Seurat 标准处理流程 Seurat 是一个 R 软件包，用于单细胞 RNA 测序数据的质量控制、分析和探索。Seurat 旨在帮助用户识别和解释单细胞转录组测量中的异质性来源，并整合不同类型的单细胞数据。 代码：https://satijalab.org/seurat/articles/pbmc3k_tutorial 数据：https://cf.10xgenomics.com/samples/cell/pbmc3k/pbmc3k_filtered_gene_bc_matrices.tar.gz # 加载包 rm(list = ls()) library(dplyr) library(Seurat) library(patchwork) 1.1 设置 Seurat 对象 10X的输入数据是固定的三个文件，在工作目录下新建01_data/，把三个文件放进去。 pbmc.data &lt;- Read10X(data.dir = &quot;01_data/&quot;) pbmc &lt;- CreateSeuratObject(counts = pbmc.data, project = &quot;pbmc3k&quot;, min.cells = 3, # 一个基因至少要在3个细胞里面有表达，才被保留 min.features = 200) # 一个细胞里面至少要表达两百个基因，才被保留。 pbmc ## An object of class Seurat ## 13714 features across 2700 samples within 1 assay ## Active assay: RNA (13714 features, 0 variable features) ## 1 layer present: counts 1.2 QC 和选择细胞进行进一步分析 常用的几个 QC 指标包括： 每个细胞中检测到的独特基因的数量。 低质量的细胞或空液滴通常只有很少的基因。 细胞双胞胎或多胞胎可能表现出异常高的基因计数。 在细胞内检测到的分子总数（与独特的基因强烈相关） 映射到线粒体基因组的 reads 百分比。 低质量/垂死的细胞通常表现出广泛的线粒体污染。 使用 PercentageFeatureSet() 函数计算线粒体 QC 指标，该函数计算源自一组特征的计数百分比。 使用所有以 MT- 开头的基因作为一组线粒体基因。 nFeature_RNA是每个细胞中检测到的基因数量。nCount_RNA是细胞内检测到的分子总数。nFeature_RNA过低，表示该细胞可能已死/将死或是空液滴。太高的nCount_RNA和/或nFeature_RNA表明“细胞”实际上可以是两个或多个细胞。结合线粒体基因count数除去异常值，即可除去大多数双峰/死细胞/空液滴，因此它们过滤是常见的预处理步骤。 参考自：https://www.biostars.org/p/407036/ # [[ 操作符可以将列添加到对象元数据中。这是存放 QC 统计数据的好地方。 pbmc[[&quot;percent.mt&quot;]] &lt;- PercentageFeatureSet(pbmc, pattern = &quot;^MT-&quot;) QC指标储存位置 在 CreateSeuratObject() 期间，会自动计算唯一基因的数量和总分子数 head(pbmc@meta.data, 5) ## orig.ident nCount_RNA nFeature_RNA percent.mt ## AAACATACAACCAC-1 pbmc3k 2419 779 3.0177759 ## AAACATTGAGCTAC-1 pbmc3k 4903 1352 3.7935958 ## AAACATTGATCAGC-1 pbmc3k 3147 1129 0.8897363 ## AAACCGTGCTTCCG-1 pbmc3k 2639 960 1.7430845 ## AAACCGTGTATGCG-1 pbmc3k 980 521 1.2244898 第一列orig.ident是原始细胞的标识； 第二列nCount_RNA是每个细胞的RNA分子数； 第三列nFeature_RNA是每个细胞检测到的基因数。 # 将 QC 指标可视化为小提琴图 VlnPlot(pbmc, features = c(&quot;nFeature_RNA&quot;, &quot;nCount_RNA&quot;, &quot;percent.mt&quot;), ncol = 3, pt.size = 0.5) # FeatureScatter 通常用于可视化特征-特征关系，但也可以用于对象计算的任何内容，即对象元数据中的列、主成分得分等。 plot1 &lt;- FeatureScatter(pbmc, feature1 = &quot;nCount_RNA&quot;, feature2 = &quot;percent.mt&quot;) plot2 &lt;- FeatureScatter(pbmc, feature1 = &quot;nCount_RNA&quot;, feature2 = &quot;nFeature_RNA&quot;) plot1 + plot2 # 我们过滤掉具有超过 2,500 或少于 200 个基因的细胞。 # 过滤掉线粒体计数&gt;5%的细胞。 pbmc &lt;- subset(pbmc, subset = nFeature_RNA &gt; 200 &amp; nFeature_RNA &lt; 2500 &amp; percent.mt &lt; 5) 1.3 数据标准化 从数据集中移除不需要的细胞后，下一步是标准化数据。默认情况下，我们采用全局缩放标准化方法 “LogNormalize”，该方法通过总表达量对每个细胞的特征表达测量值进行标准化，然后将其乘以一个比例因子（默认为 10,000），并对结果进行对数转换。在 Seurat v5 中，标准化值存储在 pbmc[[\"RNA\"]]$data 中。 pbmc &lt;- NormalizeData(pbmc) # pbmc &lt;- NormalizeData(pbmc, normalization.method = &quot;LogNormalize&quot;, scale.factor = 10000) # 默认值 虽然这种标准化方法是 scRNA-seq 分析中的标准且广泛使用的方法，但全局缩放依赖于每个细胞最初包含相同数量 RNA 分子的假设。我们和其他人已经开发了单细胞预处理的替代工作流程，这些工作流程不作这些假设。对于感兴趣的用户，请查看我们的 SCTransform() 标准化工作流程。该方法在我们的论文中有所描述，此处提供了一个使用 Seurat 的单独 vignette。使用 SCTransform 取代了运行 NormalizeData 、 FindVariableFeatures 或 ScaleData （如下所述）的需要。 1.4 高度可变特征的识别（特征选择） 计算数据集中表现出高度细胞间变异的特征子集（即，它们在某些细胞中高度表达，而在另一些细胞中低表达）。在下游分析中关注这些基因有助于突出单细胞数据集中的生物学信号。 # 默认情况下，我们每个数据集返回 2,000 个特征。这些将用于下游分析，如 PCA。 pbmc &lt;- FindVariableFeatures(pbmc, selection.method = &quot;vst&quot;, nfeatures = 2000) # 识别 10 个变异程度最高的基因 top10 &lt;- head(VariableFeatures(pbmc), 10) # 绘制带标签和不带标签的变量特征 plot1 &lt;- VariableFeaturePlot(pbmc) plot2 &lt;- LabelPoints(plot = plot1, points = top10, repel = TRUE) plot1 + plot2 1.5 缩放数据 应用线性变换（“缩放”），这是像 PCA 这样的降维技术之前的标准预处理步骤。 ScaleData() 函数： - 移动每个基因的表达，使细胞间的平均表达为 0. - 缩放每个基因的表达，使细胞间的方差为 1. - 这一步在下游分析中给予相同的权重，以便高表达的基因不会占主导地位. - 结果存储在 pbmc[[“RNA”]]$scale.data 中. - 默认情况下，仅缩放可变特征。 - 可以指定 features 参数来缩放其他特征 all.genes &lt;- rownames(pbmc) pbmc &lt;- ScaleData(pbmc, features = all.genes) 如何消除不希望的变异来源 在 Seurat 中，还可以使用 ScaleData() 函数从单细胞数据集中去除不需要的变异来源。例如，我们可以“消除”与细胞周期阶段或线粒体污染相关的异质性，即： pbmc &lt;- ScaleData(pbmc, vars.to.regress = &quot;percent.mt&quot;) 1.6 线性降维 对缩放后的数据执行 PCA。默认情况下，仅使用先前确定的可变特征作为输入，但如果您想选择不同的子集，可以使用 features 参数进行定义（如果您确实想使用自定义的特征子集，请确保首先将这些特征传递给 ScaleData ）。 pbmc &lt;- RunPCA(pbmc, features = VariableFeatures(object = pbmc)) print(pbmc[[&quot;pca&quot;]], dims = 1:5, nfeatures = 5) ## PC_ 1 ## Positive: CST3, TYROBP, LST1, AIF1, FTL ## Negative: MALAT1, LTB, IL32, IL7R, CD2 ## PC_ 2 ## Positive: CD79A, MS4A1, TCL1A, HLA-DQA1, HLA-DQB1 ## Negative: NKG7, PRF1, CST7, GZMB, GZMA ## PC_ 3 ## Positive: HLA-DQA1, CD79A, CD79B, HLA-DQB1, HLA-DPB1 ## Negative: PPBP, PF4, SDPR, SPARC, GNG11 ## PC_ 4 ## Positive: HLA-DQA1, CD79B, CD79A, MS4A1, HLA-DQB1 ## Negative: VIM, IL7R, S100A6, IL32, S100A8 ## PC_ 5 ## Positive: GZMB, NKG7, S100A8, FGFBP2, GNLY ## Negative: LTB, IL7R, CKB, VIM, MS4A7 Seurat 提供了几种有用的方法来可视化定义 PCA 的细胞和特征，包括 VizDimReduction() 、 DimPlot() 和 DimHeatmap() VizDimLoadings(pbmc, dims = 1:2, reduction = &quot;pca&quot;) DimPlot(pbmc, reduction = &quot;pca&quot;) + NoLegend() # 将 cells 设置为一个数字会绘制光谱两端的“极端”单元格，这大大加快了大型数据集的绘图速度。 DimHeatmap(pbmc, dims = 1, cells = 500, balanced = TRUE) DimHeatmap(pbmc, dims = 1:15, cells = 500, balanced = TRUE) 1.7 确定数据集的“维度” 为了克服 scRNA-seq 数据中单个特征的大量技术噪音，Seurat 基于细胞的 PCA 得分对细胞进行聚类，每个 PC 本质上代表一个“元特征”，它整合了相关特征集的信息。因此，最重要的主成分代表了数据集的稳健压缩。但是，我们应该选择包含多少个组件呢？ “肘部图”：基于每个主成分解释的方差百分比对主成分进行排序（ ElbowPlot() 函数）。 ElbowPlot(pbmc) 可以观察到 PC9-10 附近的“肘部”，这表明大部分真实信号都在前 10 个 PC 中捕获。 确定 “维度” 的其他函数 pbmc &lt;- JackStraw(pbmc, num.replicate = 100) # 通过置换检验来评估每个主成分的重要性。 pbmc &lt;- ScoreJackStraw(pbmc, dims = 1:20) # 比较实际数据和置换数据之间的差异，计算每个主成分的显著性得分。 JackStrawPlot(pbmc, dims = 1:20) # 可视化每个主成分的显著性得分 1.8 细胞聚类 Seurat 应用了一种基于图的聚类方法，该方法建立在 (Macosko et al) 中的初始策略之上。重要的是，驱动聚类分析的距离度量（基于先前识别的 PC）保持不变。简而言之，这些方法将细胞嵌入到图结构中——例如，K 最近邻 (KNN) 图，其中在具有相似特征表达模式的细胞之间绘制边，然后尝试将此图划分为高度互连的“准团”或“社区”。 与 PhenoGraph 类似，我们首先基于 PCA 空间中的欧几里得距离构建 KNN 图，并根据其局部邻域中的共享重叠（Jaccard 相似性）细化任意两个细胞之间的边缘权重。此步骤使用 FindNeighbors() 函数执行，并将先前定义的数据集维度（前 10 个 PC）作为输入。 为了对细胞进行聚类，我们接下来应用模块化优化技术，例如 Louvain 算法（默认）或 SLM [SLM, Blondel et al., Journal of Statistical Mechanics]，以迭代地将细胞组合在一起，目标是优化标准模块化函数。 FindClusters() 函数实现了此过程，并包含一个分辨率参数，该参数设置下游聚类的“粒度”，增加的值会导致更多的聚类。我们发现，将此参数设置为 0.4-1.2 通常会为大约 3K 细胞的单细胞数据集返回良好的结果。对于较大的数据集，最佳分辨率通常会增加。可以使用 Idents() 函数找到聚类。 # 结合JackStrawPlot和ElbowPlot，挑选10个PC，所以这里dims定义为1:10 pbmc &lt;- FindNeighbors(pbmc, dims = 1:10) pbmc &lt;- FindClusters(pbmc, resolution = 0.5) ## Modularity Optimizer version 1.3.0 by Ludo Waltman and Nees Jan van Eck ## ## Number of nodes: 2638 ## Number of edges: 95927 ## ## Running Louvain algorithm... ## Maximum modularity in 10 random starts: 0.8728 ## Number of communities: 9 ## Elapsed time: 0 seconds # 结果聚成几类，用Idents查看 head(Idents(pbmc), 5) ## AAACATACAACCAC-1 AAACATTGAGCTAC-1 AAACATTGATCAGC-1 AAACCGTGCTTCCG-1 ## 2 3 2 1 ## AAACCGTGTATGCG-1 ## 6 ## Levels: 0 1 2 3 4 5 6 7 8 length(levels(Idents(pbmc))) ## [1] 9 确定聚类“粒度”的方法 设置不同的分辨率，观察分群效果() library(cowplot) library(clustree) input_sce.all &lt;- pbmc for (res in c(0.01, 0.05, 0.1, 0.2, 0.3, 0.5, 0.8, 1)) { input_sce.all &lt;- FindClusters(input_sce.all, #graph.name = &quot;CCA_snn&quot;, resolution = res, algorithm = 1) } apply(input_sce.all@meta.data[,grep(&quot;RNA_snn&quot;,colnames(input_sce.all@meta.data))],2,table) p1_dim &lt;- plot_grid(ncol = 4, DimPlot(input_sce.all, reduction = &quot;umap&quot;, group.by = &quot;RNA_snn_res.0.01&quot;) + ggtitle(&quot;louvain_0.01&quot;), DimPlot(input_sce.all, reduction = &quot;umap&quot;, group.by = &quot;RNA_snn_res.0.05&quot;) + ggtitle(&quot;louvain_0.05&quot;), DimPlot(input_sce.all, reduction = &quot;umap&quot;, group.by = &quot;RNA_snn_res.0.1&quot;) + ggtitle(&quot;louvain_0.1&quot;), DimPlot(input_sce.all, reduction = &quot;umap&quot;, group.by = &quot;RNA_snn_res.0.2&quot;) + ggtitle(&quot;louvain_0.2&quot;)) p1_dim # ggsave(plot=p1_dim, filename=&quot;Dimplot_diff_resolution_low.pdf&quot;,width = 14) p2_dim &lt;- plot_grid(ncol = 4, DimPlot(input_sce.all, reduction = &quot;umap&quot;, group.by = &quot;RNA_snn_res.0.3&quot;) + ggtitle(&quot;louvain_0.3&quot;), DimPlot(input_sce.all, reduction = &quot;umap&quot;, group.by = &quot;RNA_snn_res.0.5&quot;) + ggtitle(&quot;louvain_0.5&quot;), DimPlot(input_sce.all, reduction = &quot;umap&quot;, group.by = &quot;RNA_snn_res.0.8&quot;) + ggtitle(&quot;louvain_0.8&quot;), DimPlot(input_sce.all, reduction = &quot;umap&quot;, group.by = &quot;RNA_snn_res.1&quot;) + ggtitle(&quot;louvain_1&quot;)) p2_dim # ggsave(plot = p2_dim, filename = &quot;Dimplot_diff_resolution_high.pdf&quot;, width = 18) p2_tree &lt;- clustree(input_sce.all@meta.data, prefix = &quot;RNA_snn_res.&quot;) p2_tree # ggsave(plot = p2_tree, filename=&quot;Tree_diff_resolution.pdf&quot;) 1.9 运行非线性降维（UMAP/tSNE） Seurat 提供了几种非线性降维技术，例如 tSNE 和 UMAP，用于可视化和探索这些数据集。这些算法的目标是学习数据集中的底层结构，以便将相似的细胞放置在低维空间中。因此，在上面确定的基于图的聚类中分组在一起的细胞应该在这些降维图中共同定位。 虽然我们和其他人经常发现像 tSNE 和 UMAP 这样的 2D 可视化技术是探索数据集的宝贵工具，但所有可视化技术都有局限性，并且无法完全代表底层数据的复杂性。特别是，这些方法旨在保留数据集中的局部距离（即，确保具有非常相似的基因表达谱的细胞共同定位），但通常不保留更全局的关系。我们鼓励用户利用像 UMAP 这样的技术进行可视化，但要避免仅基于可视化技术得出生物学结论。 pbmc &lt;- RunUMAP(pbmc, dims = 1:10) # 可以设置 `label = TRUE` 或使用 LabelClusters 函数来帮助标记各个簇 DimPlot(pbmc, reduction = &quot;umap&quot;, label = TRUE) 1.10 寻找差异表达的特征（聚类 Marker） 啥叫marker基因呢。和差异基因里面的上调基因有点类似，某个基因在某一簇细胞里表达量都很高，在其他簇表达量很低，那么这个基因就是这簇细胞的象征。 Seurat 可以帮助您找到通过差异表达 (DE) 定义聚类的标记。默认情况下，它识别单个聚类的阳性和阴性标记（在 ident.1 中指定），与其他所有细胞相比。 FindAllMarkers() 自动执行所有聚类的此过程，但您也可以测试聚类组之间，或针对所有细胞进行测试。 在 Seurat v5 中，我们使用 presto 包以显著提高 DE 分析的速度，特别是对于大型数据集。对于未使用 presto 的用户，您可以查看此函数 ( ?FindMarkers ) 的文档，以探索 min.pct 和 logfc.threshold 参数，可以增加这些参数以提高 DE 测试的速度。 # 找到 cluster 2 的 marker 基因 cluster2.markers &lt;- FindMarkers(pbmc, ident.1 = 2) head(cluster2.markers, n = 5) ## p_val avg_log2FC pct.1 pct.2 p_val_adj ## IL32 2.892340e-90 1.3070772 0.947 0.465 3.966555e-86 ## LTB 1.060121e-86 1.3312674 0.981 0.643 1.453850e-82 ## CD3D 8.794641e-71 1.0597620 0.922 0.432 1.206097e-66 ## IL7R 3.516098e-68 1.4377848 0.750 0.326 4.821977e-64 ## LDHB 1.642480e-67 0.9911924 0.954 0.614 2.252497e-63 # 找出区分簇 5 与簇 0 和簇 3 的所有标记 cluster5.markers &lt;- FindMarkers(pbmc, ident.1 = 5, ident.2 = c(0, 3)) head(cluster5.markers, n = 5) ## p_val avg_log2FC pct.1 pct.2 p_val_adj ## FCGR3A 8.246578e-205 6.794969 0.975 0.040 1.130936e-200 ## IFITM3 1.677613e-195 6.192558 0.975 0.049 2.300678e-191 ## CFD 2.401156e-193 6.015172 0.938 0.038 3.292945e-189 ## CD68 2.900384e-191 5.530330 0.926 0.035 3.977587e-187 ## RP11-290F20.3 2.513244e-186 6.297999 0.840 0.017 3.446663e-182 # 为每个簇与所有剩余细胞相比寻找标记物，仅报告阳性结果 pbmc.markers &lt;- FindAllMarkers(pbmc, only.pos = TRUE) pbmc.markers %&gt;% group_by(cluster) %&gt;% dplyr::filter(avg_log2FC &gt; 1) ## # A tibble: 7,019 × 7 ## # Groups: cluster [9] ## p_val avg_log2FC pct.1 pct.2 p_val_adj cluster gene ## &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;fct&gt; &lt;chr&gt; ## 1 3.75e-112 1.21 0.912 0.592 5.14e-108 0 LDHB ## 2 9.57e- 88 2.40 0.447 0.108 1.31e- 83 0 CCR7 ## 3 1.15e- 76 1.06 0.845 0.406 1.58e- 72 0 CD3D ## 4 1.12e- 54 1.04 0.731 0.4 1.54e- 50 0 CD3E ## 5 1.35e- 51 2.14 0.342 0.103 1.86e- 47 0 LEF1 ## 6 1.94e- 47 1.20 0.629 0.359 2.66e- 43 0 NOSIP ## 7 2.81e- 44 1.53 0.443 0.185 3.85e- 40 0 PIK3IP1 ## 8 6.27e- 43 1.99 0.33 0.112 8.60e- 39 0 PRKCQ-AS1 ## 9 1.16e- 40 2.70 0.2 0.04 1.59e- 36 0 FHIT ## 10 1.34e- 34 1.96 0.268 0.087 1.84e- 30 0 MAL ## # ℹ 7,009 more rows 我们包含几个用于可视化标记表达的工具。 VlnPlot() （显示跨集群的表达概率分布）和 FeaturePlot() （在 tSNE 或 PCA 图上可视化特征表达）是我们最常用的可视化方法。我们还建议探索 RidgePlot() 、 CellScatter() 和 DotPlot() 作为查看数据集的附加方法。 VlnPlot(pbmc, features = c(&quot;MS4A1&quot;, &quot;CD79A&quot;)) # 你也可以绘制原始计数 VlnPlot(pbmc, features = c(&quot;NKG7&quot;, &quot;PF4&quot;), slot = &quot;counts&quot;, log = TRUE) FeaturePlot(pbmc, features = c(&quot;MS4A1&quot;, &quot;GNLY&quot;, &quot;CD3E&quot;, &quot;CD14&quot;)) pbmc.markers %&gt;% group_by(cluster) %&gt;% dplyr::filter(avg_log2FC &gt; 1) %&gt;% slice_head(n = 10) %&gt;% ungroup() -&gt; top10 DoHeatmap(pbmc, features = top10$gene) + NoLegend() 1.11 根据 marker 基因确定细胞 new.cluster.ids &lt;- c(&quot;Naive CD4 T&quot;, &quot;CD14+ Mono&quot;, &quot;Memory CD4 T&quot;, &quot;B&quot;, &quot;CD8 T&quot;, &quot;FCGR3A+ Mono&quot;, &quot;NK&quot;, &quot;DC&quot;, &quot;Platelet&quot;) names(new.cluster.ids) &lt;- levels(pbmc) pbmc &lt;- RenameIdents(pbmc, new.cluster.ids) pbmc$seurat_annotations &lt;- Idents(pbmc) DimPlot(pbmc, reduction = &quot;umap&quot;, label = TRUE, pt.size = 0.5) + NoLegend() 保存结果 library(ggplot2) plot &lt;- DimPlot(pbmc, reduction = &quot;umap&quot;, label = TRUE, label.size = 4.5) + xlab(&quot;UMAP 1&quot;) + ylab(&quot;UMAP 2&quot;) + theme(axis.title = element_text(size = 18), legend.text = element_text(size = 18)) + guides(colour = guide_legend(override.aes = list(size = 10))) ggsave(filename = &quot;../output/images/pbmc3k_umap.jpg&quot;, height = 7, width = 12, plot = plot, quality = 50) saveRDS(pbmc, file = &quot;../output/pbmc3k_final.rds&quot;) "],["seurat-数据可视化.html", "第 2 章 Seurat 数据可视化 2.1 标记 Marker 基因表达的五种可视化方式 2.2 ggplot2 联用 2.3 交互式绘图功能 2.4 绘图辅助工具", " 第 2 章 Seurat 数据可视化 Seurat 内可视化功能的概览。 library(Seurat) library(SeuratData) library(ggplot2) library(patchwork) pbmc3k.final &lt;- LoadData(&quot;pbmc3k&quot;, type = &quot;pbmc3k.final&quot;) pbmc3k.final$groups &lt;- sample(c(&quot;group1&quot;, &quot;group2&quot;), size = ncol(pbmc3k.final), replace = TRUE) features &lt;- c(&quot;LYZ&quot;, &quot;CCL5&quot;, &quot;IL32&quot;, &quot;PTPRCAP&quot;, &quot;FCGR3A&quot;, &quot;PF4&quot;) pbmc3k.final ## An object of class Seurat ## 13714 features across 2638 samples within 1 assay ## Active assay: RNA (13714 features, 2000 variable features) ## 3 layers present: data, counts, scale.data ## 2 dimensional reductions calculated: pca, umap 2.1 标记 Marker 基因表达的五种可视化方式 2.1.1 山脊图 # 源自 ggridges。 RidgePlot(pbmc3k.final, features = features, ncol = 2) 2.1.2 小提琴图 VlnPlot(pbmc3k.final, features = features) # 小提琴图也可以根据某些变量进行分割。只需将分割变量添加到对象元数据中，并将其传递给 split.by 参数 VlnPlot(pbmc3k.final, features = &quot;percent.mt&quot;, split.by = &quot;groups&quot;) 2.1.3 特征图 # 在低维空间中可视化特征表达 FeaturePlot(pbmc3k.final, features = features) # 绘制图例以将颜色映射到表达水平 FeaturePlot(pbmc3k.final, features = &quot;MS4A1&quot;) # 调整图中的对比度 FeaturePlot(pbmc3k.final, features = &quot;MS4A1&quot;, min.cutoff = 1, max.cutoff = 3) # 基于非零表达的分位数计算特定特征的对比度水平，在绘制多个标记时尤为实用。 FeaturePlot(pbmc3k.final, features = c(&quot;MS4A1&quot;, &quot;PTPRCAP&quot;), min.cutoff = &quot;q10&quot;, max.cutoff = &quot;q90&quot;) # 可视化两个基因的共表达情况 FeaturePlot(pbmc3k.final, features = c(&quot;MS4A1&quot;, &quot;CD79A&quot;), blend = TRUE) # 将可视化拆分以按组查看表达（替代 FeatureHeatmap） FeaturePlot(pbmc3k.final, features = c(&quot;MS4A1&quot;, &quot;CD79A&quot;), split.by = &quot;groups&quot;) 2.1.4 点图 # 点的大小对应于表达该基因的细胞百分比 # 每个簇中的特征。颜色代表平均表达水平 DotPlot(pbmc3k.final, features = features) + RotatedAxis() # SplitDotPlotGG 已被替换为 DotPlot 的 `split.by` 参数 DotPlot(pbmc3k.final, features = features, split.by = &quot;groups&quot;) + RotatedAxis() # DimPlot 替代了 TSNEPlot、PCAPlot 等。此外，默认情况下它会按顺序绘制&#39;umap&#39;、&#39;tsne&#39;或 &#39;pca&#39; DimPlot(pbmc3k.final) pbmc3k.final.no.umap &lt;- pbmc3k.final pbmc3k.final.no.umap[[&quot;umap&quot;]] &lt;- NULL DimPlot(pbmc3k.final.no.umap) + RotatedAxis() 2.1.5 热图 DoHeatmap(subset(pbmc3k.final, downsample = 100), features = features, size = 3) # DoHeatmap 现在显示一个分组条，将热图分割成组或簇。这可以通过`group.by`参数进行更改 DoHeatmap(pbmc3k.final, features = VariableFeatures(pbmc3k.final)[1:100], cells = 1:500, size = 4, angle = 90) + NoLegend() 2.2 ggplot2 联用 baseplot &lt;- DimPlot(pbmc3k.final, reduction = &quot;umap&quot;) # 添加自定义 title baseplot + labs(title = &quot;Clustering of 2,700 PBMCs&quot;) # 使用社区创建的主题，覆盖默认的 Seurat 应用主题 # remotes::install_github(&#39;sjessa/ggmin&#39;) baseplot + ggmin::theme_powerpoint() # Seurat 还提供了几种内置主题，例如 DarkTheme；更多详情请参阅 # ?SeuratTheme baseplot + DarkTheme() # 将主题串联起来 baseplot + FontSize(x.title = 20, y.title = 20) + NoLegend() 2.3 交互式绘图功能 2.3.1 HoverLocator Seurat 利用 R 的 plotly 图形库创建交互式图表。这一交互式绘图功能适用于任何基于 ggplot2 的散点图（需要包含geom_point 图层）。使用时，只需创建一个基于 ggplot2 的散点图（例如 DimPlot() 或 FeaturePlot() ），然后将生成的图表传递给 HoverLocator() 函数即可。 # 通过传入信息的数据框，包含额外的数据以与单元格名称一起显示。在使用 FetchData 时效果良好。 plot &lt;- FeaturePlot(pbmc3k.final, features = &quot;MS4A1&quot;) HoverLocator(plot = plot, information = FetchData(pbmc3k.final, vars = c(&quot;ident&quot;, &quot;PC_1&quot;, &quot;nFeature_RNA&quot;))) 2.3.2 CellSelector Seurat 提供的另一项交互功能是能够手动选择细胞进行进一步研究。我们发现这对于那些不总是通过无偏聚类分离、但看起来明显不同的小簇特别有用。现在，您可以通过创建一个基于 ggplot2 的散点图（例如使用 DimPlot() 或 FeaturePlot() ），并将返回的图传递给 CellSelector() 来选择这些细胞。 CellSelector() 将返回一个包含所选点名称的向量，以便您可以将它们设置为新的身份类别并执行差异表达分析。 例如，假设在聚类过程中树突状细胞（DCs）与单核细胞合并了，但我们想根据它们在 tSNE 图中的位置来观察它们的独特之处。 pbmc3k.final &lt;- RenameIdents(pbmc3k.final, DC = &quot;CD14+ Mono&quot;) plot &lt;- DimPlot(pbmc3k.final, reduction = &quot;umap&quot;) select.cells &lt;- CellSelector(plot = plot) head(select.cells) # 然后我们可以更改这些细胞的标识，将它们转化为自己的小型簇 Idents(pbmc3k.final, cells = select.cells) &lt;- &quot;NewCells&quot; # 现在，我们寻找特定于新细胞的标记物，并找到明确的树突状细胞标记物 newcells.markers &lt;- FindMarkers(pbmc3k.final, ident.1 = &quot;NewCells&quot;, ident.2 = &quot;CD14+ Mono&quot;, min.diff.pct = 0.3, only.pos = TRUE) head(newcells.markers) 使用 CellSelector 自动分配细胞身份 除了返回细胞名称的向量外， CellSelector() 还可以获取选定的细胞并为它们分配新的身份标识，返回一个已设置身份类别的 Seurat 对象。这是通过将用于生成绘图的 Seurat 对象传递到 CellSelector() 并指定一个身份类别来实现的。例如，我们将选择与之前相同的细胞集，并将它们的身份类别设置为“selected”。 pbmc3k.final &lt;- CellSelector(plot = plot, object = pbmc3k.final, ident = &quot;selected&quot;) levels(pbmc3k.final) 2.4 绘图辅助工具 LabelClusters 和 LabelPoints 将在基于 ggplot2 的散点图上标注聚类（着色变量）或单个点 plot &lt;- DimPlot(pbmc3k.final, reduction = &quot;pca&quot;) + NoLegend() LabelClusters(plot = plot, id = &quot;ident&quot;) 两个函数都支持repel功能，它能智能地错开标签位置，并绘制从标签指向点或簇的连接线 LabelPoints(plot = plot, points = TopCells(object = pbmc3k.final[[&quot;pca&quot;]]), repel = TRUE) plot1 &lt;- DimPlot(pbmc3k.final) # Create scatter plot with the Pearson correlation value as the title plot2 &lt;- FeatureScatter(pbmc3k.final, feature1 = &quot;LYZ&quot;, feature2 = &quot;CCL5&quot;) # Combine two plots plot1 + plot2 # Remove the legend from all plots (plot1 + plot2) &amp; NoLegend() "],["seurat-中使用-sctransform-方法.html", "第 3 章 Seurat 中使用 sctransform 方法 3.1 设置 Seurat 对象 3.2 应用 sctransform 标准化方法 3.3 通过 PCA 降维和 UMAP 嵌入进行维度缩减", " 第 3 章 Seurat 中使用 sctransform 方法 使用更新版 sctransform 进行归一化、特征选择、整合及差异表达分析的示例。 单细胞 RNA 测序数据中的生物学异质性常被技术因素（如测序深度）所混淆。即便在同一细胞类型中，各细胞检测到的分子数量也可能存在显著差异。要准确解读 scRNA-seq 数据，需通过有效的预处理和标准化步骤来消除这类技术性变异。 在本论文中，我们提出了一种用于单细胞 RNA 测序实验分子计数数据标准化和方差稳定的建模框架。该方法避免了伪计数添加或对数转换等启发式步骤，并改善了常见的下游分析任务，如可变基因选择、降维和差异表达分析。我们将此方法命名为 sctransform 。 library(Seurat) library(ggplot2) library(sctransform) 3.1 设置 Seurat 对象 library(SeuratData) pbmc &lt;- LoadData(&quot;pbmc3k&quot;, type = &quot;pbmc3k&quot;) pbmc ## An object of class Seurat ## 13714 features across 2638 samples within 1 assay ## Active assay: RNA (13714 features, 2000 variable features) ## 3 layers present: data, counts, scale.data ## 2 dimensional reductions calculated: pca, umap 3.2 应用 sctransform 标准化方法 请注意，这一条指令替代了 NormalizeData() 、 ScaleData() 和 FindVariableFeatures() 的功能。 转换后的数据将存储在 SCT 分析模块中，该模块在执行 sctransform 后会被设为默认选项。 在标准化过程中，我们还可以消除混杂的变异来源，例如线粒体映射百分比。 在 Seurat v5 版本中，默认采用 SCT v2 算法。如需切换回 v1 版本，可通过设置 vst.flavor = ‘v1’ 实现。 glmGamPoi 包显著提高了速度，若已安装则默认使用，具体操作指南见此处. # 将线粒体百分比存储在对象元数据中 pbmc &lt;- PercentageFeatureSet(pbmc, pattern = &quot;^MT-&quot;, col.name = &quot;percent.mt&quot;) # run sctransform pbmc &lt;- SCTransform(pbmc, vars.to.regress = &quot;percent.mt&quot;, verbose = FALSE) 3.3 通过 PCA 降维和 UMAP 嵌入进行维度缩减 # These are now standard steps in the Seurat workflow for visualization and clustering pbmc &lt;- RunPCA(pbmc, verbose = FALSE) pbmc &lt;- FindNeighbors(pbmc, dims = 1:30, verbose = FALSE) pbmc &lt;- FindClusters(pbmc, verbose = FALSE) pbmc &lt;- RunUMAP(pbmc, dims = 1:30, verbose = FALSE) DimPlot(pbmc, label = TRUE) 为什么在使用 sctransform 时可以选择更多的主成分？ 在标准的 Seurat 工作流程中，我们针对此数据集主要关注 10 个主成分（PCs），但需要指出的是，即使调高该参数设置，结果也较为相似。有趣的是，我们发现使用 sctransform 时，通过进一步提高该参数往往能带来额外益处。我们认为这是因为 sctransform 工作流程执行了更高效的标准化处理，能强力消除数据中的技术性干扰。 即便经过标准的对数归一化处理，测序深度的差异仍是一个混杂因素，这种影响可能微妙地干扰更高阶的主成分。而在 sctransform 中，该效应得到了显著缓解。这意味着高阶主成分更有可能反映微妙但具有生物学意义的异质性来源——因此包含这些成分可能会改进下游分析。 此外，sctransform 默认返回 3,000 个可变特征，而非 2,000 个。其原理类似：额外的可变特征较少受到细胞间技术差异的影响，反而可能反映更细微的生物学波动。总体而言，我们发现使用 sctransform 得到的结果对这些参数的依赖性更低（事实上，当使用转录组中所有基因时，我们获得了几乎一致的结果，尽管这会降低计算效率）。这有助于用户获得更稳健的结果，同时还能应用标准分析流程——通过相同的参数设置可快速应用于新数据集： 例如，以下代码通过单一命令复现了完整的端到端工作流程： pbmc1 &lt;- CreateSeuratObject(pbmc_data) %&gt;% PercentageFeatureSet(pattern = &quot;^MT-&quot;, col.name = &quot;percent.mt&quot;) %&gt;% SCTransform(vars.to.regress = &quot;percent.mt&quot;) %&gt;% RunPCA() %&gt;% FindNeighbors(dims = 1:30) %&gt;% FindClusters() %&gt;% RunUMAP(dims = 1:30) sctransform 的归一化值存储在哪里？ sctransform 的结果存储在“SCT”分析中。您可以在我们的 vignette、命令速查表或开发者指南中了解更多关于 Seurat 中多分析数据和命令的信息。 pbmc[[\"SCT\"]]$scale.data 包含残差（标准化值），并直接作为 PCA 的输入。请注意该矩阵是非稀疏的，因此若为所有基因存储会占用大量内存。为节省内存，我们默认在 SCTransform() 函数调用中设置 return.only.var.genes = TRUE，仅存储可变基因的这些值。 为辅助可视化和解释，我们还将皮尔逊残差转换回‘校正后’的 UMI 计数。您可将其理解为所有细胞测序深度相同时预期观察到的 UMI 计数。若需了解具体实现方式，请参阅此处的校正函数。 ’校正后’的 UMI 计数存储在 pbmc[[\"SCT\"]]$counts 中。我们将这些校正计数的对数标准化版本存储在 pbmc[[\"SCT\"]]$data 中，这对可视化非常有帮助。 用户可根据经典标记物独立注释细胞群。然而，sctransform 标准化方法在多个方面展现出比标准 Seurat 流程更清晰的生物学区分： 基于 CD8A、GZMK、CCL5、CCR7 的表达谱，清晰区分至少 3 个 CD8 T 细胞亚群（初始态、记忆态、效应态）. 依据 S100A4、CCR7、IL32 和 ISG15 的表达，明确分离出三个 CD4 T 细胞亚群（初始态、记忆态、IFN 激活态）. B 细胞群中基于 TCL1A 和 FCER2 标记物，显示出额外的发育亚结构特征. 将 NK 细胞进一步区分为 CD56dim 与 bright 亚群，依据 XCL1 和 FCGR3A 标记基因. # 这些现在是 Seurat 工作流程中用于可视化和聚类的标准步骤 将经典标记基因可视化为小提琴图。 VlnPlot(pbmc, features = c(&quot;CD8A&quot;, &quot;GZMK&quot;, &quot;CCL5&quot;, &quot;S100A4&quot;, &quot;ANXA1&quot;, &quot;CCR7&quot;, &quot;ISG15&quot;, &quot;CD3D&quot;), pt.size = 0.2, ncol = 4) # 在 sctransform 嵌入上可视化规范标记基因。 FeaturePlot(pbmc, features = c(&quot;CD8A&quot;, &quot;GZMK&quot;, &quot;CCL5&quot;, &quot;S100A4&quot;, &quot;ANXA1&quot;, &quot;CCR7&quot;), pt.size = 0.2, ncol = 3) FeaturePlot(pbmc, features = c(&quot;CD3D&quot;, &quot;ISG15&quot;, &quot;TCL1A&quot;, &quot;FCER2&quot;, &quot;XCL1&quot;, &quot;FCGR3A&quot;), pt.size = 0.2, ncol = 3) "],["scrna-seq-整合简介.html", "第 4 章 scRNA-Seq 整合简介 4.1 设置 Seurat 对象 4.2 执行非整合分析 4.3 执行整合 4.4 识别保守的细胞类型标记基因 4.5 识别不同条件下的差异表达基因 4.6 使用 SCTransform 标准化数据集进行整合", " 第 4 章 scRNA-Seq 整合简介 整合 scRNA-Seq 数据集简介，旨在识别和比较不同实验间共享的细胞类型。 单细胞测序数据集的整合（例如跨实验批次、供体或条件）通常是 scRNA-seq 工作流程中的重要步骤。整合分析有助于匹配不同数据集间共有的细胞类型和状态，这既能增强统计效力，更重要的是能促进跨数据集的精确比较分析。在 Seurat 的早期版本中，我们已引入包括基于”锚点”的整合流程在内的多种整合分析方法。许多实验室也发表了强大且开创性的整合分析方法，如 Harmony 和 scVI。详情请参阅我们关于 《使用多种工具整合 scRNA-seq 数据》的教程文档。 本教程旨在概述利用 Seurat 整合流程对复杂细胞类型进行对比分析的多种可能性。我们主要关注以下几个关键目标： 识别在两个数据集中均存在的细胞亚群. 获取在对照组和刺激组细胞中均保守的细胞类型标记物. 对比数据集以寻找细胞类型对刺激的特异性反应. 4.1 设置 Seurat 对象 library(Seurat) library(SeuratData) library(patchwork) # install dataset # InstallData(&quot;ifnb&quot;) 该对象包含来自人类 PBMC 的两种条件数据：干扰素刺激细胞和对照细胞（存储在对象元数据的 stim 列中）。我们的目标是将这两种条件的数据整合在一起，以便能够跨数据集联合识别细胞亚群，并探索各组在不同条件下的差异。 在 Seurat 的早期版本中，我们需要将数据表示为两个不同的 Seurat 对象。而在 Seurat v5 中，我们将所有数据保留在同一个对象内，但将其分割为多个“层”。要了解更多关于层的信息，请参阅我们的 Seurat 对象交互指南。 # 加载数据 ifnb &lt;- LoadData(&quot;ifnb&quot;) # 将 RNA 测量数据分为两层，一层用于对照细胞，一层用于刺激细胞 ifnb[[&quot;RNA&quot;]] &lt;- split(ifnb[[&quot;RNA&quot;]], f = ifnb$stim) ifnb ## An object of class Seurat ## 14053 features across 13999 samples within 1 assay ## Active assay: RNA (14053 features, 0 variable features) ## 4 layers present: counts.CTRL, counts.STIM, data.CTRL, data.STIM 4.2 执行非整合分析 我们可以首先在不进行整合的情况下分析数据集。由此产生的聚类既由细胞类型又受刺激条件影响，这给下游分析带来了挑战。 # 跑标准分析流程 ifnb &lt;- NormalizeData(ifnb) ifnb &lt;- FindVariableFeatures(ifnb) ifnb &lt;- ScaleData(ifnb) ifnb &lt;- RunPCA(ifnb) ifnb &lt;- FindNeighbors(ifnb, dims = 1:30, reduction = &quot;pca&quot;) ifnb &lt;- FindClusters(ifnb, resolution = 2, cluster.name = &quot;unintegrated_clusters&quot;) ## Modularity Optimizer version 1.3.0 by Ludo Waltman and Nees Jan van Eck ## ## Number of nodes: 13999 ## Number of edges: 555146 ## ## Running Louvain algorithm... ## Maximum modularity in 10 random starts: 0.8153 ## Number of communities: 26 ## Elapsed time: 1 seconds ifnb &lt;- RunUMAP(ifnb, dims = 1:30, reduction = &quot;pca&quot;, reduction.name = &quot;umap.unintegrated&quot;) DimPlot(ifnb, reduction = &quot;umap.unintegrated&quot;, group.by = c(&quot;stim&quot;, &quot;seurat_clusters&quot;)) 4.3 执行整合 我们现在旨在整合两种条件下的数据，使得来自相同细胞类型/亚群的细胞能够聚类在一起。 我们通常将此过程称为整合/比对。在将两个基因组序列进行比对时，识别共享/同源区域有助于解释序列间的差异。类似地，对于单细胞 RNA 测序数据的整合，我们的目标并非消除不同条件间的生物学差异，而是首先识别共享的细胞类型/状态——这能让我们针对这些特定细胞类型比较刺激组与对照组的表达谱。 Seurat v5 整合流程旨在返回一个捕捉多组数据间共同变异来源的降维结果，使处于相似生物学状态的细胞得以聚类。该方法生成的降维结果（即 integrated.cca ）可用于可视化与无监督聚类分析。评估性能时，我们可以使用预加载在 seurat_annotations 元数据列中的细胞类型标签。 ifnb &lt;- IntegrateLayers(object = ifnb, method = CCAIntegration, orig.reduction = &quot;pca&quot;, new.reduction = &quot;integrated.cca&quot;, verbose = FALSE) # 集成后重新合并图层 ifnb[[&quot;RNA&quot;]] &lt;- JoinLayers(ifnb[[&quot;RNA&quot;]]) ifnb &lt;- FindNeighbors(ifnb, reduction = &quot;integrated.cca&quot;, dims = 1:30) ifnb &lt;- FindClusters(ifnb, resolution = 1) ## Modularity Optimizer version 1.3.0 by Ludo Waltman and Nees Jan van Eck ## ## Number of nodes: 13999 ## Number of edges: 590406 ## ## Running Louvain algorithm... ## Maximum modularity in 10 random starts: 0.8448 ## Number of communities: 18 ## Elapsed time: 1 seconds ifnb &lt;- RunUMAP(ifnb, dims = 1:30, reduction = &quot;integrated.cca&quot;) DimPlot(ifnb, reduction = &quot;umap&quot;, group.by = c(&quot;stim&quot;, &quot;seurat_annotations&quot;)) 为了将两种条件并排可视化，我们可以使用 split.by 参数来显示按聚类着色的每种条件。 DimPlot(ifnb, reduction = &quot;umap&quot;, split.by = &quot;stim&quot;) 4.4 识别保守的细胞类型标记基因 为了识别在不同实验条件下保守的典型细胞类型标记基因，我们提供了 FindConservedMarkers() 函数。该函数对每个数据集/组进行差异基因表达分析，并利用 MetaDE R 包中的元分析方法合并 p 值。例如，我们可以计算在集群 6（自然杀伤细胞）中不受刺激条件影响的保守标记基因。 Idents(ifnb) &lt;- &quot;seurat_annotations&quot; nk.markers &lt;- FindConservedMarkers(ifnb, ident.1 = &quot;NK&quot;, grouping.var = &quot;stim&quot;, verbose = FALSE) head(nk.markers) ## CTRL_p_val CTRL_avg_log2FC CTRL_pct.1 CTRL_pct.2 CTRL_p_val_adj ## GNLY 0 6.854586 0.943 0.046 0 ## NKG7 0 5.358881 0.953 0.085 0 ## GZMB 0 5.078135 0.839 0.044 0 ## CLIC3 0 5.765314 0.601 0.024 0 ## CTSW 0 5.307246 0.537 0.030 0 ## KLRD1 0 5.261553 0.507 0.019 0 ## STIM_p_val STIM_avg_log2FC STIM_pct.1 STIM_pct.2 STIM_p_val_adj max_pval ## GNLY 0 6.435910 0.956 0.059 0 0 ## NKG7 0 4.971397 0.950 0.081 0 0 ## GZMB 0 5.151924 0.897 0.060 0 0 ## CLIC3 0 5.505208 0.623 0.031 0 0 ## CTSW 0 5.240729 0.592 0.035 0 0 ## KLRD1 0 4.852457 0.555 0.027 0 0 ## minimump_p_val ## GNLY 0 ## NKG7 0 ## GZMB 0 ## CLIC3 0 ## CTSW 0 ## KLRD1 0 可以对无监督聚类结果（存储在 seurat_clusters 中）执行相同的分析，并使用这些保守标记来注释数据集中的细胞类型。 带有 split.by 参数的 DotPlot() 函数可用于查看跨条件下保守的细胞类型标记，同时显示表达水平以及表达任何给定基因的细胞在簇中的百分比。这里我们为 14 个簇中的每一个绘制了 2-3 个强标记基因。 # 需要修复并正确设置顺序 Idents(ifnb) &lt;- factor(Idents(ifnb), levels = c(&quot;pDC&quot;, &quot;Eryth&quot;, &quot;Mk&quot;, &quot;DC&quot;, &quot;CD14 Mono&quot;, &quot;CD16 Mono&quot;, &quot;B Activated&quot;, &quot;B&quot;, &quot;CD8 T&quot;, &quot;NK&quot;, &quot;T activated&quot;, &quot;CD4 Naive T&quot;, &quot;CD4 Memory T&quot;)) markers.to.plot &lt;- c(&quot;CD3D&quot;, &quot;CREM&quot;, &quot;HSPH1&quot;, &quot;SELL&quot;, &quot;GIMAP5&quot;, &quot;CACYBP&quot;, &quot;GNLY&quot;, &quot;NKG7&quot;, &quot;CCL5&quot;, &quot;CD8A&quot;, &quot;MS4A1&quot;, &quot;CD79A&quot;, &quot;MIR155HG&quot;, &quot;NME1&quot;, &quot;FCGR3A&quot;, &quot;VMO1&quot;, &quot;CCL2&quot;, &quot;S100A9&quot;, &quot;HLA-DQA1&quot;, &quot;GPR183&quot;, &quot;PPBP&quot;, &quot;GNG11&quot;, &quot;HBA2&quot;, &quot;HBB&quot;, &quot;TSPAN13&quot;, &quot;IL3RA&quot;, &quot;IGJ&quot;, &quot;PRSS57&quot;) DotPlot(ifnb, features = markers.to.plot, cols = c(&quot;blue&quot;, &quot;red&quot;), dot.scale = 8, split.by = &quot;stim&quot;) + RotatedAxis() 4.5 识别不同条件下的差异表达基因 既然我们已经对齐了受刺激细胞和对照细胞，现在可以开始进行比较分析，观察刺激引发的差异。 我们可以通过 AggregateExpression 命令将相似类型和状态的细胞聚合并创建“伪批量”表达谱。作为初步探索性分析，我们可以比较两种细胞类型（初始 CD4 T 细胞和 CD14 单核细胞）的伪批量表达谱，并对比它们在刺激前后的基因表达特征。我们特别标注了对干扰素刺激反应显著的基因。如图所示，许多相同基因在这两种细胞类型中均上调表达，可能代表了一条保守的干扰素响应通路，不过 CD14 单核细胞表现出更强的转录响应。 library(ggplot2) library(cowplot) theme_set(theme_cowplot()) aggregate_ifnb &lt;- AggregateExpression(ifnb, group.by = c(&quot;seurat_annotations&quot;, &quot;stim&quot;), return.seurat = TRUE) genes.to.label = c(&quot;ISG15&quot;, &quot;LY6E&quot;, &quot;IFI6&quot;, &quot;ISG20&quot;, &quot;MX1&quot;, &quot;IFIT2&quot;, &quot;IFIT1&quot;, &quot;CXCL10&quot;, &quot;CCL8&quot;) p1 &lt;- CellScatter(aggregate_ifnb, &quot;CD14 Mono_CTRL&quot;, &quot;CD14 Mono_STIM&quot;, highlight = genes.to.label) p2 &lt;- LabelPoints(plot = p1, points = genes.to.label, repel = TRUE) p3 &lt;- CellScatter(aggregate_ifnb, &quot;CD4 Naive T_CTRL&quot;, &quot;CD4 Naive T_STIM&quot;, highlight = genes.to.label) p4 &lt;- LabelPoints(plot = p3, points = genes.to.label, repel = TRUE) p2 + p4 我们现在可以询问相同类型细胞在不同条件下哪些基因发生了变化。首先，我们在 meta.data 槽中创建一个列来保存细胞类型和刺激信息，并将当前标识切换为该列。然后，我们使用 FindMarkers()来寻找刺激和对照 B 细胞之间不同的基因。请注意，这里显示的许多顶级基因与我们之前绘制的核心干扰素反应基因相同。此外，像 CXCL10 这样的基因，我们之前看到它们对单核细胞和 B 细胞的干扰素反应具有特异性，也在这个列表中显示出高度显著性。 请注意，本分析得出的 p 值应谨慎解读，因为这些检验将每个细胞视为独立重复样本，忽略了源自同一样本的细胞间固有相关性。正如此处所述，跨多条件的差异表达（DE）检验应明确使用多个样本/重复，并可在将同一样本和亚群的细胞聚合（“伪批量”）后进行。由于数据中仅有一个重复样本，我们在此未执行此分析，但请参阅我们比较健康与糖尿病样本的示例教程，了解如何进行跨条件的 DE 分析。 ifnb$celltype.stim &lt;- paste(ifnb$seurat_annotations, ifnb$stim, sep = &quot;_&quot;) Idents(ifnb) &lt;- &quot;celltype.stim&quot; b.interferon.response &lt;- FindMarkers(ifnb, ident.1 = &quot;B_STIM&quot;, ident.2 = &quot;B_CTRL&quot;, verbose = FALSE) head(b.interferon.response, n = 15) ## p_val avg_log2FC pct.1 pct.2 p_val_adj ## ISG15 5.387767e-159 5.0588481 0.998 0.233 7.571429e-155 ## IFIT3 1.945114e-154 6.1124940 0.965 0.052 2.733468e-150 ## IFI6 2.503565e-152 5.4933132 0.965 0.076 3.518260e-148 ## ISG20 6.492570e-150 3.0549593 1.000 0.668 9.124009e-146 ## IFIT1 1.951022e-139 6.2320388 0.907 0.029 2.741772e-135 ## MX1 6.897626e-123 3.9798482 0.905 0.115 9.693234e-119 ## LY6E 2.825649e-120 3.7907800 0.898 0.150 3.970885e-116 ## TNFSF10 4.007285e-112 6.5802175 0.786 0.020 5.631437e-108 ## IFIT2 2.672552e-108 5.5525558 0.786 0.037 3.755738e-104 ## B2M 5.283684e-98 0.6104044 1.000 1.000 7.425161e-94 ## PLSCR1 4.634658e-96 3.8010721 0.793 0.113 6.513085e-92 ## IRF7 2.411149e-94 3.1992949 0.835 0.187 3.388388e-90 ## CXCL10 3.708508e-86 8.0906108 0.651 0.010 5.211566e-82 ## UBE2L6 5.547472e-83 2.5167981 0.851 0.297 7.795863e-79 ## PSMB9 1.716262e-77 1.7715351 0.937 0.568 2.411863e-73 另一种可视化这些基因表达变化的有用方法是使用FeaturePlot或DotPlot函数的split.by选项。这将按分组变量（此处为刺激条件）展示给定基因列表的特征图。例如，CD3D 和 GNLY 是典型的细胞类型标记基因（分别对应 T 细胞和 NK/CD8 T 细胞），它们几乎不受干扰素刺激的影响，在对照组和刺激组中表现出相似的基因表达模式。而 IFI6 和 ISG15 则是核心干扰素应答基因，在所有细胞类型中均相应上调。最后，CD14 和 CXCL10 是展现细胞类型特异性干扰素应答的基因——CD14 在 CD14 单核细胞中受刺激后表达下降（这可能导致监督分析框架中的错误分类，从而凸显整合分析的价值）；CXCL10 则在干扰素刺激后于单核细胞和 B 细胞中显著上调，但在其他细胞类型中无此现象。 FeaturePlot(ifnb, features = c(&quot;CD3D&quot;, &quot;GNLY&quot;, &quot;IFI6&quot;), split.by = &quot;stim&quot;, max.cutoff = 3, cols = c(&quot;grey&quot;, &quot;red&quot;), reduction = &quot;umap&quot;) plots &lt;- VlnPlot(ifnb, features = c(&quot;LYZ&quot;, &quot;ISG15&quot;, &quot;CXCL10&quot;), split.by = &quot;stim&quot;, group.by = &quot;seurat_annotations&quot;, pt.size = 0, combine = FALSE) wrap_plots(plots = plots, ncol = 1) 4.6 使用 SCTransform 标准化数据集进行整合 作为对数归一化的替代方案，Seurat 还支持使用 sctransform 工作流对 scRNA-seq 数据进行预处理。 IntegrateLayers 函数同样支持 SCTransform 归一化后的数据，只需设置 normalization.method 参数即可，如下所示。 # 拆分数据集并在不集成的情况下处理 ifnb &lt;- LoadData(&quot;ifnb&quot;) ifnb[[&quot;RNA&quot;]] &lt;- split(ifnb[[&quot;RNA&quot;]], f = ifnb$stim) ifnb &lt;- SCTransform(ifnb) ifnb &lt;- RunPCA(ifnb) ifnb &lt;- RunUMAP(ifnb, dims = 1:30) DimPlot(ifnb, reduction = &quot;umap&quot;, group.by = c(&quot;stim&quot;, &quot;seurat_annotations&quot;)) # 整合数据集的情况下处理 ifnb &lt;- IntegrateLayers(object = ifnb, method = CCAIntegration, normalization.method = &quot;SCT&quot;, verbose = F) ifnb &lt;- FindNeighbors(ifnb, reduction = &quot;integrated.dr&quot;, dims = 1:30) ifnb &lt;- FindClusters(ifnb, resolution = 0.6) ## Modularity Optimizer version 1.3.0 by Ludo Waltman and Nees Jan van Eck ## ## Number of nodes: 13999 ## Number of edges: 544695 ## ## Running Louvain algorithm... ## Maximum modularity in 10 random starts: 0.9071 ## Number of communities: 19 ## Elapsed time: 1 seconds ifnb &lt;- RunUMAP(ifnb, dims = 1:30, reduction = &quot;integrated.dr&quot;) DimPlot(ifnb, reduction = &quot;umap&quot;, group.by = c(&quot;stim&quot;, &quot;seurat_annotations&quot;)) # 执行差异表达分析 ifnb &lt;- PrepSCTFindMarkers(ifnb) ifnb$celltype.stim &lt;- paste(ifnb$seurat_annotations, ifnb$stim, sep = &quot;_&quot;) Idents(ifnb) &lt;- &quot;celltype.stim&quot; b.interferon.response &lt;- FindMarkers(ifnb, ident.1 = &quot;B_STIM&quot;, ident.2 = &quot;B_CTRL&quot;, verbose = FALSE) "],["searat-整合.html", "第 5 章 Searat 整合 5.1 Seurat v5 对象中的层次结构 5.2 执行简化（单行）整合分析", " 第 5 章 Searat 整合 运用多种计算方法整合 scRNA-Seq 数据集。 library(Seurat) library(SeuratData) library(SeuratWrappers) library(Azimuth) library(ggplot2) library(patchwork) options(future.globals.maxSize = 1e9) 单细胞测序数据集的整合，例如跨实验批次、供体或条件的整合，通常是 scRNA-seq 工作流程中的重要步骤。整合分析有助于匹配跨数据集共享的细胞类型和状态，这可以提高统计效力，最重要的是，促进跨数据集的准确比较分析。在 Seurat 的早期版本中，我们引入了包括基于“锚点”的整合工作流在内的整合分析方法。许多实验室也发表了强大且开创性的整合分析方法，如 Harmony 和 scVI。我们认识到，虽然匹配跨数据集共享细胞类型的目标对许多问题可能很重要，但用户可能也会关心使用哪种方法，或者担心整合可能导致生物分辨率的损失。在 Seurat v5 中，我们引入了更灵活和简化的基础设施，只需一行代码即可运行不同的整合算法。这使得探索不同整合方法的结果变得更加容易，并将这些结果与排除整合步骤的工作流程进行比较。 在本教程中，我们使用了一个人类外周血单个核细胞（PBMC）数据集，该数据集通过七种不同技术进行基因表达分析，源自一项系统性比较研究（ pbmcsca ）。数据可通过我们的 SeuratData 包获取。 5.1 Seurat v5 对象中的层次结构 Seurat v5 的检测（assays）将数据存储在多个层次中。这些层次可存储原始未标准化的计数数据（ layer='counts' ）、标准化后的数据（layer='data' ）或经过 Z-score 转换/方差稳定的数据（ layer='scale.data' ）。我们可以加载数据、去除低质量细胞，并通过 Azimuth 流程获取预测的细胞注释（这对后续评估整合效果非常有用）。 # 载入 pbmc 系统性比较分析数据集 # SeuratData::InstallData(&quot;pbmcsca&quot;) obj &lt;- LoadData(&quot;pbmcsca&quot;) obj &lt;- subset(obj, nFeature_RNA &gt; 1000) obj &lt;- RunAzimuth(obj, reference = &quot;pbmcref&quot;) # 目前，该对象在 RNA 检测中有两层：counts 和 data obj ## An object of class Seurat ## 33789 features across 10434 samples within 4 assays ## Active assay: RNA (33694 features, 0 variable features) ## 2 layers present: counts, data ## 3 other assays present: prediction.score.celltype.l1, prediction.score.celltype.l2, prediction.score.celltype.l3 ## 2 dimensional reductions calculated: integrated_dr, ref.umap 查看可用的 Azimuth reference Azimuth # 您可以在 SeuratData 中搜索所有可用数据集（重点关注 Azimuth reference） available_data &lt;- AvailableData() available_data[grep(&quot;Azimuth&quot;, available_data[, 3]), 1:3] ## Dataset Version Summary ## adiposeref.SeuratData adiposeref 1.0.0 Azimuth Reference: adipose ## bonemarrowref.SeuratData bonemarrowref 1.0.0 Azimuth Reference: bonemarrow ## fetusref.SeuratData fetusref 1.0.0 Azimuth Reference: fetus ## heartref.SeuratData heartref 1.0.0 Azimuth Reference: heart ## humancortexref.SeuratData humancortexref 1.0.0 Azimuth Reference: humancortex ## kidneyref.SeuratData kidneyref 1.0.2 Azimuth Reference: kidney ## lungref.SeuratData lungref 2.0.0 Azimuth Reference: lung ## mousecortexref.SeuratData mousecortexref 1.0.0 Azimuth Reference: mousecortex ## pancreasref.SeuratData pancreasref 1.0.0 Azimuth Reference: pancreas ## pbmcref.SeuratData pbmcref 1.0.0 Azimuth Reference: pbmc ## tonsilref.SeuratData tonsilref 2.0.0 Azimuth Reference: tonsil 该对象包含来自九个不同批次的数据（存储在对象元数据的 Method 列中），代表了七种不同技术。我们的目标是将这些不同批次的数据整合在一起。在 Seurat 的早期版本中，我们需要将数据表示为九个不同的 Seurat 对象。而在使用 Seurat v5 分析时，我们可以将所有数据保留在一个对象中，只需拆分各层即可。拆分后，现在共有 18 层（每个批次对应一个 counts 和 data 层）。我们还可以运行标准的单细胞 RNA 测序分析（即不进行整合）。需要注意的是，由于数据被分层处理，归一化和可变特征的识别是独立为每个批次进行的（系统会自动识别出一组共识可变特征）。 obj[[&quot;RNA&quot;]] &lt;- split(obj[[&quot;RNA&quot;]], f = obj$Method) obj ## An object of class Seurat ## 33789 features across 10434 samples within 4 assays ## Active assay: RNA (33694 features, 0 variable features) ## 18 layers present: counts.Smart-seq2, counts.CEL-Seq2, counts.10x_Chromium_v2_A, counts.10x_Chromium_v2_B, counts.10x_Chromium_v3, counts.Drop-seq, counts.Seq-Well, counts.inDrops, counts.10x_Chromium_v2, data.Smart-seq2, data.CEL-Seq2, data.10x_Chromium_v2_A, data.10x_Chromium_v2_B, data.10x_Chromium_v3, data.Drop-seq, data.Seq-Well, data.inDrops, data.10x_Chromium_v2 ## 3 other assays present: prediction.score.celltype.l1, prediction.score.celltype.l2, prediction.score.celltype.l3 ## 2 dimensional reductions calculated: integrated_dr, ref.umap obj &lt;- NormalizeData(obj) obj &lt;- FindVariableFeatures(obj) obj &lt;- ScaleData(obj) obj &lt;- RunPCA(obj) 现在我们可以可视化未进行整合的标准分析结果。注意，细胞既按细胞类型分组，也按基础方法分组。虽然 UMAP 分析仅是对此的可视化呈现，但对该数据集进行聚类将主要得到批次特异性簇。尤其是如果没有先前的细胞类型注释，这将使下游分析变得极具挑战性。 obj &lt;- FindNeighbors(obj, dims = 1:30, reduction = &quot;pca&quot;) obj &lt;- FindClusters(obj, resolution = 2, cluster.name = &quot;unintegrated_clusters&quot;) ## Modularity Optimizer version 1.3.0 by Ludo Waltman and Nees Jan van Eck ## ## Number of nodes: 10434 ## Number of edges: 412660 ## ## Running Louvain algorithm... ## Maximum modularity in 10 random starts: 0.8981 ## Number of communities: 48 ## Elapsed time: 0 seconds obj &lt;- RunUMAP(obj, dims = 1:30, reduction = &quot;pca&quot;, reduction.name = &quot;umap.unintegrated&quot;) # 按批次和细胞类型注释进行可视化 细胞类型注释之前由 Azimuth 添加 DimPlot(obj, reduction = &quot;umap.unintegrated&quot;, group.by = c(&quot;Method&quot;, &quot;predicted.celltype.l2&quot;)) 5.2 执行简化（单行）整合分析 Seurat v5 通过使用 IntegrateLayers 函数实现了简化的整合分析流程。该方法目前支持五种整合方法。这些方法均在低维空间执行整合，并返回一个旨在跨批次共嵌共享细胞类型的降维结果（即 integrated.rpca ）。 基于锚点的 CCA 整合方法（ method=CCAIntegration ）. 基于锚点的 RPCA 整合方法（ method=RPCAIntegration ）. Harmony 算法（ method=HarmonyIntegration）. FastMNN ( method= FastMNNIntegration ) scVI ( method=scVIIntegration ) 请注意，我们基于锚点的 RPCA 整合方法是一种更快且更保守（校正较少）的整合方案。对此方法感兴趣的用户，可以在我们之前的 RPCA 教程中查看更多详细讨论。 您可以在 Seurat 文档中（例如 ?scVIIntegration ）找到每种方法的详细信息及安装前提条件。例如，scVI 整合需要 reticulate （可通过 CRAN 安装 install.packages(\"reticulate\") ）以及 scvi-tools 及其依赖项需在 conda 环境中安装。具体安装说明请参阅此处。 以下每一行代码都执行一次新的整合操作： obj &lt;- IntegrateLayers( object = obj, method = CCAIntegration, orig.reduction = &quot;pca&quot;, new.reduction = &quot;integrated.cca&quot;, verbose = FALSE ) obj &lt;- IntegrateLayers( object = obj, method = RPCAIntegration, orig.reduction = &quot;pca&quot;, new.reduction = &quot;integrated.rpca&quot;, verbose = FALSE ) obj &lt;- IntegrateLayers( object = obj, method = HarmonyIntegration, orig.reduction = &quot;pca&quot;, new.reduction = &quot;harmony&quot;, verbose = FALSE ) obj &lt;- IntegrateLayers( object = obj, method = FastMNNIntegration, new.reduction = &quot;integrated.mnn&quot;, verbose = FALSE ) obj &lt;- IntegrateLayers( object = obj, method = scVIIntegration, new.reduction = &quot;integrated.scvi&quot;, conda_env = &quot;../miniconda3/envs/scvi-env&quot;, verbose = FALSE ) 对于任何方法，我们现在都可以对数据集进行可视化和聚类。我们以 CCA 整合和 scVI 为例进行展示，但您可以将此应用于任何方法。 obj &lt;- FindNeighbors(obj, reduction = &quot;integrated.cca&quot;, dims = 1:30) obj &lt;- FindClusters(obj, resolution = 2, cluster.name = &quot;cca_clusters&quot;) ## Modularity Optimizer version 1.3.0 by Ludo Waltman and Nees Jan van Eck ## ## Number of nodes: 10434 ## Number of edges: 617481 ## ## Running Louvain algorithm... ## Maximum modularity in 10 random starts: 0.8039 ## Number of communities: 26 ## Elapsed time: 1 seconds obj &lt;- RunUMAP(obj, reduction = &quot;integrated.cca&quot;, dims = 1:30, reduction.name = &quot;umap.cca&quot;) p1 &lt;- DimPlot( obj, reduction = &quot;umap.cca&quot;, group.by = c(&quot;Method&quot;, &quot;predicted.celltype.l2&quot;, &quot;cca_clusters&quot;), combine = FALSE, label.size = 2 ) wrap_plots(c(p1), ncol = 1, byrow = F) obj &lt;- FindNeighbors(obj, reduction = &quot;integrated.scvi&quot;, dims = 1:30) obj &lt;- FindClusters(obj, resolution = 2, cluster.name = &quot;scvi_clusters&quot;) obj &lt;- RunUMAP(obj, reduction = &quot;integrated.scvi&quot;, dims = 1:30, reduction.name = &quot;umap.scvi&quot;) p2 &lt;- DimPlot( obj, reduction = &quot;umap.scvi&quot;, group.by = c(&quot;Method&quot;, &quot;predicted.celltype.l2&quot;, &quot;scvi_clusters&quot;), combine = FALSE, label.size = 2 ) wrap_plots(c(p1, p2), ncol = 2, byrow = F) 我们希望通过简化整合分析的过程，用户能更细致地评估整合数据集中保留的生物学信息。例如，用户可以基于不同聚类方案比较生物标记物的表达情况，或在不同的 UMAP 可视化结果上展示某一方法的聚类方案。 p1 &lt;- VlnPlot( obj, features = &quot;rna_CD8A&quot;, group.by = &quot;unintegrated_clusters&quot; ) + NoLegend() + ggtitle(&quot;CD8A - Unintegrated Clusters&quot;) p2 &lt;- VlnPlot( obj, &quot;rna_CD8A&quot;, group.by = &quot;cca_clusters&quot; ) + NoLegend() + ggtitle(&quot;CD8A - CCA Clusters&quot;) p3 &lt;- VlnPlot( obj, &quot;rna_CD8A&quot;, group.by = &quot;scvi_clusters&quot; ) + NoLegend() + ggtitle(&quot;CD8A - scVI Clusters&quot;) p1 | p2 | p3 obj &lt;- RunUMAP(obj, reduction = &quot;integrated.rpca&quot;, dims = 1:30, reduction.name = &quot;umap.rpca&quot;) p4 &lt;- DimPlot(obj, reduction = &quot;umap.unintegrated&quot;, group.by = c(&quot;cca_clusters&quot;)) p5 &lt;- DimPlot(obj, reduction = &quot;umap.rpca&quot;, group.by = c(&quot;cca_clusters&quot;)) p6 &lt;- DimPlot(obj, reduction = &quot;umap.scvi&quot;, group.by = c(&quot;cca_clusters&quot;)) p4 | p5 | p6 一旦整合分析完成，你可以重新合并图层——这将把各个数据集合并在一起并重建原始的 counts 和 data 图层。在进行任何差异表达分析之前，你需要完成这一步骤。不过，如果你想重新进行整合分析，随时可以再次拆分这些图层。 obj &lt;- JoinLayers(obj) obj ## An object of class Seurat ## 33789 features across 10434 samples within 4 assays ## Active assay: RNA (33694 features, 2000 variable features) ## 3 layers present: data, counts, scale.data ## 3 other assays present: prediction.score.celltype.l1, prediction.score.celltype.l2, prediction.score.celltype.l3 ## 6 dimensional reductions calculated: integrated_dr, ref.umap, pca, umap.unintegrated, integrated.cca, umap.cca 最后，用户还可以使用 sctransform 归一化数据进行整合（更多信息请参阅我们的 SCTransform vignette），首先运行 SCTransform 归一化，然后在 IntegrateLayers 中设置 normalization.method 参数。 options(future.globals.maxSize = 3e+09) obj &lt;- SCTransform(obj) obj &lt;- RunPCA(obj, npcs = 30, verbose = F) obj &lt;- IntegrateLayers( object = obj, method = RPCAIntegration, normalization.method = &quot;SCT&quot;, verbose = F ) obj &lt;- FindNeighbors(obj, dims = 1:30, reduction = &quot;integrated.dr&quot;) obj &lt;- FindClusters(obj, resolution = 2) obj &lt;- RunUMAP(obj, dims = 1:30, reduction = &quot;integrated.dr&quot;) "],["映射与注释查询数据集.html", "第 6 章 映射与注释查询数据集 6.1 数据集预处理 6.2 使用集成参考进行细胞类型分类 6.3 单模态 UMAP 投影", " 第 6 章 映射与注释查询数据集 学习如何将查询单细胞 RNA 测序数据集映射至参考数据集，以实现查询细胞的自动化注释与可视化。 我们首先构建一个集成参考集，随后演示如何利用该参考集对新查询数据集进行注释。生成集成参考集的流程与整合介绍教程中详述的工作流一致。一旦生成，此参考集可用于分析额外的查询数据集，执行诸如细胞类型标签转移、将查询细胞投影至参考 UMAP 等任务。值得注意的是，该方法无需校正原始查询数据，因此在拥有高质量参考集时是一种高效策略。 6.1 数据集预处理 在本示例中，我们选择了通过四种技术生成的人类胰岛细胞数据集：CelSeq（GSE81076）、CelSeq2（GSE85241）、Fluidigm C1（GSE86469）和 SMART-Seq2（E-MTAB-5061）。为方便起见，我们通过 SeuratData 包分发该数据集。元数据包含每项技术（ tech 列）和四种数据集中每个细胞的细胞类型注释（ celltype 列）。 library(Seurat) library(SeuratData) library(ggplot2) 作为演示，我们将使用部分技术子集构建参考数据集，随后将剩余数据集映射到该参考上。我们首先从四种技术中筛选细胞，并进行无整合的分析。 # InstallData(&quot;panc8&quot;) panc8 &lt;- LoadData(&quot;panc8&quot;) table(panc8$tech) ## ## celseq celseq2 fluidigmc1 indrop smartseq2 ## 1004 2285 638 8569 2394 # 我们将使用来自 2 种技术的数据作为参考 pancreas.ref &lt;- subset(panc8, tech %in% c(&quot;celseq2&quot;, &quot;smartseq2&quot;)) pancreas.ref[[&quot;RNA&quot;]] &lt;- split(pancreas.ref[[&quot;RNA&quot;]], f = pancreas.ref$tech) # 预处理数据集（无整合） pancreas.ref &lt;- NormalizeData(pancreas.ref) pancreas.ref &lt;- FindVariableFeatures(pancreas.ref) pancreas.ref &lt;- ScaleData(pancreas.ref) pancreas.ref &lt;- RunPCA(pancreas.ref) pancreas.ref &lt;- FindNeighbors(pancreas.ref, dims = 1:30) pancreas.ref &lt;- FindClusters(pancreas.ref) ## Modularity Optimizer version 1.3.0 by Ludo Waltman and Nees Jan van Eck ## ## Number of nodes: 4679 ## Number of edges: 174953 ## ## Running Louvain algorithm... ## Maximum modularity in 10 random starts: 0.9180 ## Number of communities: 19 ## Elapsed time: 0 seconds pancreas.ref &lt;- RunUMAP(pancreas.ref, dims = 1:30) DimPlot(pancreas.ref, group.by = c(&quot;celltype&quot;, &quot;tech&quot;)) 接下来，我们将这些数据集整合到一个共享参考中。具体方法请参阅我们的整合指南介绍。 pancreas.ref &lt;- IntegrateLayers(object = pancreas.ref, method = CCAIntegration, orig.reduction = &quot;pca&quot;, new.reduction = &quot;integrated.cca&quot;, verbose = FALSE) pancreas.ref &lt;- FindNeighbors(pancreas.ref, reduction = &quot;integrated.cca&quot;, dims = 1:30) pancreas.ref &lt;- FindClusters(pancreas.ref) ## Modularity Optimizer version 1.3.0 by Ludo Waltman and Nees Jan van Eck ## ## Number of nodes: 4679 ## Number of edges: 190152 ## ## Running Louvain algorithm... ## Maximum modularity in 10 random starts: 0.8680 ## Number of communities: 15 ## Elapsed time: 0 seconds pancreas.ref &lt;- RunUMAP(pancreas.ref, reduction = &quot;integrated.cca&quot;, dims = 1:30) DimPlot(pancreas.ref, group.by = c(&quot;tech&quot;, &quot;celltype&quot;)) 6.2 使用集成参考进行细胞类型分类 Seurat 同样支持将参考数据（或元数据）映射到查询对象上。尽管两种方法有共通之处（均始于锚点识别），但数据转移与整合存在两个重要区别： 在数据转移过程中，Seurat 不会对查询表达数据进行校正或修改。 在数据转移时，Seurat 默认提供将参考数据的 PCA 结构投影至查询选项，而非使用 CCA 学习联合结构。对于单细胞 RNA 测序数据集间的数据投影，我们通常建议启用此选项。 定位锚点后，我们使用 TransferData() 函数根据参考数据（参考细胞类型标签向量）对查询细胞进行分类。 TransferData() 返回包含预测 ID 和评分的矩阵，可将其添加至查询元数据中。 # 选择两种技术用于查询数据集 pancreas.query &lt;- subset(panc8, tech %in% c(&quot;fluidigmc1&quot;, &quot;celseq&quot;)) pancreas.query &lt;- NormalizeData(pancreas.query) pancreas.anchors &lt;- FindTransferAnchors(reference = pancreas.ref, query = pancreas.query, dims = 1:30, reference.reduction = &quot;pca&quot;) predictions &lt;- TransferData(anchorset = pancreas.anchors, refdata = pancreas.ref$celltype, dims = 1:30) pancreas.query &lt;- AddMetaData(pancreas.query, metadata = predictions) 由于我们拥有完整整合分析中的原始标签注释，因此可以评估预测的细胞类型注释与完整参考数据的匹配程度。在本例中，我们发现细胞类型分类具有高度一致性，超过 96%的细胞被正确标记。 pancreas.query$prediction.match &lt;- pancreas.query$predicted.id == pancreas.query$celltype table(pancreas.query$prediction.match) ## ## FALSE TRUE ## 63 1579 为了进一步验证这一点，我们可以检查一些特定胰岛细胞群的典型细胞类型标记物。需要注意的是，尽管某些细胞类型仅由一两个细胞代表（例如 epsilon 细胞），我们仍能正确分类它们。 table(pancreas.query$predicted.id) ## ## acinar activated_stellate alpha beta ## 262 39 436 419 ## delta ductal endothelial gamma ## 73 330 19 41 ## macrophage mast schwann ## 15 2 6 VlnPlot(pancreas.query, c(&quot;REG1A&quot;, &quot;PPY&quot;, &quot;SST&quot;, &quot;GHRL&quot;, &quot;VWF&quot;, &quot;SOX10&quot;), group.by = &quot;predicted.id&quot;) 6.3 单模态 UMAP 投影 我们还支持将查询数据投影到参考 UMAP 结构上。这可以通过计算参考 UMAP 模型后调用 MapQuery() 而非 TransferData() 来实现。 pancreas.ref &lt;- RunUMAP(pancreas.ref, dims = 1:30, reduction = &quot;integrated.cca&quot;, return.model = TRUE) pancreas.query &lt;- MapQuery(anchorset = pancreas.anchors, reference = pancreas.ref, query = pancreas.query,refdata = list(celltype = &quot;celltype&quot;), reference.reduction = &quot;pca&quot;, reduction.model = &quot;umap&quot;) MapQuery 的作用是什么？ MapQuery() 是三个函数的封装： TransferData() 、 IntegrateEmbeddings() 和 ProjectUMAP() 。 TransferData() 用于传递细胞类型标签并估算 ADT 值； IntegrateEmbeddings() 用于通过校正查询数据的低维嵌入来整合参考数据和查询数据；最后 ProjectUMAP() 用于将查询数据投影到参考数据的 UMAP 结构上。使用中间函数实现相同功能的等效代码如下： pancreas.query &lt;- TransferData(anchorset = pancreas.anchors, reference = pancreas.ref, query = pancreas.query, refdata = list(celltype = &quot;celltype&quot;)) pancreas.query &lt;- IntegrateEmbeddings(anchorset = pancreas.anchors, reference = pancreas.ref, query = pancreas.query, new.reduction.name = &quot;ref.pca&quot;) pancreas.query &lt;- ProjectUMAP(query = pancreas.query, query.reduction = &quot;ref.pca&quot;, reference = pancreas.ref, reference.reduction = &quot;pca&quot;, reduction.model = &quot;umap&quot;) 现在我们可以将查询细胞与参考数据一同可视化。 p1 &lt;- DimPlot(pancreas.ref, reduction = &quot;umap&quot;, group.by = &quot;celltype&quot;, label = TRUE, label.size = 3, repel = TRUE) + NoLegend() + ggtitle(&quot;Reference annotations&quot;) p2 &lt;- DimPlot(pancreas.query, reduction = &quot;ref.umap&quot;, group.by = &quot;predicted.celltype&quot;, label = TRUE, label.size = 3, repel = TRUE) + NoLegend() + ggtitle(&quot;Query transferred labels&quot;) p1 + p2 "],["差异表达分析.html", "第 7 章 差异表达分析 7.1 执行默认差异表达分析 7.2 在同一细胞类型内跨条件进行差异表达分析", " 第 7 章 差异表达分析 library(Seurat) library(SeuratData) library(ggplot2) ifnb &lt;- LoadData(&quot;ifnb&quot;) 7.1 执行默认差异表达分析 Seurat 的大部分差异表达功能可通过 FindMarkers() 函数访问。默认情况下，Seurat 基于非参数 Wilcoxon 秩和检验进行差异表达（DE）测试。若要测试两组特定细胞间的差异表达基因，需指定 ident.1 和 ident.2 参数。 # 规范化数据 ifnb &lt;- NormalizeData(ifnb) # 查找 CD16 单核细胞与 CD1 单核细胞之间的差异基因 Idents(ifnb) &lt;- &quot;seurat_annotations&quot; monocyte.de.markers &lt;- FindMarkers(ifnb, ident.1 = &quot;CD16 Mono&quot;, ident.2 = &quot;CD14 Mono&quot;) # 查看结果 head(monocyte.de.markers) ## p_val avg_log2FC pct.1 pct.2 p_val_adj ## VMO1 0 5.700274 0.778 0.084 0 ## MS4A4A 0 3.349751 0.748 0.143 0 ## FCGR3A 0 3.281942 0.982 0.418 0 ## PLAC8 0 3.268470 0.636 0.124 0 ## CXCL16 0 2.014758 0.938 0.475 0 ## MS4A7 0 2.386436 0.978 0.558 0 结果数据框包含以下列： - p_val：未校正的 p 值 - avg_log2FC：两组间平均表达量的对数倍变化。正值表示该特征在第一个组中表达更高。 - pct.1：在第一个组中检测到该特征的细胞百分比。 - pct.2：在第二个组中检测到该特征的细胞百分比。 - p_val_adj：校正后的 p 值，基于数据集中所有特征进行 Bonferroni 校正。 如果省略 ident.2 参数或将其设置为 NULL ， FindMarkers() 将测试由 ident.1 指定的组与所有其他细胞之间的差异表达特征。此外，参数 only.pos 可设置为 TRUE 以仅搜索正向标记，即在 ident.1 组中表达更高的特征。 # 在 CD14+单核细胞与所有其他细胞之间寻找差异表达特征，仅搜索阳性标记物 monocyte.de.markers &lt;- FindMarkers(ifnb, ident.1 = &quot;CD16 Mono&quot;, ident.2 = NULL, only.pos = TRUE) # 查看结果 head(monocyte.de.markers) ## p_val avg_log2FC pct.1 pct.2 p_val_adj ## FCGR3A 0 4.532656 0.982 0.168 0 ## MS4A7 0 3.806350 0.978 0.216 0 ## CXCL16 0 3.274267 0.938 0.196 0 ## VMO1 0 6.254651 0.778 0.044 0 ## MS4A4A 0 4.747731 0.748 0.055 0 ## LST1 0 2.927351 0.912 0.228 0 7.2 在同一细胞类型内跨条件进行差异表达分析 由于该数据集包含处理信息（对照与干扰素-β刺激），我们还可以探究同一类型细胞在不同条件下哪些基因发生变化。首先，我们在 meta.data 槽中创建一个列来存储细胞类型和处理信息，并将当前 Idents 切换为该列。然后使用 FindMarkers() 找出对照与受刺激 CD14 单核细胞之间差异的基因。 ifnb$celltype.stim &lt;- paste(ifnb$seurat_annotations, ifnb$stim, sep = &quot;_&quot;) Idents(ifnb) &lt;- &quot;celltype.stim&quot; mono.de &lt;- FindMarkers(ifnb, ident.1 = &quot;CD14 Mono_STIM&quot;, ident.2 = &quot;CD14 Mono_CTRL&quot;, verbose = FALSE) head(mono.de, n = 10) ## p_val avg_log2FC pct.1 pct.2 p_val_adj ## IFIT1 0 7.319139 0.985 0.033 0 ## CXCL10 0 8.036564 0.984 0.035 0 ## RSAD2 0 6.741673 0.988 0.045 0 ## TNFSF10 0 6.991279 0.989 0.047 0 ## IFIT3 0 6.883785 0.992 0.056 0 ## IFIT2 0 7.179929 0.961 0.039 0 ## CXCL11 0 8.624208 0.932 0.012 0 ## CCL8 0 9.134191 0.918 0.017 0 ## IDO1 0 5.455898 0.965 0.089 0 ## MX1 0 5.059052 0.960 0.093 0 然而，从该分析中获得的 p 值需谨慎解读，因为这些检验将每个细胞视为独立重复样本，忽略了源自同一样本的细胞间固有相关性。此类分析已被证明会产生大量假阳性关联，如 Squair 等人 2021 年、Zimmerman 等人 2021 年、Junttila 等人 2022 年及其他研究所证实。下文我们将展示如何利用伪批量分析（pseudobulking）来校正此类样本内相关性。 7.2.1 执行伪批量分析后的差异表达分析 进行伪批量分析时，我们将使用 AggregateExpression() 函数对同一样本中所有细胞的基因计数按细胞类型求和。这将为每个样本和细胞类型生成一个基因表达谱。随后可在样本层面使用 DESeq2 进行差异表达分析，此时将样本（而非单个细胞）视为独立观测单位。 首先需要获取每个细胞的样本信息。由于该信息未加载至元数据中，我们将从原始论文源数据的 GitHub 仓库中加载。 向数据集中添加样本信息 # 加载每个细胞的推断样本 ID ctrl &lt;- read.table(url(&quot;https://raw.githubusercontent.com/yelabucsf/demuxlet_paper_code/master/fig3/ye1.ctrl.8.10.sm.best&quot;), head = T, stringsAsFactors = F) stim &lt;- read.table(url(&quot;https://raw.githubusercontent.com/yelabucsf/demuxlet_paper_code/master/fig3/ye2.stim.8.10.sm.best&quot;), head = T, stringsAsFactors = F) info &lt;- rbind(ctrl, stim) # 通过将&#39;-&#39;替换为&#39;.&#39;来重命名单元格 ID info$BARCODE &lt;- gsub(pattern = &quot;\\\\-&quot;, replacement = &quot;\\\\.&quot;, info$BARCODE) # 仅保留具有高置信度样本 ID 的细胞 info &lt;- info[grep(pattern = &quot;SNG&quot;, x = info$BEST), ] # 在 ctrl 和 stim 组中移除具有重复 ID 的细胞 info &lt;- info[!duplicated(info$BARCODE) &amp; !duplicated(info$BARCODE, fromLast = T), ] # 现在将样本 ID 添加到 ifnb rownames(info) &lt;- info$BARCODE info &lt;- info[, c(&quot;BEST&quot;), drop = F] names(info) &lt;- c(&quot;donor_id&quot;) ifnb &lt;- AddMetaData(ifnb, metadata = info) # 移除没有供体 ID 的细胞 ifnb$donor_id[is.na(ifnb$donor_id)] &lt;- &quot;unknown&quot; ifnb &lt;- subset(ifnb, subset = donor_id != &quot;unknown&quot;) 我们现在可以根据供体 ID 进行伪批量分析（ AggregateExpression() ）。 # 基于供体-条件-细胞类型 (donor-condition-celltype) 对计数进行伪批量处理 pseudo_ifnb &lt;- AggregateExpression(ifnb, assays = &quot;RNA&quot;, return.seurat = T, group.by = c(&quot;stim&quot;, &quot;donor_id&quot;, &quot;seurat_annotations&quot;)) # 每个“细胞”都是一个供体-条件-细胞类型的伪批量表达谱 tail(Cells(pseudo_ifnb)) ## [1] &quot;STIM_SNG-1488_NK&quot; &quot;STIM_SNG-1488_DC&quot; ## [3] &quot;STIM_SNG-1488_B Activated&quot; &quot;STIM_SNG-1488_Mk&quot; ## [5] &quot;STIM_SNG-1488_pDC&quot; &quot;STIM_SNG-1488_Eryth&quot; pseudo_ifnb$celltype.stim &lt;- paste(pseudo_ifnb$seurat_annotations, pseudo_ifnb$stim, sep = &quot;_&quot;) 接下来，我们在伪批量水平上对 CD14 单核细胞进行差异表达（DE）测试，并将其与之前的单细胞水平 DE 结果进行比较。 Idents(pseudo_ifnb) &lt;- &quot;celltype.stim&quot; bulk.mono.de &lt;- FindMarkers(object = pseudo_ifnb, ident.1 = &quot;CD14 Mono_STIM&quot;, ident.2 = &quot;CD14 Mono_CTRL&quot;, test.use = &quot;DESeq2&quot;) head(bulk.mono.de, n = 15) ## p_val avg_log2FC pct.1 pct.2 p_val_adj ## IL1RN 3.701542e-275 5.588693 1 1 5.201777e-271 ## IFITM2 1.955626e-250 4.108615 1 1 2.748242e-246 ## SSB 2.699554e-203 2.893183 1 1 3.793683e-199 ## NT5C3A 2.239898e-198 4.426872 1 1 3.147729e-194 ## RTCB 5.700554e-162 2.738430 1 1 8.010989e-158 ## RABGAP1L 4.743010e-161 4.494047 1 1 6.665352e-157 ## DYNLT1 9.735640e-159 2.265511 1 1 1.368150e-154 ## PLSCR1 3.191691e-146 2.501836 1 1 4.485284e-142 ## ISG20 9.664488e-145 5.214558 1 1 1.358151e-140 ## NAPA 2.858013e-144 1.782667 1 1 4.016365e-140 ## DDX58 5.957026e-142 3.908225 1 1 8.371409e-138 ## HERC5 6.333722e-133 4.360282 1 1 8.900780e-129 ## OASL 3.892853e-130 3.691383 1 1 5.470627e-126 ## EIF2AK2 6.636434e-128 3.386754 1 1 9.326180e-124 ## TMEM50A 6.731955e-117 1.264359 1 1 9.460416e-113 比较单细胞水平与伪bulk水平结果 # 比较单细胞水平与伪批量水平结果之间的 DE P 值 names(bulk.mono.de) &lt;- paste0(names(bulk.mono.de), &quot;.bulk&quot;) bulk.mono.de$gene &lt;- rownames(bulk.mono.de) names(mono.de) &lt;- paste0(names(mono.de), &quot;.sc&quot;) mono.de$gene &lt;- rownames(mono.de) merge_dat &lt;- merge(mono.de, bulk.mono.de, by = &quot;gene&quot;) merge_dat &lt;- merge_dat[order(merge_dat$p_val.bulk), ] # 在两者中均具有边际显著性的基因数量；仅在批量数据中具有边际显著性；以及仅在单细胞数据中具有边际显著性 common &lt;- merge_dat$gene[which(merge_dat$p_val.bulk &lt; 0.05 &amp; merge_dat$p_val.sc &lt; 0.05)] only_sc &lt;- merge_dat$gene[which(merge_dat$p_val.bulk &gt; 0.05 &amp; merge_dat$p_val.sc &lt; 0.05)] only_bulk &lt;- merge_dat$gene[which(merge_dat$p_val.bulk &lt; 0.05 &amp; merge_dat$p_val.sc &gt; 0.05)] print(paste0(&#39;# Common: &#39;,length(common))) ## [1] &quot;# Common: 3519&quot; print(paste0(&#39;# Only in single-cell: &#39;,length(only_sc))) ## [1] &quot;# Only in single-cell: 1649&quot; print(paste0(&#39;# Only in bulk: &#39;,length(only_bulk))) ## [1] &quot;# Only in bulk: 204&quot; 我们可以看到，虽然单细胞数据和伪批量数据的 p 值存在相关性，但单细胞数据的 p 值通常更小，表明显著性水平更高。具体而言，有 3,519 个基因在两项分析中均显示差异表达证据（未进行多重假设检验前），1,649 个基因仅在单细胞分析中呈现差异表达，而仅有 204 个基因仅在批量分析中显示差异表达。我们可以使用 VlnPlot 来探究这些差异。 首先，我们可以检查在两项分析中差异表达最显著的基因。 # 在单细胞数据集中创建一个新列来标注样本-条件-细胞类型 ifnb$donor_id.stim &lt;- paste0(ifnb$stim, &quot;-&quot;, ifnb$donor_id) # 画图 Idents(ifnb) &lt;- &quot;celltype.stim&quot; print(merge_dat[merge_dat$gene%in%common[1:2],c(&#39;gene&#39;,&#39;p_val.sc&#39;,&#39;p_val.bulk&#39;)]) ## gene p_val.sc p_val.bulk ## 2785 IL1RN 0 3.701542e-275 ## 2739 IFITM2 0 1.955626e-250 VlnPlot(ifnb, features = common[1:2], idents = c(&quot;CD14 Mono_CTRL&quot;, &quot;CD14 Mono_STIM&quot;), group.by = &quot;stim&quot;) VlnPlot(ifnb, features = common[1:2], idents = c(&quot;CD14 Mono_CTRL&quot;, &quot;CD14 Mono_STIM&quot;), group.by = &quot;donor_id.stim&quot;, ncol = 1) 在这里，SRGN 和 HLA-DRA 在单细胞分析中都具有非常小的 p 值（数量级分别为 10−21 和 10−9），但在伪批量分析中 p 值约为 0.18，显著增大。虽然忽略样本信息时，对照组和模拟细胞之间似乎存在差异，但在样本水平上信号明显减弱，并且我们可以看到样本间存在显著变异性。 7.2.2 使用其他检验进行差异表达分析 最后，我们还支持使用其他方法进行多种差异表达检验。为全面起见，当前支持以下检验方法： “wilcox”：Wilcoxon 秩和检验（默认，使用‘presto’包） “wilcox_limma”：Wilcoxon 秩和检验（使用‘limma’包） “bimod：单细胞特征表达似然比检验（McDavid 等人，《生物信息学》，2013 年） “roc”：标准 AUC 分类器 “t” : Student’s t-test “poisson”: 基于负二项分布假设的似然比检验。仅适用于 UMI 数据集 “negbinom”：基于负二项分布假设的似然比检验。仅适用于 UMI 数据集 “LR”：采用逻辑回归框架鉴定差异表达基因。针对每个特征单独构建逻辑回归模型预测分组归属，并通过似然比检验与零模型进行比较 “MAST”：一种将细胞检测率作为协变量处理的广义线性模型框架（Finak 等人，《Genome Biology》，2015 年）（安装说明） “DESeq2”：基于负二项分布模型的差异表达分析（Love 等人，《基因组生物学》，2014 年）（安装说明）对于 MAST 和 DESeq2，请确保单独安装这些软件包，以便将它们作为 Seurat 的一部分使用。安装完成后，可通过 test.use 参数指定要使用的差异表达测试方法。 # Test for DE features using the MAST package Idents(ifnb) &lt;- &quot;seurat_annotations&quot; head(FindMarkers(ifnb, ident.1 = &quot;CD14 Mono&quot;, ident.2 = &quot;CD16 Mono&quot;, test.use = &quot;MAST&quot;)) "],["seurat-命令列表.html", "第 8 章 Seurat 命令列表 8.1 标准 Seurat 工作流程 8.2 SCtransform 版本 8.3 Seurat 对象数据访问 8.4 子集划分与合并 8.5 伪 bulk 分析 8.6 在 Seurat 中进行可视化 8.7 多检测特征", " 第 8 章 Seurat 命令列表 8.1 标准 Seurat 工作流程 pbmc &lt;- NormalizeData(object = pbmc) pbmc &lt;- FindVariableFeatures(object = pbmc) pbmc &lt;- ScaleData(object = pbmc) pbmc &lt;- RunPCA(object = pbmc) pbmc &lt;- FindNeighbors(object = pbmc, dims = 1:30) pbmc &lt;- FindClusters(object = pbmc) pbmc &lt;- RunUMAP(object = pbmc, dims = 1:30) DimPlot(object = pbmc, reduction = &quot;umap&quot;) 8.2 SCtransform 版本 pbmc &lt;- SCTransform(object = pbmc) pbmc &lt;- RunPCA(object = pbmc) pbmc &lt;- FindNeighbors(object = pbmc, dims = 1:30) pbmc &lt;- FindClusters(object = pbmc) pbmc &lt;- RunUMAP(object = pbmc, dims = 1:30) DimPlot(object = pbmc, reduction = &quot;umap&quot;) # 请注意，您可以使用 %&gt;% 将多个命令串联在一起 pbmc &lt;- SCTransform(pbmc) %&gt;% RunPCA() %&gt;% FindNeighbors(dims = 1:30) %&gt;% FindClusters() %&gt;% RunUMAP(dims = 1:30) 8.3 Seurat 对象数据访问 8.3.1 细胞、基因及层级名称 # 获取细胞和特征名称及总数 我们展示了多种获取相同输出细胞名称的方法 colnames(pbmc) Cells(pbmc) # 基因名 Features(pbmc) rownames(pbmc) # 细胞/基因数量 num_cells &lt;- ncol(pbmc) num_features &lt;- nrow(pbmc) # 对象层级列表 Layers(pbmc) # 使用多模态对象列表检测 Assays(cbmc) # 检测特异性基因（基因/ADT） Features(cbmc[[&quot;RNA&quot;]]) Features(cbmc[[&quot;ADT&quot;]]) # 可变基因名称 VariableFeatures(pbmc) 8.3.2 身份类别标签 # 设置和检索细胞标识 # Set identity classes to an existing column in meta data Idents(object = pbmc) &lt;- &quot;seurat_annotations&quot; # 将元数据中的现有列设置为身份类别 Idents(pbmc) table(Idents(pbmc)) # 将所有细胞的 identity 设置为 CD4 T 细胞 Idents(pbmc) &lt;- &quot;CD4 T cells&quot; # 为选定的一组细胞设置 pbmc.cells &lt;- Cells(pbmc) Idents(object = pbmc, cells = pbmc.cells[1:10]) &lt;- &quot;CD4 T cells&quot; # 获取细胞身份类别 Idents(object = pbmc) levels(x = pbmc) #将细胞身份类别存储在元数据中 pbmc[[&quot;old.ident&quot;]] &lt;- Idents(object = pbmc) pbmc &lt;- StashIdent(object = pbmc, save.name = &quot;old.ident&quot;) # 重命名身份类别 pbmc &lt;- RenameIdents(object = pbmc, `CD4 T cells` = &quot;T Helper cells&quot;) 8.3.3 细胞元数据 # 查看元数据数据框，存储在 object@meta.data 中 pbmc[[]] # 从元数据中检索特定值 pbmc$nCount_RNA pbmc[[c(&quot;percent.mito&quot;, &quot;nFeature_RNA&quot;)]] # 添加元数据，参见 ?AddMetaData random_group_labels &lt;- sample(x = c(&quot;g1&quot;, &quot;g2&quot;), size = ncol(x = pbmc), replace = TRUE) pbmc$groups &lt;- random_group_labels 8.3.4 表达数据（在 Seurat v5 中以图层形式存储） # 以表达矩阵 RNA 计数矩阵的形式检索数据 pbmc[[&quot;RNA&quot;]]$counts # 具有相同结果的替代访问器函数 LayerData(pbmc, assay = &quot;RNA&quot;, layer = &quot;counts&quot;) # Seurat v4 中的 GetAssayData 功能仍受支持 GetAssayData(object = pbmc, assay = &quot;RNA&quot;, slot = &quot;counts&quot;) # ADT 计数矩阵（多模态对象） cbmc[[&quot;ADT&quot;]]$counts # 设置表达式数据假设 new.data 是一个新的表达式矩阵 pbmc[[&quot;RNA&quot;]]$counts &lt;- new.data # 具有相同结果的替代设置函数 LayerData(pbmc, assay = &quot;RNA&quot;, layer = &quot;counts&quot;) &lt;- new.data # Seurat v4 中的 SetAssayData 功能仍受支持 pbmc &lt;- SetAssayData(object = pbmc, slot = &quot;counts&quot;, new.data = new.data) 8.3.5 降维 # 获取存储在 pbmc[[&#39;pca&#39;]]@cell.embeddings 中的细胞嵌入和特征载荷 Embeddings(pbmc, reduction = &quot;pca&quot;) # 存储在 pbmc[[&#39;pca&#39;]]@feature.loadings 中 Loadings(pbmc, reduction = &quot;pca&quot;) # 可选择创建自定义降维负载矩阵 new_reduction &lt;- CreateDimReducObject(embeddings = new.embeddings, loadings = new.loadings, key = &quot;custom_pca&quot;) pbmc[[&quot;custom_pca&quot;]] &lt;- new_reduction 8.3.6 数据获取 # FetchData 可以访问表达式矩阵、细胞嵌入或元数据中的任何内容。使用之前列出的命令访问整个矩阵，使用 FetchData 访问单个/小组变量 FetchData(object = pbmc, vars = c(&quot;PC_1&quot;, &quot;nFeature_RNA&quot;, &quot;MS4A1&quot;), layer = &quot;counts&quot;) 8.4 子集划分与合并 8.4.1 子集 Seurat 对象 # 根据身份类别子集化 Seurat 对象，另请参阅?SubsetData subset(x = pbmc, idents = &quot;B&quot;) subset(x = pbmc, idents = c(&quot;Naive CD4 T&quot;, &quot;CD8 T&quot;), invert = TRUE) # 根据基因/特征的表达水平进行子集筛选 subset(x = pbmc, subset = MS4A1 &gt; 2.5) # 基于多重条件的子集筛选 subset(x = pbmc, subset = MS4A1 &gt; 2.5 &amp; PC_1 &gt; 5) subset(x = pbmc, subset = MS4A1 &gt; 2.5, idents = &quot;B&quot;) # 根据对象元数据中的值进行子集筛选 subset(x = pbmc, subset = groups == &quot;g1&quot;) # 按身份类别对细胞数量进行下采样 subset(x = pbmc, downsample = 100) 8.4.2 分割图层 # 在 Seurat v5 中，用户现在可以直接将对象分割到不同层中，将表达数据保留在一个对象内，但将多个样本分割到各层中，分割层后可直接进入整合工作流程 ifnb[[&quot;RNA&quot;]] &lt;- split(ifnb[[&quot;RNA&quot;]], f = ifnb$stim) Layers(ifnb) # 如果需要，例如在整合后，这些层可以再次合并在一起 ifnb &lt;- JoinLayers(ifnb) 8.4.3 合并对象（不带整合) # 在 Seurat v5 中，合并会创建一个单一对象，但将表达信息保留在不同的层中以供整合。如果不进行整合，合并后需重新合并各层。 # 合并两个 Seurat 对象 merged_obj &lt;- merge(x = ifnb_list$CTRL, y = ifnb_list$STIM) merged_obj[[&quot;RNA&quot;]] &lt;- JoinLayers(merged_obj) # 合并两个以上 Seurat 对象的示例 merge(x = pbmc1, y = list(pbmc2, pbmc3)) 8.4.4 合并对象（带整合）’ 更多信息请参阅整合介绍。 merged_obj &lt;- merge(x = ifnb_list$CTRL, y = ifnb_list$STIM) merged_obj &lt;- NormalizeData(merged_obj) merged_obj &lt;- FindVariableFeatures(merged_obj) merged_obj &lt;- ScaleData(merged_obj) merged_obj &lt;- RunPCA(merged_obj) merged_obj &lt;- IntegrateLayers(object = obj, method = RPCAIntegration, orig.reduction = &quot;pca&quot;, new.reduction = &quot;integrated.rpca&quot;, verbose = FALSE) # 现在集成已完成，重新合并图层 merged_obj[[&quot;RNA&quot;]] &lt;- JoinLayers(merged_obj) 8.5 伪 bulk 分析 8.5.1 基于多个类别将细胞分组 # 仅按细胞类型的伪 bulk bulk &lt;- AggregateExpression(ifnb, group.by = &quot;seurat_annotations&quot;, return.seurat = TRUE) Cells(bulk) # 按刺激条件和细胞类型分类的伪 bulk bulk &lt;- AggregateExpression(ifnb, group.by = c(&quot;stim&quot;, &quot;seurat_annotations&quot;), return.seurat = TRUE) Cells(bulk) # 按刺激条件、细胞类型和供体进行伪 bulk 分析 bulk &lt;- AggregateExpression(ifnb, group.by = c(&quot;stim&quot;, &quot;seurat_annotations&quot;, &quot;donor_id&quot;), return.seurat = TRUE) Cells(bulk) 8.6 在 Seurat 中进行可视化 Seurat 拥有一个基于 ggplot2 的庞大绘图库。默认情况下，所有绘图函数都会返回一个 ggplot2 图形，便于利用 ggplot2 进行轻松自定义。 # 降维图 DimPlot(object = pbmc, reduction = &quot;pca&quot;) # 降维图，细胞按定量特征着色，默认使用 UMAP（如果可用） FeaturePlot(object = pbmc, features = &quot;MS4A1&quot;) # 单细胞散点图 FeatureScatter(object = pbmc, feature1 = &quot;MS4A1&quot;, feature2 = &quot;PC_1&quot;) FeatureScatter(object = pbmc, feature1 = &quot;MS4A1&quot;, feature2 = &quot;CD3D&quot;) # 跨个体特征的散点图，替代 CellPlot CellScatter(object = pbmc, cell1 = &quot;AGTCTACTAGGGTG&quot;, cell2 = &quot;CACAGATGGTTTCT&quot;) VariableFeaturePlot(object = pbmc) # 小提琴图和山脊图 VlnPlot(object = pbmc, features = c(&quot;LYZ&quot;, &quot;CCL5&quot;, &quot;IL32&quot;)) RidgePlot(object = pbmc, feature = c(&quot;LYZ&quot;, &quot;CCL5&quot;, &quot;IL32&quot;)) # 热图（可视化 scale.data 数据槽） DimHeatmap(object = pbmc, reduction = &quot;pca&quot;, cells = 200) # 标准工作流程 pbmc &lt;- ScaleData(pbmc, features = heatmap_markers) DoHeatmap(object = pbmc, features = heatmap_markers) # sctransform 工作流程 pbmc &lt;- GetResidual(pbmc, features = heatmap_markers) DoHeatmap(object = pbmc, features = heatmap_markers) # 每组最多 100 个单元格的热图 DoHeatmap(pbmc, heatmap_markers, cells = subset(pbmc, downsample = 100)) # 新功能尝鲜！请注意，绘图函数现在会返回 ggplot2 对象，因此你可以为它们添加主题、标题和选项 VlnPlot(object = pbmc, features = &quot;MS4A1&quot;, split.by = &quot;groups&quot;) DotPlot(object = pbmc, features = c(&quot;LYZ&quot;, &quot;CCL5&quot;, &quot;IL32&quot;), split.by = &quot;groups&quot;) FeaturePlot(object = pbmc, features = c(&quot;MS4A1&quot;, &quot;CD79A&quot;), blend = TRUE) DimPlot(object = pbmc) + DarkTheme() DimPlot(object = pbmc) + labs(title = &quot;2,700 PBMCs clustered using Seurat and viewed\\non a two-dimensional UMAP&quot;) 主题 功能 DarkTheme 设置黑色背景与白色文字 FontSize 为图表中的不同元素设置字体大小 NoAxes 移除坐标轴及轴文本 NoLegend 移除所有图例元素 RestoreLegend 移除后恢复图例 RotatedAxis 旋转 X 轴标签 # 绘图辅助函数适用于基于 ggplot2 的散点图，如 DimPlot、FeaturePlot、CellScatter 和 FeatureScatter plot &lt;- DimPlot(object = pbmc) + NoLegend() # HoverLocator 取代了之前的 `do.hover` 参数，它还可以通过 `information` 参数显示额外数据，设计初衷是与 FetchData 无缝协作 HoverLocator(plot = plot, information = FetchData(object = pbmc, vars = c(&quot;ident&quot;, &quot;PC_1&quot;, &quot;nFeature_RNA&quot;))) # FeatureLocator 取代了之前的`do.identify` select.cells &lt;- FeatureLocator(plot = plot) # 在 ggplot 对象上标记点 LabelPoints(plot = plot, points = TopCells(object = pbmc[[&quot;pca&quot;]]), repel = TRUE) 8.7 多检测特征 使用 Seurat，您可以在单细胞级别轻松切换不同的检测数据（如 CITE-seq 的 ADT 计数或整合/批次校正后的数据）。大多数函数现在接受 assay 参数，但您可设置默认检测以避免重复声明。 cbmc &lt;- CreateSeuratObject(counts = cbmc.rna) # 添加 ADT 数据 cbmc[[&quot;ADT&quot;]] &lt;- CreateAssayObject(counts = cbmc.adt) # 通过指定要使用的检测方法运行分析 NormalizeData(object = cbmc, assay = &quot;RNA&quot;) NormalizeData(object = cbmc, assay = &quot;ADT&quot;, method = &quot;CLR&quot;) # 检索并设置默认检测 DefaultAssay(object = cbmc) DefaultAssay(object = cbmc) &lt;- &quot;ADT&quot; DefaultAssay(object = cbmc) # 通过使用键从两个检测中提取特征表达 FetchData(object = cbmc, vars = c(&quot;rna_CD3E&quot;, &quot;adt_CD3&quot;)) # 使用键绘制来自多个检测的数据 FeatureScatter(object = cbmc, feature1 = &quot;rna_CD3E&quot;, feature2 = &quot;adt_CD3&quot;) "],["单样本分析.html", "第 9 章 单样本分析 9.1 创建Seurat对象 9.2 降维聚类分群 9.3 maker 基因 9.4 maker 基因可视化 9.5 注释亚群", " 第 9 章 单样本分析 9.1 创建Seurat对象 #https://www.ncbi.nlm.nih.gov/pmc/articles/PMC10039079/ #untar(&quot;GSE218208_RAW.tar&quot;) rm(list = ls()) a = data.table::fread(&quot;GSM6736629_10x-PBMC-1_ds0.1974_CountMatrix.tsv.gz&quot;,data.table = F) a[1:4,1:4] ## alias:gene AAACCCAAGTAGGGTC AAACCCACACCATTCC AAACCCATCTACACTT ## 1 TSPAN6:ENSG00000000003 0 0 0 ## 2 DPM1:ENSG00000000419 0 1 0 ## 3 SCYL3:ENSG00000000457 0 0 0 ## 4 C1orf112:ENSG00000000460 0 0 0 library(tidyverse) a$`alias:gene` = str_split(a$`alias:gene`,&quot;:&quot;,simplify = T)[,1] #str_split_i(a$`alias:gene`,&quot;:&quot;,i = 1) a = distinct(a,`alias:gene`,.keep_all = T) a = column_to_rownames(a,var = &quot;alias:gene&quot;) a[1:4,1:4] ## AAACCCAAGTAGGGTC AAACCCACACCATTCC AAACCCATCTACACTT AAACGAAAGCACGTCC ## TSPAN6 0 0 0 0 ## DPM1 0 1 0 0 ## SCYL3 0 0 0 0 ## C1orf112 0 0 0 0 library(Seurat) pbmc &lt;- CreateSeuratObject(counts = a, project = &quot;a&quot;, min.cells = 3, min.features = 200) 9.1.0.1 2.质控 pbmc[[&quot;percent.mt&quot;]] &lt;- PercentageFeatureSet(pbmc, pattern = &quot;^MT-&quot;) head(pbmc@meta.data, 3) ## orig.ident nCount_RNA nFeature_RNA percent.mt ## AAACCCAAGTAGGGTC a 10768 3213 7.030089 ## AAACCCACACCATTCC a 4102 1676 5.046319 ## AAACCCATCTACACTT a 4694 1740 6.305922 VlnPlot(pbmc, features = c(&quot;nFeature_RNA&quot;, &quot;nCount_RNA&quot;, &quot;percent.mt&quot;), ncol = 3, pt.size = 0.5) pbmc = subset(pbmc,nFeature_RNA &lt; 4200 &amp; nCount_RNA &lt; 18000 &amp; percent.mt &lt; 18) 9.2 降维聚类分群 f = &quot;obj.Rdata&quot; if(!file.exists(f)){ pbmc = pbmc %&gt;% NormalizeData() %&gt;% FindVariableFeatures() %&gt;% ScaleData(features = rownames(.)) %&gt;% RunPCA(features = VariableFeatures(.)) %&gt;% FindNeighbors(dims = 1:15) %&gt;% FindClusters(resolution = 0.5) %&gt;% RunUMAP(dims = 1:15) %&gt;% RunTSNE(dims = 1:15) save(pbmc,file = f) } load(f) ElbowPlot(pbmc) p1 &lt;- DimPlot(pbmc, reduction = &quot;umap&quot;,label = T)+NoLegend();p1 9.3 maker 基因 library(dplyr) f = &quot;markers.Rdata&quot; if(!file.exists(f)){ pbmc.markers &lt;- FindAllMarkers(pbmc, only.pos = TRUE,min.pct = 0.25) save(pbmc.markers,file = f) } load(f) mks = pbmc.markers %&gt;% group_by(cluster) %&gt;% top_n(n = 2, wt = avg_log2FC) g = unique(mks$gene) 9.4 maker 基因可视化 DoHeatmap(pbmc, features = g) + NoLegend()+ scale_fill_gradientn(colors = c(&quot;#2fa1dd&quot;, &quot;white&quot;, &quot;#f87669&quot;)) DotPlot(pbmc, features = g,cols = &quot;RdYlBu&quot;) + RotatedAxis() VlnPlot(pbmc, features = g[1:3]) FeaturePlot(pbmc, features = g[1:4]) 9.5 注释亚群 手动注释 a = read.delim(&quot;../supp/markers.txt&quot;,header = F) gt = split(a[,2],a[,1]) DotPlot(pbmc, features = gt,cols = &quot;RdYlBu&quot;) + RotatedAxis() writeLines(paste0(0:11,&quot;,&quot;)) ## 0, ## 1, ## 2, ## 3, ## 4, ## 5, ## 6, ## 7, ## 8, ## 9, ## 10, ## 11, celltype = read.table(&quot;anno.txt&quot;,sep = &quot;,&quot;) #自己照着DotPlot图填的 celltype ## V1 V2 ## 1 0 Naive CD4 T ## 2 1 CD14+ Mono ## 3 2 B ## 4 3 CD8 T ## 5 4 NK ## 6 5 Naive CD4 T ## 7 6 Naive CD4 T ## 8 7 FCGR3A+ Mono ## 9 8 CD14+ Mono ## 10 9 Platelet ## 11 10 DC ## 12 11 DC new.cluster.ids &lt;- celltype$V2 names(new.cluster.ids) &lt;- levels(pbmc) seu.obj &lt;- RenameIdents(pbmc, new.cluster.ids) save(seu.obj,file = &quot;seu.obj.Rdata&quot;) p2 &lt;- DimPlot(seu.obj, reduction = &quot;umap&quot;, label = TRUE, pt.size = 0.5) + NoLegend() p2 自动注释 library(celldex) library(SingleR) ls(&quot;package:celldex&quot;) ## [1] &quot;BlueprintEncodeData&quot; &quot;DatabaseImmuneCellExpressionData&quot; ## [3] &quot;defineTextQuery&quot; &quot;fetchLatestVersion&quot; ## [5] &quot;fetchMetadata&quot; &quot;fetchReference&quot; ## [7] &quot;HumanPrimaryCellAtlasData&quot; &quot;ImmGenData&quot; ## [9] &quot;listReferences&quot; &quot;listVersions&quot; ## [11] &quot;MonacoImmuneData&quot; &quot;MouseRNAseqData&quot; ## [13] &quot;NovershternHematopoieticData&quot; &quot;saveReference&quot; ## [15] &quot;searchReferences&quot; &quot;surveyReferences&quot; f = &quot;../supp/single_ref/ref_BlueprintEncode.RData&quot; if(!file.exists(f)){ ref &lt;- celldex::BlueprintEncodeData() save(ref,file = f) } ref &lt;- get(load(f)) library(BiocParallel) scRNA = pbmc test = scRNA@assays$RNA$data pred.scRNA &lt;- SingleR(test = test, ref = ref, labels = ref$label.main, clusters = scRNA@active.ident) pred.scRNA$pruned.labels ## [1] &quot;CD4+ T-cells&quot; &quot;Monocytes&quot; &quot;B-cells&quot; &quot;CD8+ T-cells&quot; &quot;NK cells&quot; ## [6] &quot;CD4+ T-cells&quot; &quot;CD4+ T-cells&quot; &quot;Monocytes&quot; &quot;Monocytes&quot; &quot;Monocytes&quot; ## [11] &quot;DC&quot; &quot;Monocytes&quot; #查看注释准确性 plotScoreHeatmap(pred.scRNA, clusters=pred.scRNA@rownames, fontsize.row = 9,show_colnames = T) new.cluster.ids &lt;- pred.scRNA$pruned.labels names(new.cluster.ids) &lt;- levels(scRNA) levels(scRNA) ## [1] &quot;0&quot; &quot;1&quot; &quot;2&quot; &quot;3&quot; &quot;4&quot; &quot;5&quot; &quot;6&quot; &quot;7&quot; &quot;8&quot; &quot;9&quot; &quot;10&quot; &quot;11&quot; scRNA &lt;- RenameIdents(scRNA,new.cluster.ids) levels(scRNA) ## [1] &quot;CD4+ T-cells&quot; &quot;Monocytes&quot; &quot;B-cells&quot; &quot;CD8+ T-cells&quot; &quot;NK cells&quot; ## [6] &quot;DC&quot; p3 &lt;- DimPlot(scRNA, reduction = &quot;umap&quot;,label = T,pt.size = 0.5) + NoLegend() p2+p3 "],["单细胞二次分群.html", "第 10 章 单细胞二次分群 10.1 示例数据 10.2 二次分群 10.3 marker基因及其可视化 10.4 放回原来的Seurat对象里面", " 第 10 章 单细胞二次分群 背景知识 Seurat里的FindClusters函数设置的resolution数值越大，分群的数量就越多，但是当单细胞数量太多的时候，会遇到resolution再变大，分群的数量也不再增加的情况。一次分群分不开时就会需要二次分群。 10.1 示例数据 这里的示例数据seu.obj.Rdata是GSE218208降维聚类分群的结果，因为文件太大，没有直接放进文件夹里，如果load报错就自己运行一下隔壁GSE218208的代码得到这个文件再跑。 rm(list = ls()) library(Seurat) library(dplyr) load(&quot;../2.GSE218208/seu.obj.Rdata&quot;) p1 = DimPlot(seu.obj, reduction = &quot;umap&quot;,label=T)+NoLegend() p1 10.2 二次分群 这里以树突细胞(DC)为例进行二次分群，想要切换别的细胞类型直接修改下面的my_sub即可。 核心就是提取感兴趣的亚群的细胞，后面就是标准流程和可视化了，没有区别 my_sub = &quot;DC&quot; #⭐ sub.cells &lt;- subset(seu.obj, idents = my_sub) f = &quot;obj.Rdata&quot; if(!file.exists(f)){ sub.cells = sub.cells %&gt;% NormalizeData() %&gt;% FindVariableFeatures() %&gt;% ScaleData(features = rownames(.)) %&gt;% RunPCA(features = VariableFeatures(.)) %&gt;% FindNeighbors(dims = 1:15) %&gt;% FindClusters(resolution = 0.5) %&gt;% RunUMAP(dims = 1:15) save(sub.cells,file = f) } ## Modularity Optimizer version 1.3.0 by Ludo Waltman and Nees Jan van Eck ## ## Number of nodes: 88 ## Number of edges: 1998 ## ## Running Louvain algorithm... ## Maximum modularity in 10 random starts: 0.7358 ## Number of communities: 2 ## Elapsed time: 0 seconds load(f) DimPlot(sub.cells, reduction = &#39;umap&#39;,label = T)+NoLegend() 10.3 marker基因及其可视化 sub.cells.markers &lt;- FindAllMarkers(sub.cells, only.pos = TRUE, min.pct = 0.25, logfc.threshold = 0.25) top10 &lt;- sub.cells.markers %&gt;% group_by(cluster) %&gt;% top_n(n = 10, wt = avg_log2FC) %&gt;% pull(gene);top10 ## [1] &quot;LYZ&quot; &quot;TIMP1&quot; &quot;GPAT3&quot; &quot;ITGAX&quot; &quot;SAMSN1&quot; &quot;OLR1&quot; &quot;FPR3&quot; ## [8] &quot;EREG&quot; &quot;FCN1&quot; &quot;AKAP12&quot; &quot;JCHAIN&quot; &quot;IGKC&quot; &quot;MZB1&quot; &quot;PACSIN1&quot; ## [15] &quot;WNT10A&quot; &quot;MAP1A&quot; &quot;VASH2&quot; &quot;NIBAN3&quot; &quot;SMPD3&quot; &quot;TNFRSF4&quot; VlnPlot(sub.cells, features = top10) RidgePlot(sub.cells, features = top10) FeaturePlot(sub.cells, features = top10) DotPlot(sub.cells,features = top10)+ RotatedAxis() DoHeatmap(sub.cells, features = top10) + NoLegend() 10.4 放回原来的Seurat对象里面 上面的umap图是感兴趣的单独的展示，也可以把它放回原来的seurat对象里。 sub.cells@meta.data$celltype = paste0(&quot;M&quot;,sub.cells$seurat_clusters) seu.obj$celltype = as.character(Idents(seu.obj)) seu.obj$celltype = ifelse(seu.obj$celltype==my_sub, sub.cells$celltype[match(colnames(seu.obj),colnames(sub.cells))], seu.obj$celltype) Idents(seu.obj) = seu.obj$celltype p2 = DimPlot(seu.obj,label = T)+NoLegend() p1+p2 "],["多样本分析.html", "第 11 章 多样本分析 11.1 整理数据 11.2 批量读取 11.3 质控指标 11.4 整合降维聚类分群 11.5 注释 11.6 分组可视化及组件细胞比例比较 11.7 差异分析 11.8 伪bulk 转录组差异分析", " 第 11 章 多样本分析 这篇文章介绍的是有分组的单细胞数据怎样分析，数据来自GEO的GSE231920，有3个treat，3个control样本，代码完整，可以自行下载数据跑一跑，但请注意细胞数量是6w，对计算资源要求较高，自己的电脑跑不动，需要在服务器上跑。 11.1 整理数据 因为数据组织的不是每个样本一个文件夹的形式，所以需要自行整理，参考代码如下，注意这段改名的代码不要反复运行： GSE231920_RAW.tar是从GEO页面上下载的补充文件，太大了没放进文件夹里，可以自己下载。 #untar(&quot;GSE231920_RAW.tar&quot;,exdir = &quot;GSE231920_RAW&quot;) #unlink(&quot;GSE231920_RAW.tar&quot;) if(!require(&quot;multtest&quot;))BiocManager::install(&#39;multtest&#39;,update = F,ask = F) if(!require(&quot;metap&quot;))install.packages(&#39;metap&#39;,update = F,ask = F) library(stringr) fs = paste0(&quot;GSE231920_RAW/&quot;,dir(&quot;GSE231920_RAW/&quot;)) fs samples = dir(&quot;GSE231920_RAW/&quot;) %&gt;% str_split_i(&quot;_&quot;,2) %&gt;% unique();samples if(!dir.exists(&quot;01_data&quot;))dir.create(&quot;01_data&quot;) #为每个样本创建单独的文件夹 lapply(samples, function(s){ ns = paste0(&quot;01_data/&quot;,s) if(!file.exists(ns))dir.create(ns,recursive = T) }) #每个样本的三个文件复制到单独的文件夹 lapply(fs, function(s){ #s = fs[1] for(i in 1:length(samples)){ #i = 1 if(str_detect(s,samples[[i]])){ file.copy(s,paste0(&quot;01_data/&quot;,samples[[i]])) } } }) #文件名字修改 on = paste0(&quot;01_data/&quot;,dir(&quot;01_data/&quot;,recursive = T));on nn = str_remove(on,&quot;GSM\\\\d+_sample\\\\d_&quot;);nn file.rename(on,nn) 代码主要参考： https://satijalab.org/seurat/articles/integration_introduction 11.2 批量读取 rm(list = ls()) library(Seurat) rf = &quot;sce.all.Rdata&quot; if(!file.exists(rf)){ f = dir(&quot;01_data/&quot;) scelist = list() for(i in 1:length(f)){ pda &lt;- Read10X(paste0(&quot;01_data/&quot;,f[[i]])) scelist[[i]] &lt;- CreateSeuratObject(counts = pda, project = f[[i]]) print(dim(scelist[[i]])) } sce.all = merge(scelist[[1]],scelist[-1]) sce.all = JoinLayers(sce.all) #⭐抽样 set.seed(313) sce.all = subset(sce.all,downsample=500)#每个样本抽500个细胞 save(sce.all,file = rf) } load(rf) head(sce.all@meta.data) table(sce.all$orig.ident) sum(table(Idents(sce.all))) 11.3 质控指标 sce.all[[&quot;percent.mt&quot;]] &lt;- PercentageFeatureSet(sce.all, pattern = &quot;^MT-&quot;) sce.all[[&quot;percent.rp&quot;]] &lt;- PercentageFeatureSet(sce.all, pattern = &quot;^RP[SL]&quot;) sce.all[[&quot;percent.hb&quot;]] &lt;- PercentageFeatureSet(sce.all, pattern = &quot;^HB[^(P)]&quot;) head(sce.all@meta.data, 3) VlnPlot(sce.all, features = c(&quot;nFeature_RNA&quot;, &quot;nCount_RNA&quot;, &quot;percent.mt&quot;, &quot;percent.rp&quot;, &quot;percent.hb&quot;), ncol = 3,pt.size = 0, group.by = &quot;orig.ident&quot;) sce.all = subset(sce.all,percent.mt&lt;25) 11.4 整合降维聚类分群 f = &quot;obj.Rdata&quot; library(harmony) if(!file.exists(f)){ sce.all = sce.all %&gt;% NormalizeData() %&gt;% FindVariableFeatures() %&gt;% ScaleData(features = rownames(.)) %&gt;% RunPCA(pc.genes = VariableFeatures(.)) %&gt;% RunHarmony(&quot;orig.ident&quot;) %&gt;% FindNeighbors(dims = 1:15, reduction = &quot;harmony&quot;) %&gt;% FindClusters(resolution = 0.5) %&gt;% RunUMAP(dims = 1:15,reduction = &quot;harmony&quot;) %&gt;% RunTSNE(dims = 1:15,reduction = &quot;harmony&quot;) save(sce.all,file = f) } load(f) ElbowPlot(sce.all) UMAPPlot(sce.all,label = T) TSNEPlot(sce.all,label = T) 11.5 注释 ⭐这里用了两个参考数据 library(celldex) library(SingleR) ls(&quot;package:celldex&quot;) f = &quot;../supp/single_ref/ref_BlueprintEncode.RData&quot; if(!file.exists(f)){ ref &lt;- celldex::ref_BlueprintEncode() save(ref,file = f) } f2 = &quot;../supp/single_ref/ref_HumanPrimaryCellAtlasData.RData&quot; if(!file.exists(f2)){ ref &lt;- celldex::HumanPrimaryCellAtlasData() save(ref,file = f2) } ref &lt;- list(get(load(f)), get(load(f2))) library(BiocParallel) scRNA = sce.all test = scRNA@assays$RNA$data pred.scRNA &lt;- SingleR(test = test, ref = ref, labels = list(ref[[1]]$label.main,ref[[2]]$label.main), clusters = scRNA@active.ident) pred.scRNA$pruned.labels #查看注释准确性 #plotScoreHeatmap(pred.scRNA, clusters=pred.scRNA@rownames, fontsize.row = 9,show_colnames = T) new.cluster.ids &lt;- pred.scRNA$pruned.labels new.cluster.ids[is.na(new.cluster.ids)] = &quot;unknown&quot; names(new.cluster.ids) &lt;- levels(scRNA) levels(scRNA) scRNA &lt;- RenameIdents(scRNA,new.cluster.ids) levels(scRNA) p2 &lt;- DimPlot(scRNA, reduction = &quot;umap&quot;,label = T,pt.size = 0.5) + NoLegend() p2 11.6 分组可视化及组件细胞比例比较 scRNA$seurat_annotations = Idents(scRNA) table(scRNA$orig.ident) library(tinyarray) pd = geo_download(&quot;GSE231920&quot;)$pd pd$title scRNA$group = ifelse(scRNA$orig.ident %in% c(&quot;sample1&quot;,&quot;sample2&quot;,&quot;sample3&quot;), &quot;treat&quot;,&quot;control&quot;) DimPlot(scRNA, reduction = &quot;umap&quot;, group.by = &quot;group&quot;) 可以计算每个亚群的细胞数量和占全部细胞的比例 # 每种细胞的数量和比例 cell_counts &lt;- table(Idents(scRNA)) cell.all &lt;- cbind(cell_counts = cell_counts, cell_Freq = round(prop.table(cell_counts)*100,2)) #各组中每种细胞的数量和比例 cell.num.group &lt;- table(Idents(scRNA), scRNA$group) cell.freq.group &lt;- round(prop.table(cell.num.group, margin = 2) *100,2) cell.all = cbind(cell.all,cell.num.group,cell.freq.group) cell.all = cell.all[,c(1,3,4,2,5,6)] colnames(cell.all) = paste(rep(c(&quot;all&quot;,&quot;control&quot;,&quot;treat&quot;),times = 2), rep(c(&quot;count&quot;,&quot;freq&quot;),each = 3),sep = &quot;_&quot;) cell.all 11.7 差异分析 找某种细胞在不同组间的差异基因 table(scRNA$seurat_annotations) sub.markers &lt;- FindConservedMarkers(scRNA, ident.1 = &quot;NK cells&quot;, grouping.var = &quot;group&quot;, min.pct = 0.25, logfc.threshold = 0.25,verbose = F) head(sub.markers) 组间比较的气泡图 markers.to.plot = c(&quot;CD3D&quot;, &quot;CREM&quot;, &quot;HSPH1&quot;, &quot;SELL&quot;, &quot;GIMAP5&quot;, &quot;CACYBP&quot;, &quot;GNLY&quot;, &quot;NKG7&quot;, &quot;CCL5&quot;, &quot;CD8A&quot;, &quot;MS4A1&quot;, &quot;CD79A&quot;, &quot;MIR155HG&quot;, &quot;NME1&quot;, &quot;FCGR3A&quot;, &quot;VMO1&quot;, &quot;CCL2&quot;, &quot;S100A9&quot;, &quot;HLA-DQA1&quot;, &quot;GPR183&quot;, &quot;PPBP&quot;, &quot;GNG11&quot;, &quot;HBA2&quot;, &quot;HBB&quot;, &quot;TSPAN13&quot;, &quot;IL3RA&quot;, &quot;PRSS57&quot;) #一组感兴趣的基因 #如果idents有NA会报错https://github.com/satijalab/seurat/issues/8772 #scRNA &lt;- subset(scRNA, seurat_annotations %in% na.omit(scRNA$seurat_annotations)) DotPlot(scRNA, features = markers.to.plot, cols = c(&quot;blue&quot;, &quot;red&quot;), dot.scale = 8, split.by = &quot;group&quot;) + RotatedAxis() FeaturePlot(scRNA, features = c(&quot;CD3D&quot;, &quot;GNLY&quot;, &quot;IFI6&quot;), split.by = &quot;group&quot;, max.cutoff = 3, cols = c(&quot;grey&quot;, &quot;red&quot;), reduction = &quot;umap&quot;) plots &lt;- VlnPlot(scRNA, features = c(&quot;LYZ&quot;, &quot;ISG15&quot;, &quot;CXCL10&quot;), split.by = &quot;group&quot;, group.by = &quot;seurat_annotations&quot;, pt.size = 0, combine = FALSE) library(patchwork) wrap_plots(plots = plots, ncol = 1) 11.8 伪bulk 转录组差异分析 每个组要有多个样本才能做 https://satijalab.org/seurat/articles/parsebio_sketch_integration bulk &lt;- AggregateExpression(scRNA, return.seurat = T, slot = &quot;counts&quot;, assays = &quot;RNA&quot;, group.by = c(&quot;seurat_annotations&quot;,&quot;orig.ident&quot;, &quot;group&quot;)) sub &lt;- subset(bulk, seurat_annotations == &quot;CD8+ T-cells&quot;) Idents(sub) &lt;- &quot;group&quot; de_markers &lt;- FindMarkers(sub, ident.1 = &quot;treat&quot;, ident.2 = &quot;control&quot;, slot = &quot;counts&quot;, test.use = &quot;DESeq2&quot;, verbose = F) de_markers$gene &lt;- rownames(de_markers) k1 = de_markers$avg_log2FC&lt; -1 &amp; de_markers$p_val &lt;0.01 k2 = de_markers$avg_log2FC&gt; 1 &amp; de_markers$p_val &lt;0.01 de_markers$change &lt;- ifelse(k1,&quot;down&quot;,ifelse(k2,&quot;up&quot;,&quot;not&quot;)) library(ggplot2) library(ggrepel) ggplot(de_markers, aes(avg_log2FC, -log10(p_val),color = change)) + geom_point(size = 2, alpha = 0.5) + geom_vline(xintercept = c(1,-1),linetype = 4)+ geom_hline(yintercept = -log10(0.01),linetype = 4)+ scale_color_manual(values = c(&quot;blue&quot;,&quot;grey&quot;,&quot;red&quot;))+ theme_bw() + ylab(&quot;-log10(unadjusted p-value)&quot;) "],["单样本拟时序分析.html", "第 12 章 单样本拟时序分析 12.1 构建细胞发育轨迹 12.2 绘图展示", " 第 12 章 单样本拟时序分析 ** 背景知识 ** 做拟时序分析是为了探索自己感兴趣的几种细胞之间的发育关系，一般不是用全部类型的细胞来做的。 如果让ai来说拟时序的目的那就比我说的多: &gt; 拟时序分析（Pseudo-time analysis）是一种用于理解细胞状态和细胞命运变化的计算生物学方法。这种分析通常用于单细胞测序数据，其目的是重建细胞发育或疾病进程中的时间序列，即使实际的时间信息不可用。以下是进行拟时序分析的几个主要目的： 1. 细胞状态推断：通过分析单个细胞的基因表达模式，推断细胞在生物学过程中所处的状态。 2. 细胞轨迹追踪：重建细胞从一种状态转变到另一种状态的路径，这有助于理解细胞分化、发育或疾病进展的过程。 3. 细胞命运预测：预测细胞随时间可能采取的发育轨迹，尤其是在干细胞分化或癌症发展的研究中。 4. 动态过程建模：创建细胞状态变化的动态模型，这有助于揭示细胞行为的内在规律和调控机制。 5. 细胞亚群识别：在复杂的细胞群体中识别不同的细胞亚群，并理解它们在生物学过程中的作用。 6. 基因调控网络推断：通过分析基因表达随“拟时间”的变化，推断基因调控网络和信号传导途径。 7. 疾病机理探索：在疾病研究中，拟时序分析有助于揭示疾病发生和发展的分子机制。 8. 药物作用机制研究：通过观察药物处理前后细胞状态的变化，研究药物的作用机制和效果。 拟时序分析是一种强大的工具，它可以帮助研究者在没有直接时间标记的情况下，通过基因表达数据来探索细胞状态的变化和动态过程。这种方法在单细胞生物学、发育生物学、癌症生物学和神经科学等领域有着广泛的应用。 本篇代码是处理单样本数据的，下一篇是多样本的。 rm(list = ls()) library(Seurat) library(monocle) library(dplyr) load(&quot;../2.GSE218208/seu.obj.Rdata&quot;) DimPlot(seu.obj,label = T) table(Idents(seu.obj)) ## ## Naive CD4 T CD14+ Mono B CD8 T NK FCGR3A+ Mono ## 1675 1206 598 406 337 125 ## Platelet DC ## 48 88 这里的示例数据seu.obj.Rdata是GSE218208降维聚类分群的结果，因为文件太大，没有直接放进文件夹里，如果load报错就自己运行一下隔壁GSE218208的代码得到这个文件再跑。 seu.obj$celltype = as.character(Idents(seu.obj)) 👆将注释的结果添加到了meta表格里面成为了celltype列。 为了节省计算资源我们还是抽样，实战时不能抽样哦。你跑完我的代码换个别的细胞类型跑跑看。注意差异分析那里加上了存在即跳过的代码，换了输入数据是要删除Rdata重新跑，或者是换一个工作目录跑。 scRNA = subset(seu.obj,idents = c(&quot;CD14+ Mono&quot;,&quot;FCGR3A+ Mono&quot;)) set.seed(1234) scRNA = subset(scRNA,downsample = 100)#每种细胞抽100个 提取想要研究的两种细胞。 因为monocle和seurat是两个不同的体系，所以需要将seurat对象转换为monocle可以接受的CellDataSet对象。虽然monocle3已经出来很久了，但大家都不约而同的选择monocle2，大概就是习惯了吧。。 ct &lt;- scRNA@assays$RNA$counts gene_ann &lt;- data.frame( gene_short_name = row.names(ct), row.names = row.names(ct) ) pd &lt;- new(&quot;AnnotatedDataFrame&quot;, data=scRNA@meta.data) fd &lt;- new(&quot;AnnotatedDataFrame&quot;, data=gene_ann) sc_cds &lt;- newCellDataSet( ct, phenoData = pd, featureData =fd, expressionFamily = negbinomial.size(), lowerDetectionLimit=1) sc_cds ## CellDataSet (storageMode: environment) ## assayData: 25988 features, 200 samples ## element names: exprs ## protocolData: none ## phenoData ## sampleNames: AAACCCAAGTAGGGTC AAAGGTAGTCTTGAGT ... TTTGGAGAGTCCCAGC ## (200 total) ## varLabels: orig.ident nCount_RNA ... Size_Factor (8 total) ## varMetadata: labelDescription ## featureData ## featureNames: TSPAN6 DPM1 ... AL357874.3 (25988 total) ## fvarLabels: gene_short_name ## fvarMetadata: labelDescription ## experimentData: use &#39;experimentData(object)&#39; ## Annotation: 12.1 构建细胞发育轨迹 选择基因有不同的策略，比如 1.使用seurat给出的高变化基因 2.按照平均表达量大于某个数字(比如0.1，官网用的是这个)的基因 3.使用不同细胞类型之间的差异基因，differentialGeneTest计算。 我们默认使用的是最后一个策略。 sc_cds &lt;- estimateSizeFactors(sc_cds) sc_cds &lt;- estimateDispersions(sc_cds) table(scRNA@meta.data$celltype) ## ## CD14+ Mono FCGR3A+ Mono ## 100 100 fdif = &quot;diff_test_res.Rdata&quot; if(!file.exists(fdif)){ diff_test_res &lt;- differentialGeneTest(sc_cds, fullModelFormulaStr = &quot;~celltype&quot;, cores = 4) save(diff_test_res,file = fdif) } load(fdif) ordering_genes &lt;- row.names (subset(diff_test_res, qval &lt; 0.01)) #然后是查看基因，设置为排序要使用的基因 head(ordering_genes) ## [1] &quot;CD99&quot; &quot;CASP10&quot; &quot;SLC25A5&quot; &quot;MCUB&quot; &quot;ITGAL&quot; &quot;TNFRSF12A&quot; sc_cds &lt;- setOrderingFilter(sc_cds, ordering_genes) plot_ordering_genes(sc_cds) #降维 sc_cds &lt;- reduceDimension(sc_cds) #细胞排序 sc_cds &lt;- orderCells(sc_cds) 12.2 绘图展示 发育轨迹图 library(ggsci) p1 = plot_cell_trajectory(sc_cds)+ scale_color_nejm() p2 = plot_cell_trajectory(sc_cds, color_by = &#39;Pseudotime&#39;) p3 = plot_cell_trajectory(sc_cds, color_by = &#39;celltype&#39;) + scale_color_npg() library(patchwork) p2+p1/p3 这三种着色方式放在一起非常的带劲，很清晰的展示了pseudotime、state和celltype是怎样变化的。 经典的拟时序热图 展示了一些基因是如何随着时间轨迹的变化而渐变的，这个渐变不同于findmarkers，是体现变化过程的，而不是直接给出差异表达的基因。 gene_to_cluster = diff_test_res %&gt;% arrange(qval) %&gt;% head(50) %&gt;% pull(gene_short_name);head(gene_to_cluster) ## [1] &quot;S100A9&quot; &quot;S100A8&quot; &quot;FCGR3A&quot; &quot;VMO1&quot; &quot;TIMP1&quot; &quot;MS4A7&quot; plot_pseudotime_heatmap(sc_cds[gene_to_cluster,], num_clusters = nlevels(Idents(scRNA)), show_rownames = TRUE, cores = 4,return_heatmap = TRUE, hmcols = colorRampPalette(c(&quot;navy&quot;, &quot;white&quot;, &quot;firebrick3&quot;))(100)) 用感兴趣的基因给轨迹图着色，gs可以换成你想换的基因 gs = head(gene_to_cluster) plot_cell_trajectory(sc_cds,markers=gs, use_color_gradient=T) 也可以是jitter plot_genes_jitter(sc_cds[gs,], grouping = &quot;celltype&quot;, color_by = &quot;celltype&quot;, nrow= 3, ncol = NULL ) "],["多样本拟时序分析.html", "第 13 章 多样本拟时序分析 13.1 构建细胞发育轨迹 13.2 绘图展示", " 第 13 章 多样本拟时序分析 ** 背景知识** 做拟时序分析是为了探索自己感兴趣的几种细胞之间的发育关系，一般不是用全部类型的细胞来做的。例如本例中选择了CD14和CD16单核细胞。 如果让ai来说拟时序的目的那就比我说的多: &gt; 拟时序分析（Pseudo-time analysis）是一种用于理解细胞状态和细胞命运变化的计算生物学方法。这种分析通常用于单细胞测序数据，其目的是重建细胞发育或疾病进程中的时间序列，即使实际的时间信息不可用。以下是进行拟时序分析的几个主要目的： 1. 细胞状态推断：通过分析单个细胞的基因表达模式，推断细胞在生物学过程中所处的状态。 2. 细胞轨迹追踪：重建细胞从一种状态转变到另一种状态的路径，这有助于理解细胞分化、发育或疾病进展的过程。 3. 细胞命运预测：预测细胞随时间可能采取的发育轨迹，尤其是在干细胞分化或癌症发展的研究中。 4. 动态过程建模：创建细胞状态变化的动态模型，这有助于揭示细胞行为的内在规律和调控机制。 5. 细胞亚群识别：在复杂的细胞群体中识别不同的细胞亚群，并理解它们在生物学过程中的作用。 6. 基因调控网络推断：通过分析基因表达随“拟时间”的变化，推断基因调控网络和信号传导途径。 7. 疾病机理探索：在疾病研究中，拟时序分析有助于揭示疾病发生和发展的分子机制。 8. 药物作用机制研究：通过观察药物处理前后细胞状态的变化，研究药物的作用机制和效果。 拟时序分析是一种强大的工具，它可以帮助研究者在没有直接时间标记的情况下，通过基因表达数据来探索细胞状态的变化和动态过程。这种方法在单细胞生物学、发育生物学、癌症生物学和神经科学等领域有着广泛的应用。 今天的代码是处理多样本数据的，单样本的在前一篇。 使用的数据sce.all.Rdata是Seurat降维聚类分群注释的结果，有两个样本。 rm(list = ls()) library(Seurat) library(monocle) library(dplyr) load(&quot;sce.all.Rdata&quot;) DimPlot(sce.all,label = T)+NoLegend() table(sce.all$celltype) ## ## B B Activated CD14 Mono CD16 Mono CD4 Memory T CD4 Naive T ## 100 100 100 100 100 100 ## CD8 T DC Mk NK pDC T activated ## 100 100 100 100 100 100 本文的输入数据是seurat做完降维聚类分群注释的数据，为了节省计算资源，我已经抽样减少细胞数量了。并将注释的结果添加到了meta表格里面成为了celltype列。 我这里只是举例，没有考虑背景知识，提取两种细胞： scRNA = subset(sce.all,idents = c(&quot;CD14 Mono&quot;,&quot;CD16 Mono&quot;)) table(scRNA$celltype) ## ## CD14 Mono CD16 Mono ## 100 100 table(scRNA$orig.ident) ## ## IMMUNE_CTRL IMMUNE_STIM ## 105 95 因为monocle和seurat是两个不同的体系，所以需要将seurat对象转换为monocle可以接受的CellDataSet对象。虽然monocle3已经出来很久了，但大家都不约而同的选择monocle2，大概就是习惯了吧。。 ct &lt;- scRNA@assays$RNA$counts gene_ann &lt;- data.frame( gene_short_name = row.names(ct), row.names = row.names(ct) ) pd &lt;- new(&quot;AnnotatedDataFrame&quot;, data=scRNA@meta.data) fd &lt;- new(&quot;AnnotatedDataFrame&quot;, data=gene_ann) sc_cds &lt;- newCellDataSet( ct, phenoData = pd, featureData =fd, expressionFamily = negbinomial.size(), lowerDetectionLimit=1) sc_cds ## CellDataSet (storageMode: environment) ## assayData: 14053 features, 200 samples ## element names: exprs ## protocolData: none ## phenoData ## sampleNames: AAACGGCTTACTCT.1 AAATACTGGTTCTT.1 ... TTGGAGTGCTCGAA.11 ## (200 total) ## varLabels: orig.ident nCount_RNA ... Size_Factor (19 total) ## varMetadata: labelDescription ## featureData ## featureNames: AL627309.1 RP11-206L10.2 ... LRRC3DN (14053 total) ## fvarLabels: gene_short_name ## fvarMetadata: labelDescription ## experimentData: use &#39;experimentData(object)&#39; ## Annotation: 13.1 构建细胞发育轨迹 选择基因有不同的策略，比如 1.使用seurat给出的高变化基因 2.按照平均表达量大于某个数字(比如0.1，官网用的是这个)的基因 3.使用不同细胞类型之间的差异基因，differentialGeneTest计算。 我们默认使用的是最后一个策略。 sc_cds &lt;- estimateSizeFactors(sc_cds) sc_cds &lt;- estimateDispersions(sc_cds) table(scRNA@meta.data$celltype) ## ## CD14 Mono CD16 Mono ## 100 100 fdif = &quot;diff_test_res.Rdata&quot; if(!file.exists(fdif)){ diff_test_res &lt;- differentialGeneTest(sc_cds, fullModelFormulaStr = &quot; ~ celltype + orig.ident&quot;, reducedModelFormulaStr = &quot; ~ orig.ident&quot;, cores = 4) save(diff_test_res,file = fdif) } load(fdif) ordering_genes &lt;- row.names (subset(diff_test_res, qval &lt; 0.01)) #然后是查看基因，设置为排序要使用的基因 head(ordering_genes) ## [1] &quot;C1QA&quot; &quot;C1QB&quot; &quot;SH3BGRL3&quot; &quot;MARCKSL1&quot; &quot;YBX1&quot; &quot;TMEM59&quot; sc_cds &lt;- setOrderingFilter(sc_cds, ordering_genes) plot_ordering_genes(sc_cds) #降维 sc_cds &lt;- reduceDimension(sc_cds,residualModelFormulaStr = &quot;~orig.ident&quot;) #细胞排序 sc_cds &lt;- orderCells(sc_cds) 13.2 绘图展示 发育轨迹图 library(ggsci) p1 = plot_cell_trajectory(sc_cds)+ scale_color_nejm() p2 = plot_cell_trajectory(sc_cds, color_by = &#39;Pseudotime&#39;) p3 = plot_cell_trajectory(sc_cds, color_by = &#39;celltype&#39;) + scale_color_npg() library(patchwork) p2+p1/p3 这三种着色方式放在一起非常的带劲，很清晰的展示了pseudotime、state和celltype是怎样变化的。 以orig.ident着色可以看出，不同样本中的细胞基本是均匀分布在轨迹上的，说明前面的代码很好的去除了样本间的批次效应 plot_cell_trajectory(sc_cds, color_by = &#39;orig.ident&#39;) 经典的拟时序热图 展示了一些基因是如何随着时间轨迹的变化而渐变的，这个渐变不同于findmarkers，是体现变化过程的，而不是直接给出差异表达的基因。 gene_to_cluster = diff_test_res %&gt;% arrange(qval) %&gt;% head(50) %&gt;% pull(gene_short_name);head(gene_to_cluster) ## [1] &quot;VMO1&quot; &quot;CCL2&quot; &quot;CCL7&quot; &quot;S100A8&quot; &quot;FCGR3A&quot; &quot;S100A9&quot; plot_pseudotime_heatmap(sc_cds[gene_to_cluster,], num_clusters = nlevels(Idents(scRNA)), show_rownames = TRUE, cores = 4,return_heatmap = TRUE, hmcols = colorRampPalette(c(&quot;navy&quot;, &quot;white&quot;, &quot;firebrick3&quot;))(100)) 用感兴趣的基因给轨迹图着色，gs可以换成你想换的基因 gs = head(gene_to_cluster) plot_cell_trajectory(sc_cds,markers=gs, use_color_gradient=T) 也可以是jitter plot_genes_jitter(sc_cds[gs,], grouping = &quot;celltype&quot;, color_by = &quot;celltype&quot;, nrow= 3, ncol = NULL ) "],["cellchat-单数据集分析.html", "第 14 章 cellchat 单数据集分析 14.1 数据输入、处理及 cellchat 对象初始化 14.2 细胞间通讯网络推断 14.3 细胞间通信网络的可视化 14.4 细胞间通信网络的系统分析 14.5 保存 cellchaat 对象 14.6 通过交互式 CellChat 探索器探索细胞间通讯", " 第 14 章 cellchat 单数据集分析 library(CellChat) library(patchwork) library(NMF) library(ggalluvial) options(stringsAsFactors = FALSE) # reticulate::use_python(&quot;/Users/suoqinjin/anaconda3/bin/python&quot;, required=T) 14.1 数据输入、处理及 cellchat 对象初始化 CellChat 需要两个输入：一是细胞的基因表达数据，二是用户指定的细胞标签。 CellChat 需要细胞的基因表达数据作为输入，并通过将基因表达与信号配体、受体及其辅因子之间相互作用的先验知识相结合来模拟细胞间通讯的概率。 ### 准备 cellchat 分析所需要的输入数据 (可选) #### （A）从计数矩阵开始 data.input = data_humanSkin$data # normalized data matrix meta = data_humanSkin$meta # a dataframe with rownames containing cell mata data cell.use = rownames(meta)[meta$condition == &quot;LS&quot;] # extract the cell names from disease data 14.1.0.1 （B）从 Seurat 对象开始 library(Seurat) seurat_object &lt;- pbmc3k # load the Seurat objec Idents(seurat_object) &lt;- seurat_object$seurat_annotations # set the cell indentity data.input &lt;- seurat_object[[&quot;RNA&quot;]]@data # normalized data matrix # For Seurat version &lt;= “5.0.0”, get the normalized data via `seurat_object[[&quot;RNA&quot;]]@data` labels &lt;- Idents(seurat_object) meta &lt;- data.frame(labels = labels, row.names = names(labels)) # create a dataframe of the cell labels 14.1.1 创建 cellchat 对象 14.1.1.1 （B）从 Seurat 对象开始 如果输入的是 Seurat 或 SingleCellExperiment 对象，则默认使用对象中的元数据，并且必须提供 group.by 来定义细胞组。例如，group.by = “ident” 表示 Seurat 对象中的默认细胞标识。 cellchat &lt;- createCellChat(object = seurat_object, group.by = &quot;ident&quot;, assay = &quot;RNA&quot;) ## [1] &quot;Create a CellChat object from a Seurat object&quot; ## The `meta.data` slot in the Seurat object is used as cell meta information ## Set cell identities for the new CellChat object ## The cell groups used for CellChat analysis are Naive CD4 T, Memory CD4 T, CD14+ Mono, B, CD8 T, FCGR3A+ Mono, NK, DC, Platelet 如果在创建 CellChat 对象时没有添加单元格 mata 信息，用户也可以稍后使用 addMeta 添加，并使用 setIdent 设置默认单元格标识。 cellchat &lt;- addMeta(cellchat, meta = meta) cellchat &lt;- setIdent(cellchat, ident.use = &quot;labels&quot;) # set &quot;labels&quot; as default cell identity levels(cellchat@idents) # show factor levels of the cell labels groupSize &lt;- as.numeric(table(cellchat@idents)) # number of cells in each cell group 14.1.2 设置配体-受体相互作用数据库 在使用 CellChat 推断细胞间通讯之前，需要设置配体-受体相互作用数据库并识别过度表达的配体或受体。 CellChatDB 是一个人工整理的数据库，包含文献支持的人类和小鼠配体-受体相互作用。 CellChatDB v2 包含约 3,300 个已验证的分子相互作用， 其中包括约 40% 的分泌性自分泌/旁分泌信号相互作用、约 17% 的细胞外基质 (ECM)-受体相互作用、 约 13% 的细胞间接触相互作用以及约 30% 的非蛋白信号传导。 与 CellChatDB v1 相比，CellChatDB v2 增加了 1000 多种蛋白质和非蛋白质相互作用， 例如代谢和突触信号。需要注意的是，对于与 scRNA-seq 中测量的基因无直接关联的分子， CellChat v2 会利用这些分子的关键介质或酶来估计配体和受体的表达，以了解可能由非蛋白介导的通讯。 CellChatDB v2 还添加了配体-受体对的额外功能注释， 例如 UniProtKB 关键词（包括生物过程、分子功能、功能类别、疾病等）、亚细胞定位和与神经递质的相关性。 可以通过添加自己精选的配体-受体对来更新 CellChatDB。请查看更新配体-受体相互作用数据库 CellChatDB 的教程 。 分析人体样本时，使用数据库 CellChatDB.human ; 分析小鼠时 样本，使用数据库 CellChatDB.mouse 。CellChatDB 将配体-受体对分为不同的类型，包括“分泌信号”、“ECM-受体”、“细胞-细胞接触”和“非蛋白信号”。默认情况下，“非蛋白信号”不使用。 CellChatDB &lt;- CellChatDB.human # use CellChatDB.mouse if running on mouse data showDatabaseCategory(CellChatDB) # Show the structure of the database dplyr::glimpse(CellChatDB$interaction) ## Rows: 3,234 ## Columns: 28 ## $ interaction_name &lt;chr&gt; &quot;TGFB1_TGFBR1_TGFBR2&quot;, &quot;TGFB2_TGFBR1_TGFBR2&quot;,… ## $ pathway_name &lt;chr&gt; &quot;TGFb&quot;, &quot;TGFb&quot;, &quot;TGFb&quot;, &quot;TGFb&quot;, &quot;TGFb&quot;, &quot;TGFb… ## $ ligand &lt;chr&gt; &quot;TGFB1&quot;, &quot;TGFB2&quot;, &quot;TGFB3&quot;, &quot;TGFB1&quot;, &quot;TGFB1&quot;, … ## $ receptor &lt;chr&gt; &quot;TGFbR1_R2&quot;, &quot;TGFbR1_R2&quot;, &quot;TGFbR1_R2&quot;, &quot;ACVR1… ## $ agonist &lt;chr&gt; &quot;TGFb agonist&quot;, &quot;TGFb agonist&quot;, &quot;TGFb agonist… ## $ antagonist &lt;chr&gt; &quot;TGFb antagonist&quot;, &quot;TGFb antagonist&quot;, &quot;TGFb a… ## $ co_A_receptor &lt;chr&gt; &quot;&quot;, &quot;&quot;, &quot;&quot;, &quot;&quot;, &quot;&quot;, &quot;&quot;, &quot;&quot;, &quot;&quot;, &quot;&quot;, &quot;&quot;, &quot;&quot;, &quot;… ## $ co_I_receptor &lt;chr&gt; &quot;TGFb inhibition receptor&quot;, &quot;TGFb inhibition … ## $ evidence &lt;chr&gt; &quot;KEGG: hsa04350&quot;, &quot;KEGG: hsa04350&quot;, &quot;KEGG: hs… ## $ annotation &lt;chr&gt; &quot;Secreted Signaling&quot;, &quot;Secreted Signaling&quot;, &quot;… ## $ interaction_name_2 &lt;chr&gt; &quot;TGFB1 - (TGFBR1+TGFBR2)&quot;, &quot;TGFB2 - (TGFBR1+T… ## $ is_neurotransmitter &lt;lgl&gt; FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FAL… ## $ ligand.symbol &lt;chr&gt; &quot;TGFB1&quot;, &quot;TGFB2&quot;, &quot;TGFB3&quot;, &quot;TGFB1&quot;, &quot;TGFB1&quot;, … ## $ ligand.family &lt;chr&gt; &quot;TGF-beta&quot;, &quot;TGF-beta&quot;, &quot;TGF-beta&quot;, &quot;TGF-beta… ## $ ligand.location &lt;chr&gt; &quot;Extracellular matrix, Secreted, Extracellula… ## $ ligand.keyword &lt;chr&gt; &quot;Disease variant, Signal, Reference proteome,… ## $ ligand.secreted_type &lt;chr&gt; &quot;growth factor&quot;, &quot;growth factor&quot;, &quot;cytokine;g… ## $ ligand.transmembrane &lt;lgl&gt; FALSE, FALSE, TRUE, FALSE, FALSE, FALSE, FALS… ## $ receptor.symbol &lt;chr&gt; &quot;TGFBR2, TGFBR1&quot;, &quot;TGFBR2, TGFBR1&quot;, &quot;TGFBR2, … ## $ receptor.family &lt;chr&gt; &quot;Protein kinase superfamily, TKL Ser/Thr prot… ## $ receptor.location &lt;chr&gt; &quot;Cell membrane, Secreted, Membrane raft, Cell… ## $ receptor.keyword &lt;chr&gt; &quot;Membrane, Secreted, Disulfide bond, Kinase, … ## $ receptor.surfaceome_main &lt;chr&gt; &quot;Receptors&quot;, &quot;Receptors&quot;, &quot;Receptors&quot;, &quot;Recep… ## $ receptor.surfaceome_sub &lt;chr&gt; &quot;Act.TGFB;Kinase&quot;, &quot;Act.TGFB;Kinase&quot;, &quot;Act.TG… ## $ receptor.adhesome &lt;chr&gt; &quot;&quot;, &quot;&quot;, &quot;&quot;, &quot;&quot;, &quot;&quot;, &quot;&quot;, &quot;&quot;, &quot;&quot;, &quot;&quot;, &quot;&quot;, &quot;&quot;, &quot;… ## $ receptor.secreted_type &lt;chr&gt; &quot;&quot;, &quot;&quot;, &quot;&quot;, &quot;&quot;, &quot;&quot;, &quot;&quot;, &quot;&quot;, &quot;&quot;, &quot;&quot;, &quot;&quot;, &quot;&quot;, &quot;… ## $ receptor.transmembrane &lt;lgl&gt; TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRU… ## $ version &lt;chr&gt; &quot;CellChatDB v1&quot;, &quot;CellChatDB v1&quot;, &quot;CellChatDB… # use a subset of CellChatDB for cell-cell communication analysis CellChatDB.use &lt;- subsetDB(CellChatDB, search = &quot;Secreted Signaling&quot;, key = &quot;annotation&quot;) # use Secreted Signaling # Only uses the Secreted Signaling from CellChatDB v1 # CellChatDB.use &lt;- subsetDB(CellChatDB, search = list(c(&quot;Secreted Signaling&quot;), c(&quot;CellChatDB v1&quot;)), key = c(&quot;annotation&quot;, &quot;version&quot;)) # use all CellChatDB except for &quot;Non-protein Signaling&quot; for cell-cell communication analysis # CellChatDB.use &lt;- subsetDB(CellChatDB) # use all CellChatDB for cell-cell communication analysis # CellChatDB.use &lt;- CellChatDB # simply use the default CellChatDB. We do not suggest to use it in this way because CellChatDB v2 includes &quot;Non-protein Signaling&quot; (i.e., metabolic and synaptic signaling). # set the used database in the object cellchat@DB &lt;- CellChatDB.use 14.1.3 细胞间通讯分析的表达数据预处理 为了推断细胞状态特定的通信，CellChat 会识别一个细胞组中过度表达的配体或受体，然后识别过度表达的配体-受体相互作用（如果配体或受体过度表达）。 我们还提供了一个功能，可以将基因表达数据投射到蛋白质-蛋白质相互作用（PPI）网络上。具体来说，这个功能使用扩散过程来根据高置信度实验验证的蛋白质-蛋白质网络中定义的邻居来平滑基因的表达值。当分析测序深度较浅的单细胞数据时，这个功能非常有用，因为投射可以减少信号基因的掉落效应（dropout effects），特别是对于可能为零表达的配体/受体亚基。有人可能会担心这种扩散过程引入的可能伪影，然而，它只会引入非常弱的通讯。默认情况下，CellChat 使用原始数据（即，object@data.signaling）而不是投射数据。要使用投射数据，用户应在运行 computeCommunProb 之前运行 projectData 函数，然后在运行 computeCommunProb 时设置 raw.use = FALSE。 # subset the expression data of signaling genes for saving computation cost cellchat &lt;- subsetData(cellchat) # This step is necessary even if using the whole database future::plan(&quot;multisession&quot;, workers = 4) # do parallel cellchat &lt;- identifyOverExpressedGenes(cellchat) cellchat &lt;- identifyOverExpressedInteractions(cellchat) ## The number of highly variable ligand-receptor pairs used for signaling inference is 135 # project gene expression data onto PPI (Optional: when running it, USER should set `raw.use = FALSE` in the function `computeCommunProb()` in order to use the projected data) # cellchat &lt;- projectData(cellchat, PPI.human) 14.2 细胞间通讯网络推断 CellChat 通过为每个相互作用分配一个概率值并进行置换检验，推断具有生物学意义的细胞间通讯。CellChat 运用质量作用定律，将基因表达与信号传导配体、受体及其辅因子之间相互作用的已知知识相结合，从而建立细胞间通讯的概率模型。 注意：推断的配体-受体对的数量明显依赖于计算每个细胞组平均基因表达的方法。默认情况下，CellChat 使用一种统计上稳健的均值方法，称为“trimean”，它产生的交互作用比其他方法少。然而，我们发现 CellChat 在预测更强的交互作用方面表现良好，这对于进一步的实验验证非常有帮助。在 computeCommunProb 中，我们提供了使用其他方法的选项，例如 5% 和 10% 截断均值，来计算平均基因表达。值得注意的是，“trimean”近似于 25% 截断均值，这意味着如果一个组中表达的细胞百分比少于 25%，则平均基因表达为零。要使用 10% 截断均值，用户可以设置 type = \"truncatedMean\" 和 trim = 0.1。为了确定合适的 trim 值，CellChat 提供了一个函数 computeAveExpr，它可以帮助检查感兴趣的信号基因的平均表达，例如，computeAveExpr(cellchat, features = c(\"CXCL12\",\"CXCR4\"), type = \"truncatedMean\", trim = 0.1)。因此，如果在研究的生物过程中没有预测到知名的信号通路，用户可以尝试使用较低的 trim 值的 truncatedMean 来改变每个细胞组平均基因表达的计算方法。 在分析未分类的单细胞转录组时，基于这样一种假设：丰富的细胞群体往往比稀有的细胞群体发送更强的集体信号，CellChat 也可以在概率计算中考虑每个细胞组中细胞比例的影响。用户可以设置 population.size = TRUE。 14.2.1 计算通讯概率并推断细胞通讯网络 该分析的关键参数是 type，即计算每个细胞组平均基因表达的方法。默认情况下，type = \"triMean\"，这会产生较少但更强的交互作用。当设置 type = \"truncatedMean\" 时，需要为 trim 赋值，这会产生更多的交互作用。 cellchat &lt;- computeCommunProb(cellchat, type = &quot;triMean&quot;) ## triMean is used for calculating the average gene expression per cell group. ## [1] &quot;&gt;&gt;&gt; Run CellChat on sc/snRNA-seq data &lt;&lt;&lt; [2025-04-12 18:41:15.969183]&quot; ## [1] &quot;&gt;&gt;&gt; CellChat inference is done. Parameter values are stored in `object@options$parameter` &lt;&lt;&lt; [2025-04-12 18:41:40.331192]&quot; 用户可以过滤掉那些在某些细胞群体中只有少量细胞的细胞间通讯。默认情况下，每个细胞群体中进行细胞间通讯所需的最小细胞数量是10个。 cellchat &lt;- filterCommunication(cellchat, min.cells = 10) 14.2.2 将推断出的细胞通讯网络提取为一个数据框。 我们提供了一个函数 subsetCommunication，以便轻松访问感兴趣的推断细胞间通讯。例如： df.net &lt;- subsetCommunication(cellchat) 返回一个数据框，其中包含配体/受体水平的所有推断细胞间通讯。设置 slot.name = \"netP\" 可以访问信号通路水平的推断通讯。 df.net &lt;- subsetCommunication(cellchat, sources.use = c(1,2), targets.use = c(4,5)) 提供从细胞群体 1 和 2 发送到细胞群体 4 和 5 的推断细胞间通讯。 df.net &lt;- subsetCommunication(cellchat, signaling = c(\"WNT\", \"TGFb\")) 提供由 WNT 和 TGFb 信号介导的推断细胞间通讯。 df.net &lt;- subsetCommunication(cellchat, slot.name = &quot;netP&quot;) 14.2.3 在信号通路级别推断细胞-细胞通讯 CellChat 通过总结与每个信号通路相关的所有配体-受体相互作用的通信概率，计算信号通路级别的通信概率。 注意：每个配体-受体对和每个信号通路的推断细胞间通信网络存储在“net”和“netP”槽中。 cellchat &lt;- computeCommunProbPathway(cellchat) 14.2.4 计算聚合的细胞-细胞通信网络 CellChat 通过计算链接数量或总结通信概率来计算聚合的细胞-细胞通信网络。用户还可以通过设置 sources.use 和 targets.use 来计算一组细胞群体之间的聚合网络。 cellchat &lt;- aggregateNet(cellchat) CellChat 还可以可视化聚合的细胞间通信网络。例如，使用圆形图显示任意两个细胞组之间的交互次数或总交互强度（权重）。 groupSize &lt;- as.numeric(table(cellchat@idents)) par(mfrow = c(1,2), xpd=TRUE) netVisual_circle(cellchat@net$count, vertex.weight = groupSize, weight.scale = T, label.edge= F, title.name = &quot;Number of interactions&quot;) netVisual_circle(cellchat@net$weight, vertex.weight = groupSize, weight.scale = T, label.edge= F, title.name = &quot;Interaction weights/strength&quot;) 由于复杂的细胞间通信网络，我们可以检查每个细胞组发送的信号。在这里，我们还控制参数 edge.weight.max ，以便比较不同网络之间的边权重。 mat &lt;- cellchat@net$weight par(mfrow = c(3,4), xpd=TRUE) for (i in 1:nrow(mat)) { mat2 &lt;- matrix(0, nrow = nrow(mat), ncol = ncol(mat), dimnames = dimnames(mat)) mat2[i, ] &lt;- mat[i, ] netVisual_circle(mat2, vertex.weight = groupSize, weight.scale = T, edge.weight.max = max(mat), title.name = rownames(mat)[i]) } 14.3 细胞间通信网络的可视化 在推断细胞间通信网络后，CellChat 提供了多种功能以便进一步的数据探索、分析和可视化。具体来说： - 它提供了几种可视化细胞间通信网络的方法，包括层次图、圆形图、和弦图和气泡图。 - 它提供了一个易于使用的工具，用于提取和可视化推断网络的高阶信息。例如，它可以方便地预测细胞群体的主要信号输入和输出，以及这些群体和信号如何协调以实现功能。 - 它可以通过结合社交网络分析、模式识别和流形学习方法，定量表征和比较推断的细胞间通信网络。 14.3.1 使用层次图、圆形图或和弦图可视化每个信号通路 层次图：应定义 vertex.receiver ，这是一个数值向量，给出层次图左侧作为目标的细胞组的索引。该层次图由两个部分组成：左侧部分显示对某些感兴趣的细胞组（即定义的 vertex.receiver ）的自分泌和旁分泌信号，而右侧部分显示对数据集中其余细胞组的自分泌和旁分泌信号。因此，层次图提供了一种信息丰富且直观的方式来可视化感兴趣的细胞组之间的自分泌和旁分泌信号通信。例如，在研究成纤维细胞与免疫细胞之间的细胞间通信时，用户可以将 vertex.receiver 定义为所有成纤维细胞组。 和弦图：CellChat 提供了两个函数 netVisual_chord_cell 和 netVisual_chord_gene 用于以不同的目的和不同的层次可视化细胞间通信。 netVisual_chord_cell 用于可视化不同细胞组之间的细胞间通信（和弦图中的每个扇区是一个细胞组）, netVisual_chord_gene 用于可视化由多个配体-受体或信号通路介导的细胞间通信（和弦图中的每个扇区是一个配体、受体或信号通路）。 边缘颜色/权重、节点颜色/大小/形状的解释：在所有可视化图中，边缘颜色与作为发送者的源一致，边缘权重与交互强度成正比。边缘线越粗，信号越强。在层次图和圆形图中，圆圈的大小与每个细胞组中的细胞数量成正比。在层次图中，实心圆和空心圆分别表示源和目标。在和弦图中，内侧较细的条形颜色表示接收来自相应外侧条形信号的目标。内侧条形的大小与目标接收到的信号强度成正比。这种内侧条形有助于解释复杂的和弦图。请注意，某些细胞组存在没有任何和弦的内侧条形，请忽略它，因为这是 circlize 包尚未解决的问题。 在不同层次上可视化细胞间通信：可以使用 netVisual_aggregate 可视化信号通路的推断通信网络，并使用 netVisual_individual 可视化与该信号通路相关的单个配对的推断通信网络。 在这里，我们以一个信号通路作为例子。所有显示显著通信的信号通路可以通过 cellchat@netP$pathways 访问。 14.3.1.1 层次图 pathways.show &lt;- c(&quot;MIF&quot;) # Hierarchy plot # Here we define `vertex.receive` so that the left portion of the hierarchy plot shows signaling to fibroblast and the right portion shows signaling to immune cells vertex.receiver = c(1,2,5) # a numeric vector. netVisual_aggregate(cellchat, signaling = pathways.show, vertex.receiver = vertex.receiver, layout = &quot;hierarchy&quot;) # Circle plot par(mfrow=c(1,1)) netVisual_aggregate(cellchat, signaling = pathways.show, layout = &quot;circle&quot;) 14.3.1.2 弦图 # Chord diagram par(mfrow=c(1,1)) netVisual_aggregate(cellchat, signaling = pathways.show, layout = &quot;chord&quot;) 对于弦图，CellChat 有一个独立的函数 netVisual_chord_cell ，可以通过调整 circlize 包中的不同参数灵活地可视化信号网络。例如，我们可以定义一个命名的字符向量 group 来创建多组和弦图，例如，将细胞簇分组为不同的细胞类型。 # Chord diagram group.cellType &lt;- c(rep(&quot;A&quot;, 4), rep(&quot;B&quot;, 4), rep(&quot;C&quot;, 4)) # grouping cell clusters into different cell types (example: A, B, C) names(group.cellType) &lt;- levels(cellchat@idents) netVisual_chord_cell(cellchat, signaling = pathways.show, group = group.cellType, title.name = paste0(pathways.show, &quot; signaling network&quot;)) 14.3.1.3 热图 # Heatmap par(mfrow=c(1,1)) netVisual_heatmap(cellchat, signaling = pathways.show, color.heatmap = &quot;Reds&quot;) 14.3.2 计算每个配体-受体对对整体信号通路的贡献，并可视化由单个配体-受体对介导的细胞间通信 netAnalysis_contribution(cellchat, signaling = pathways.show) 我们还可以可视化由单一配体-受体对介导的细胞间通信。我们提供一个函数 extractEnrichedLR 来提取给定信号通路的所有显著相互作用（L-R 对）和相关信号基因。 pairLR.CXCL &lt;- extractEnrichedLR(cellchat, signaling = pathways.show, geneLR.return = FALSE) LR.show &lt;- pairLR.CXCL[1:2,] # show one ligand-receptor pair # Hierarchy plot vertex.receiver = seq(1,4) # a numeric vector netVisual_individual(cellchat, signaling = pathways.show, pairLR.use = LR.show, vertex.receiver = vertex.receiver, layout = &quot;hierarchy&quot; ) # Circle plot netVisual_individual(cellchat, signaling = pathways.show, pairLR.use = LR.show, layout = &quot;circle&quot;) ## [[1]] ## ## [[2]] # Chord diagram netVisual_individual(cellchat, signaling = pathways.show, pairLR.use = LR.show, layout = &quot;chord&quot;) ## [[1]] ## ## [[2]] 14.3.2.1 自动保存所有推断网络的图以便快速浏览 在实际使用中，可以使用‘for … loop’自动保存所有推断的网络，以便使用 netVisual 进行快速探索。 netVisual 支持以 svg、png 和 pdf 格式输出。 # Access all the signaling pathways showing significant communications pathways.show.all &lt;- cellchat@netP$pathways # check the order of cell identity to set suitable vertex.receiver levels(cellchat@idents) vertex.receiver = seq(1,4) for (i in 1:length(pathways.show.all)) { # Visualize communication network associated with both signaling pathway and individual L-R pairs netVisual(cellchat, signaling = pathways.show.all[i], vertex.receiver = vertex.receiver, layout = &quot;hierarchy&quot;) # Compute and visualize the contribution of each ligand-receptor pair to the overall signaling pathway gg &lt;- netAnalysis_contribution(cellchat, signaling = pathways.show.all[i]) ggsave(filename=paste0(pathways.show.all[i], &quot;_L-R_contribution.pdf&quot;), plot=gg, width = 3, height = 2, units = &#39;in&#39;, dpi = 300) } 14.3.3 可视化由多个配体-受体或信号通路介导的细胞间通信 CellChat 还可以显示由 L-R 对和信号通路介导的所有显著相互作用，以及用户从某些细胞群体到其他细胞群体提供的相互作用， 使用功能 netVisual_bubble（选项 A）和 netVisual_chord_gene（选项 B）。 14.3.3.1 A：气泡图 我们还可以使用 netVisual_bubble 显示从某些细胞群体到其他细胞群体的所有显著相互作用（L-R 对）。 # (1) show all the significant interactions (L-R pairs) from some cell groups (defined by &#39;sources.use&#39;) to other cell groups (defined by &#39;targets.use&#39;) netVisual_bubble(cellchat, sources.use = 2, targets.use = c(5:9), remove.isolate = FALSE) # (2) show all the significant interactions (L-R pairs) associated with certain signaling pathways netVisual_bubble(cellchat, sources.use = 2, targets.use = c(5:9), signaling = c(&quot;MIF&quot;,&quot;GALECTIN&quot;), remove.isolate = FALSE) # (3) show all the significant interactions (L-R pairs) based on user&#39;s input (defined by `pairLR.use`) pairLR.use &lt;- extractEnrichedLR(cellchat, signaling = c(&quot;MIF&quot;,&quot;GALECTIN&quot;,&quot;ANNEXIN&quot;)) netVisual_bubble(cellchat, sources.use = c(3,4), targets.use = c(5:8), pairLR.use = pairLR.use, remove.isolate = TRUE) # set the order of interacting cell pairs on x-axis # (4) 默认情况下，细胞对是根据来源细胞在 `object@idents` 中的出现顺序进行排序的，如果来源相同，则根据目标细胞的出现顺序排序。 # (5) 根据用户定义的目标 (target) 进行排序 netVisual_bubble(cellchat, targets.use = c(&quot;MIF&quot;, &quot;GALECTIN&quot;, &quot;ANNEXIN&quot;, &quot;CD40&quot;, &quot;IL16&quot;), pairLR.use = pairLR.use, remove.isolate = TRUE, sort.by.target = T) # (6) 根据用户定义的来源 (source) 进行排序 netVisual_bubble(cellchat, sources.use = c(&quot;FBN1+ FIB&quot;,&quot;APOE+ FIB&quot;,&quot;Inflam. FIB&quot;), pairLR.use = pairLR.use, remove.isolate = TRUE, sort.by.source = T) # (7) 先根据来源再根据目标进行排序 netVisual_bubble(cellchat, sources.use = c(&quot;FBN1+ FIB&quot;,&quot;APOE+ FIB&quot;,&quot;Inflam. FIB&quot;), targets.use = c(&quot;LC&quot;,&quot;Inflam. DC&quot;,&quot;cDC2&quot;,&quot;CD40LG+ TC&quot;), pairLR.use = pairLR.use, remove.isolate = TRUE, sort.by.source = T, sort.by.target = T) # (8) 先根据目标再根据来源进行排序 netVisual_bubble(cellchat, sources.use = c(&quot;FBN1+ FIB&quot;,&quot;APOE+ FIB&quot;,&quot;Inflam. FIB&quot;), targets.use = c(&quot;LC&quot;,&quot;Inflam. DC&quot;,&quot;cDC2&quot;,&quot;CD40LG+ TC&quot;), pairLR.use = pairLR.use, remove.isolate = TRUE, sort.by.source = T, sort.by.target = T, sort.by.source.priority = FALSE) 14.3.3.2 B：和弦图 类似于气泡图，CellChat 提供了一个 netVisual_chord_gene 的功能来绘制弦图 显示某些细胞组到其他细胞组的所有相互作用（L-R 对或信号通路）。有两种特殊情况：一种是显示从一个细胞组发送的所有相互作用，另一种是显示一个细胞组接收的所有相互作用 。 显示用户输入的相互作用或用户定义的某些信号通路 # 显示从某些细胞群体（由 &#39;sources.use&#39; 定义）到其他细胞群体（由 &#39;targets.use&#39; 定义）的所有显著相互作用（配体-受体对）。 # 显示从 B 细胞发送的所有相互作用。 netVisual_chord_gene(cellchat, sources.use = 4, targets.use = c(1:9), lab.cex = 0.5, legend.pos.y = 30) # 显示树突状细胞（DC）接收到的所有相互作用。 netVisual_chord_gene(cellchat, sources.use = c(1,2,3,4,5,6), targets.use = 8, legend.pos.x = 15) # 显示与特定信号通路相关的所有显著相互作用（配体-受体对）。 netVisual_chord_gene(cellchat, sources.use = c(1,2,3,4), targets.use = c(5:9), signaling = c(&quot;MIF&quot;,&quot;GALECTIN&quot;),legend.pos.x = 8) # 显示从某些细胞群体（由 &#39;sources.use&#39; 定义）到其他细胞群体（由 &#39;targets.use&#39; 定义）的所有显著信号通路。 netVisual_chord_gene(cellchat, sources.use = c(1,2,3,4), targets.use = c(5:8), slot.name = &quot;netP&quot;, legend.pos.x = 10) 注意：生成图表时请忽略诸如“注意：第一个连接端绘制在‘MIF’扇区之外”的注释。若基因名称重叠，可通过减小参数 small.gap 的值进行调整。 14.3.4 使用小提琴图/点图绘制信号基因表达分布 若已安装 Seurat R 包，CellChat 可通过其封装函数 plotGeneExpression 绘制与配体-受体对或信号通路相关的信号基因表达分布图。 该函数提供三种可视化类型：“violin”（小提琴图）、“dot”（点图）、“bar”（条形图）。 用户亦可使用 extractEnrichedLR 提取推断出的配体-受体对或信号通路相关信号基因，再借助 Seurat 或其他软件包进行基因表达可视化。 plotGeneExpression(cellchat, signaling = &quot;CD40&quot;, enriched.only = TRUE, type = &quot;violin&quot;) 默认情况下， plotGeneExpression 仅显示与推断出的显著通讯相关的信号基因表达。用户可通过设置展示特定信号通路下所有相关信号基因的表达情况。 plotGeneExpression(cellchat, signaling = &quot;CD40&quot;, enriched.only = FALSE) 14.4 细胞间通信网络的系统分析 为便于解析复杂的细胞间通讯网络，CellChat 通过从图论 (graph theory)、模式识别 (pattern recognition) 和流形学习 (manifold learning) 的方法对网络进行量化分析。 它可以使用网络分析中的中心性度量来确定给定信号网络中的主要信号源和目标，以及介导者和影响者。 它可以通过利用模式识别方法预测特定细胞类型的关键进出信号以及不同细胞类型之间的协调反应。 它可以通过定义相似性度量并从功能和拓扑的角度进行流形学习来对信号通路进行分组。 它可以通过对多个网络的联合流形学习来描绘保守和特定上下文的信号通路。 14.4.1 确定细胞群体的信号角色（例如，主要发送者、接收者）以及主要贡献的信号 CellChat 通过计算每个细胞组的多个网络中心性度量，允许快速识别细胞间通信网络中的主导发送者、接收者、中介和影响者。具体而言，我们使用加权有向网络中的度量，包括出度、入度、流动介数和信息中心性，分别识别细胞间通信的主导发送者、接收者、中介和影响者。在一个加权有向网络中，权重为计算得出的通信概率，出度计算为细胞组发出的信号的通信概率之和，入度计算为细胞组接收的信号的通信概率之和，可以分别用于识别信号网络的主导细胞发送者和接收者。 14.4.1.1 （A）计算并可视化网络中心性分数 # 计算网络中心性得分 cellchat &lt;- netAnalysis_computeCentrality(cellchat, slot.name = &quot;netP&quot;) # 插槽 &#39;netP&#39; 指的是推断的细胞间信号通路通信网络 # 使用热图可视化计算出的中心性得分，便于识别细胞群体的主要信号作用 netAnalysis_signalingRole_network(cellchat, signaling = pathways.show, width = 8, height = 2.5, font.size = 10) 14.4.1.2 （B）在 2D 空间中可视化主要发送者（来源）和接收者（目标） CellChat 还提供了一种直观的方式，通过散点图在 2D 空间中可视化主要发送者（来源）和接收者（目标）。x 轴和 y 轴分别是与每个细胞群体相关的总外向或内向通信概率。点的大小与每个细胞群体相关的推断链接数量（包括外向和内向）成正比。点的颜色表示不同的细胞群体。如果定义了 group ，点的形状表示不同类别的细胞群体。 # 对所有信号通路的聚合细胞间通信网络进行信号作用分析 gg1 &lt;- netAnalysis_signalingRole_scatter(cellchat) # 对感兴趣的细胞间通信网络的信号作用分析 gg2 &lt;- netAnalysis_signalingRole_scatter(cellchat, signaling = c(&quot;MIF&quot;,&quot;GALECTIN&quot;)) gg1 + gg2 14.4.1.3 （C）识别对特定细胞群输出或输入信号贡献最大的信号 我们还能解答哪些信号对特定细胞群的输出或输入信号贡献最大的问题。在此热图中，颜色条代表信号通路在不同细胞群间的相对信号强度（注：数值经过行标准化）。顶部彩色条形图通过汇总热图中所有信号通路来展示细胞群的总信号强度。右侧灰色条形图则通过汇总所有显示的细胞群来展示信号通路的总信号强度。 # 从所有信号通路对细胞-细胞通讯网络的聚集信号作用进行分析 ht1 &lt;- netAnalysis_signalingRole_heatmap(cellchat, pattern = &quot;outgoing&quot;) ht2 &lt;- netAnalysis_signalingRole_heatmap(cellchat, pattern = &quot;incoming&quot;) ht1 + ht2 14.4.2 识别全局通讯模式，探索多种细胞类型与信号通路如何协同作用 除了探究单个通路的详细通讯情况外，一个重要问题是多个细胞群与信号通路如何协调运作。CellChat 采用模式识别方法来识别全局通讯模式。 随着模式数量的增加，可能会出现冗余模式，从而难以解释通信模式。我们默认选择五种模式。通常情况下，模式数量大于 2 时具有生物学意义。此外，我们还提供了一个函数 selectK 来推断模式数量，该函数基于 NMF R 包中已实现的两个指标，包括 Cophenetic 和 Silhouette。这两个指标基于共识矩阵的层次聚类来衡量特定数量模式的稳定性。对于一定范围内的模式数量，合适的模式数量是 Cophenetic 和 Silhouette 值突然开始下降时的数值。 该分析可针对传出（选项 A）和传入（选项 B）信号模式进行。传出模式揭示了发送细胞（即作为信号源的细胞）如何相互协调，以及它们如何与特定信号通路协同驱动通讯。传入模式则展示了目标细胞（即作为信号接收者的细胞）如何相互协调，以及它们如何与特定信号通路协同响应传入信号。 14.4.2.1 （A）识别并可视化分泌细胞的传出通讯模式 传出模式揭示了发送细胞（即作为信号源的细胞）如何相互协调，以及它们如何与特定信号通路协同驱动通讯。 对于输出（或输入）模式，通过矩阵分解输出的细胞群模式矩阵 W 展示了这些细胞群如何协同发送（或接收）信号，而信号通路模式矩阵 H 则揭示了这些信号通路如何共同作用以发送（或接收）信号。为了直观展示潜在模式与细胞群、配体-受体对或信号通路之间的关联，我们采用了河流（冲积）图。首先，我们将 W 的每一行和 H 的每一列归一化至[0,1]范围，随后将 W 和 H 中小于阈值（默认值为 0.5）的元素设为零。这种阈值处理有助于揭示与每个推断模式相关的最富集细胞群和信号通路。经过阈值处理的矩阵 W 和 H 将作为创建冲积图的输入数据。 此外，为了直接将细胞群与其富集的信号通路关联起来，我们设定矩阵 W 和 H 中的元素若小于阈值（默认值为 1/R，其中 R 为潜在模式数量）则置零。通过采用较宽松的阈值，可能获得更多与各细胞群相关的富集信号通路。利用通过 W 乘以 H 计算得到的各细胞群对每条信号通路的贡献分数，我们构建了点阵图——图中点的大小与贡献分数成正比，用以展示细胞群与其富集信号通路之间的关联。用户还可调低参数 cutoff 以显示更多与各细胞群相关的富集信号通路。 selectK(cellchat, pattern = &quot;outgoing&quot;) 当外向通信模式数量为 2 时，同构系数和轮廓系数均开始骤降。 nPatterns = 2 cellchat &lt;- identifyCommunicationPatterns(cellchat, pattern = &quot;outgoing&quot;, k = nPatterns) # river plot netAnalysis_river(cellchat, pattern = &quot;outgoing&quot;) # dot plot netAnalysis_dot(cellchat, pattern = &quot;outgoing&quot;) 14.4.2.2 (B) 识别并可视化目标细胞的传入通信模式 传入模式展示了靶细胞（即作为信号接收者的细胞）如何相互协调，以及它们如何与特定信号通路协调以响应传入信号。 selectK(cellchat, pattern = &quot;incoming&quot;) 当传入模式数量为 3 时，共表型值开始下降。 nPatterns = 3 cellchat &lt;- identifyCommunicationPatterns(cellchat, pattern = &quot;incoming&quot;, k = nPatterns) # river plot netAnalysis_river(cellchat, pattern = &quot;incoming&quot;) # dot plot netAnalysis_dot(cellchat, pattern = &quot;incoming&quot;) 14.4.3 信号网络的流形与分类学习分析 此外，CellChat 能够量化所有重要信号通路之间的相似性，并根据它们的细胞通讯网络相似性进行分组。分组可以基于功能相似性或结构相似性来完成。 功能相似性：高度的功能相似性表明主要的发送者和接收者相似，可以解释为这两种信号通路或两种配体-受体对表现出相似和/或冗余的作用。功能相似性分析要求两个数据集之间具有相同的细胞群体组成。 结构相似性：采用结构相似性来比较它们的信号网络结构，不考虑发送者和接收者的相似性。 14.4.3.1 基于功能相似性识别信号组 cellchat &lt;- computeNetSimilarity(cellchat, type = &quot;functional&quot;) cellchat &lt;- netEmbedding(cellchat, type = &quot;functional&quot;) cellchat &lt;- netClustering(cellchat, type = &quot;functional&quot;) netVisual_embedding(cellchat, type = &quot;functional&quot;, label.size = 3.5) netVisual_embeddingZoomIn(cellchat, type = &quot;functional&quot;, nCol = 2) 14.4.3.2 基于结构相似性识别信号组 cellchat &lt;- computeNetSimilarity(cellchat, type = &quot;structural&quot;) cellchat &lt;- netEmbedding(cellchat, type = &quot;structural&quot;) cellchat &lt;- netClustering(cellchat, type = &quot;structural&quot;) netVisual_embedding(cellchat, type = &quot;structural&quot;, label.size = 3.5) netVisual_embeddingZoomIn(cellchat, type = &quot;structural&quot;, nCol = 2) 14.5 保存 cellchaat 对象 saveRDS(cellchat, file = &quot;cellchat_humanSkin_LS.rds&quot;) 14.6 通过交互式 CellChat 探索器探索细胞间通讯 进行单细胞转录组 CellChat 分析时，请确保 object@dr 包含数据的低维空间（如“umap”和“tsne”），以便生成信号基因的特征图。可通过 addReduction 函数添加新的降维空间。 runCellChatApp(cellchat) "],["cellchat-多数据集对比分析.html", "第 15 章 cellchat 多数据集对比分析 15.1 加载各数据集的 CellChat 对象并合并 15.2 识别改变的互作与细胞群体 15.3 识别具有不同网络架构及相互作用强度的信号变化 15.4 识别上调和下调的信号配体-受体对 15.5 使用层次图、圆形图或和弦图可视化比较细胞间通信 15.6 比较不同数据集之间信号基因表达分布 15.7 保存合并的 CellChat 对象", " 第 15 章 cellchat 多数据集对比分析 本教程展示如何运用 CellChat 通过定量对比和联合流形学习，识别不同生物学条件下的主要信号变化。我们以特应性皮炎患者的非皮损（NL，正常）和皮损（LS，病变）人皮肤单细胞 RNA 测序数据集为例，演示 CellChat 在跨条件识别主要信号变化时的多样化功能。这两个数据集（条件）在联合聚类后具有相同的细胞群组成。 CellChat 采用自上而下的方法，即从宏观视角出发，逐步细化至信号传导机制的细节层面，以识别不同层次上的信号变化，包括交互作用、细胞群体、信号通路及配体-受体对的改变。 library(CellChat) library(patchwork) 15.1 加载各数据集的 CellChat 对象并合并 需先对每个数据集单独运行 CellChat，随后合并不同的 CellChat 对象。若 CellChat 对象是通过早期版本（&lt;1.6.0）获取的，请执行 updateCellChat 操作。 cellchat.NL &lt;- readRDS(&quot;data/Cellchat-2/cellchat_humanSkin_NL.rds&quot;) cellchat.LS &lt;- readRDS(&quot;data/Cellchat-2/cellchat_humanSkin_LS.rds&quot;) object.list &lt;- list(NL = cellchat.NL, LS = cellchat.LS) cellchat &lt;- mergeCellChat(object.list, add.names = names(object.list)) 15.2 识别改变的互作与细胞群体 CellChat 采用自上而下的方法，即从宏观视角出发，逐步细化信号传导机制，以识别不同层面的信号变化，包括改变的相互作用、细胞群体、信号通路和配体-受体对。首先，CellChat 从宏观角度出发，回答以下问题： 细胞与细胞之间的交流是否得到加强 哪些细胞类型之间的相互作用发生了显著变化 主要来源和目标如何从一个条件变化到另一个条件 15.2.1 比较相互作用的总数量及相互作用强度 为了解答细胞间通讯是否增强的问题，CellChat 会比较不同生物学条件下推断出的细胞间通讯网络中相互作用的总数量及相互作用强度。 gg1 &lt;- compareInteractions(cellchat, show.legend = F, group = c(1,2)) gg2 &lt;- compareInteractions(cellchat, show.legend = F, group = c(1,2), measure = &quot;weight&quot;) gg1 + gg2 15.2.2 比较不同细胞群体间的相互作用数量及相互作用强度 为了识别哪些细胞群体之间的相互作用显示出显著变化，CellChat 通过以下方式比较不同细胞群体间的相互作用数量和强度：使用差异相互作用的环形图（选项 A）、差异相互作用的热图（选项 B）以及展示每个数据集中相互作用数量或强度的双环形图（选项 C）。此外，用户还可以通过基于定义的细胞群汇总细胞间通讯，来检查粗略细胞类型之间相互作用数量或强度的差异（选项 D）。 15.2.2.1 (A) 圆形图展示两个数据集中不同细胞群体间相互作用数量或强度的差异 两个数据集间细胞-细胞通讯网络中相互作用数量或强度的差异可通过圆形图可视化，其中 red （或 blue）色边代表相较于第一个数据集，第二个数据集中的 increased（或 decreased）信号传导。 # par(mfrow = c(1,2), xpd=TRUE) # netVisual_diffInteraction(cellchat, weight.scale = T, measure = &quot;count&quot;) # 报错 netVisual_diffInteraction(cellchat, weight.scale = T, measure = &quot;weight&quot;) 15.2.2.2 (B) 热图展示两个数据集中不同细胞群之间相互作用数量或强度的差异 CellChat 还可以通过热图更详细地展示交互数量或交互强度的差异。顶部彩色条形图表示热图中显示的绝对值每列的总和（传入信号）。右侧彩色条形图表示绝对值每行的总和（传出信号）。因此，条形高度表示两种条件下交互数量或交互强度的变化程度。在颜色条中， red（或 blue）表示与第一个数据集相比，第二个数据集中的 increased（或 decreased）信号。 gg1 &lt;- netVisual_heatmap(cellchat) gg2 &lt;- netVisual_heatmap(cellchat, measure = &quot;weight&quot;) gg1 + gg2 15.2.2.3 (C) 圆形图展示多个数据集中不同细胞群之间的相互作用数量或相互作用强度 上述差异网络分析仅适用于两两数据集间的比较。若有更多数据集需要对比，CellChat 可直接展示各数据集中任意两个细胞群之间的相互作用数量或相互作用强度。 为了更好地控制不同数据集中推断网络的节点大小和边权重，CellChat 会计算所有数据集中每个细胞组的最大细胞数量以及最大相互作用数量（或相互作用权重）。 weight.max &lt;- getMaxWeight(object.list, attribute = c(&quot;idents&quot;,&quot;count&quot;)) par(mfrow = c(1,2), xpd=TRUE) for (i in 1:length(object.list)) { netVisual_circle(object.list[[i]]@net$count, weight.scale = T, label.edge= F, edge.weight.max = weight.max[2], edge.width.max = 12, title.name = paste0(&quot;Number of interactions - &quot;, names(object.list)[i])) } 15.2.2.4 (D) 展示粗略细胞类型间相互作用数量或相互作用强度差异的圆形图 为简化复杂网络并获取细胞类型水平上细胞间通讯的深入理解，CellChat 基于定义的细胞群对细胞间通讯进行聚合。此处我们将细胞群体划分为三种细胞类型，随后重新合并 CellChat 对象列表。 group.cellType &lt;- c(rep(&quot;FIB&quot;, 4), rep(&quot;DC&quot;, 4), rep(&quot;TC&quot;, 4)) group.cellType &lt;- factor(group.cellType, levels = c(&quot;FIB&quot;, &quot;DC&quot;, &quot;TC&quot;)) object.list &lt;- lapply(object.list, function(x) {mergeInteractions(x, group.cellType)}) cellchat &lt;- mergeCellChat(object.list, add.names = names(object.list)) 随后我们可展示各数据集中任意两种细胞类型间的相互作用数量或相互作用强度。 weight.max &lt;- getMaxWeight(object.list, slot.name = c(&quot;idents&quot;, &quot;net&quot;, &quot;net&quot;), attribute = c(&quot;idents&quot;,&quot;count&quot;, &quot;count.merged&quot;)) par(mfrow = c(1,2), xpd=TRUE) for (i in 1:length(object.list)) { netVisual_circle(object.list[[i]]@net$count.merged, weight.scale = T, label.edge= T, edge.weight.max = weight.max[3], edge.width.max = 12, title.name = paste0(&quot;Number of interactions - &quot;, names(object.list)[i])) } 类似地，CellChat 还能通过圆形图展示任意两种细胞类型间相互作用数量或强度的差异。红色（或蓝色）边表示与第一个数据集相比，第二个数据集中信号传导的增加（或减少）。 par(mfrow = c(1,2), xpd=TRUE) netVisual_diffInteraction(cellchat, weight.scale = T, measure = &quot;count.merged&quot;, label.edge = T) netVisual_diffInteraction(cellchat, weight.scale = T, measure = &quot;weight.merged&quot;, label.edge = T) 15.2.3 在二维空间中比较主要来源和目标 在二维空间中比较传出与传入的相互作用强度，可轻松识别不同数据集间信号发送或接收发生显著变化的细胞群体。 通过选项 A 识别不同数据集间信号发送或接收发生显著变化的细胞群体，通过选项 B 追踪特定细胞群体的信号变化。 15.2.3.1 (A) 识别信号发送或接收发生显著变化的细胞群体 num.link &lt;- sapply(object.list, function(x) {rowSums(x@net$count) + colSums(x@net$count)-diag(x@net$count)}) weight.MinMax &lt;- c(min(num.link), max(num.link)) # control the dot size in the different datasets gg &lt;- list() for (i in 1:length(object.list)) { gg[[i]] &lt;- netAnalysis_signalingRole_scatter(object.list[[i]], title = names(object.list)[i], weight.MinMax = weight.MinMax) } patchwork::wrap_plots(plots = gg) 从散点图可见，与 NL 相比，Inflam.DC 和 cDC1 成为 LS 中主要信号源及靶标之一。成纤维细胞群体亦成为 LS 中的主要信号源。 15.2.3.2 (B) 识别特定细胞群体的信号变化 此外，我们还能识别出 NL 与 LS 之间 Inflam.DC 和 cDC1 细胞的特异性信号变化。 gg1 &lt;- netAnalysis_signalingChanges_scatter(cellchat, idents.use = &quot;Inflam. DC&quot;, signaling.exclude = &quot;MIF&quot;) gg2 &lt;- netAnalysis_signalingChanges_scatter(cellchat, idents.use = &quot;cDC1&quot;, signaling.exclude = c(&quot;MIF&quot;)) patchwork::wrap_plots(plots = list(gg1,gg2)) 15.3 识别具有不同网络架构及相互作用强度的信号变化 CellChat 随后可识别网络差异较大（或较小）的信号通路，并根据其在多种生物学条件下的功能或结构相似性对信号组进行分类。 15.3.1 识别差异较大（或较小）的信号网络，并基于其功能/结构相似性划分信号组 CellChat 基于不同条件下推断出的通信网络的功能及拓扑相似性，执行联合流形学习与分类。注：此类分析适用于两个以上的数据集。 通过量化不同条件下细胞通讯网络中信号通路的相似性，该分析揭示了可能发生改变的信号通路。CellChat 借鉴了网络生物学中的网络重构概念，并假设不同通讯网络间的差异可能会影响跨条件的生物学过程。UMAP 用于可视化信号关系，并以直观方式解释信号输出结果，无需涉及条件分类。 功能相似性：高度的功能相似性表明主要发送者和接收者相似，可解释为两个信号通路或两个配体-受体对具有相似和/或冗余的作用。注意：功能相似性分析不适用于具有不同细胞类型组成的多重数据集。 结构相似性：采用结构相似性比较其信号网络结构，未考虑发送者与接收者的相似性。注：结构相似性分析适用于具有相同细胞类型组成或细胞类型组成差异极大的多个数据集。 由于这两个数据集具有相同的细胞类型组成，我们可以基于功能相似性进行流形学习和分类分析。 15.3.1.1 基于功能相似性识别信号组 cellchat &lt;- computeNetSimilarityPairwise(cellchat, type = &quot;functional&quot;) cellchat &lt;- netEmbedding(cellchat, type = &quot;functional&quot;) cellchat &lt;- netClustering(cellchat, type = &quot;functional&quot;) netVisual_embeddingPairwise(cellchat, type = &quot;functional&quot;, label.size = 3.5) netVisual_embeddingZoomIn(cellchat, type = &quot;functional&quot;, nCol = 2) 15.3.1.2 基于结构相似性识别信号组 cellchat &lt;- computeNetSimilarityPairwise(cellchat, type = &quot;structural&quot;) cellchat &lt;- netEmbedding(cellchat, type = &quot;structural&quot;) cellchat &lt;- netClustering(cellchat, type = &quot;structural&quot;) netVisual_embeddingPairwise(cellchat, type = &quot;structural&quot;, label.size = 3.5) netVisual_embeddingPairwiseZoomIn(cellchat, type = &quot;structural&quot;, nCol = 2) 15.3.1.3 计算并可视化学习到的联合流形中的通路距离 计算并可视化学习到的联合流形中的通路距离 CellChat 可以根据共享的二维空间中它们的欧几里得距离识别出信号网络的较大（或较小）差异。较大的距离意味着在功能或结构相似性方面，两个数据集之间的通信网络差异较大。需要注意的是，我们仅计算两个数据集之间重叠信号通路的距离。那些仅在一个数据集中识别出的信号通路在此不予考虑。如果有超过三个数据集，可以通过修改函数 rankSimilarity 中的参数 comparison 进行成对比较。 rankSimilarity(cellchat, type = &quot;functional&quot;) 15.3.2 识别具有不同交互强度的改变信号 通过比较每个信号通路的信息流/交互强度，CellChat 识别出以下信号通路：(i) 关闭，(ii) 减少，(iii) 打开，或 (iv) 增加，通过在一个条件下与另一个条件相比改变其信息流。根据整体信息流通过选项 A 识别改变的信号通路或配体-受体对，并根据外发（或内收）信号模式通过选项 B 进行识别。 15.3.2.1 (A) 比较每个信号通路或配体-受体对的整体信息流 CellChat 可以通过简单地比较每个信号通路的信息流来识别保守和特定上下文的信号通路，这由推断网络中所有细胞组对之间的通信概率之和定义（即网络中的总权重）。 该条形图可以以堆叠模式绘制或不绘制。根据 NL 和 LS 皮肤之间推断网络中整体信息流的差异，对显著的信号通路进行了排名。当设置 do.stat = TRUE 时，进行配对 Wilcoxon 检验以确定两种条件之间的信号信息流是否存在显著差异。红色标记的顶级信号通路在 NL 皮肤中富集，而绿色标记的则在 LS 皮肤中富集。 gg1 &lt;- rankNet(cellchat, mode = &quot;comparison&quot;, measure = &quot;weight&quot;, sources.use = NULL, targets.use = NULL, stacked = T, do.stat = TRUE) gg2 &lt;- rankNet(cellchat, mode = &quot;comparison&quot;, measure = &quot;weight&quot;, sources.use = NULL, targets.use = NULL, stacked = F, do.stat = TRUE) gg1 + gg2 15.3.2.2 (B) 比较与每个细胞群体相关的外向（或内向）信号模式 上述分析总结了外向和内向信号的信息。CellChat 还可以比较两个数据集之间的外向（或内向）信号模式，从而识别表现出不同信号模式的信号通路/配体-受体。我们可以将来自不同数据集的所有识别信号通路结合在一起，从而并排比较它们，包括外向信号、内向信号和通过将外向和内向信号聚合在一起得到的整体信号。 CellChat 使用热图绘制信号（信号通路或配体-受体对）对细胞群体的贡献，显示出外发或接收信号。在此热图中，颜色条表示信号通路在细胞群体中的相对信号强度（注意值是行缩放的）。顶部的彩色条形图通过汇总热图中显示的所有信号通路，显示细胞群体的总信号强度。右侧的灰色条形图通过汇总热图中显示的所有细胞群体，显示信号通路的总信号强度。 library(ComplexHeatmap) pathway.union &lt;- union(object.list[[i]]@netP$pathways, object.list[[i+1]]@netP$pathways) ht1 = netAnalysis_signalingRole_heatmap(object.list[[i]], pattern = &quot;outgoing&quot;, signaling = pathway.union, title = names(object.list)[i], width = 5, height = 6) ht2 = netAnalysis_signalingRole_heatmap(object.list[[i+1]], pattern = &quot;outgoing&quot;, signaling = pathway.union, title = names(object.list)[i+1], width = 5, height = 6) draw(ht1 + ht2, ht_gap = unit(0.5, &quot;cm&quot;)) ht1 = netAnalysis_signalingRole_heatmap(object.list[[i]], pattern = &quot;incoming&quot;, signaling = pathway.union, title = names(object.list)[i], width = 5, height = 6, color.heatmap = &quot;GnBu&quot;) ht2 = netAnalysis_signalingRole_heatmap(object.list[[i+1]], pattern = &quot;incoming&quot;, signaling = pathway.union, title = names(object.list)[i+1], width = 5, height = 6, color.heatmap = &quot;GnBu&quot;) draw(ht1 + ht2, ht_gap = unit(0.5, &quot;cm&quot;)) ht1 = netAnalysis_signalingRole_heatmap(object.list[[i]], pattern = &quot;all&quot;, signaling = pathway.union, title = names(object.list)[i], width = 5, height = 6, color.heatmap = &quot;OrRd&quot;) ht2 = netAnalysis_signalingRole_heatmap(object.list[[i+1]], pattern = &quot;all&quot;, signaling = pathway.union, title = names(object.list)[i+1], width = 5, height = 6, color.heatmap = &quot;OrRd&quot;) draw(ht1 + ht2, ht_gap = unit(0.5, &quot;cm&quot;)) 15.4 识别上调和下调的信号配体-受体对 15.4.1 通过比较通信概率来识别功能失调的信号传导 CellChat 可以比较某些细胞群体与其他细胞群体之间由 L-R 对介导的通信概率。这可以通过在函数 netVisual_bubble 中设置 comparison 来完成。 netVisual_bubble(cellchat, sources.use = 4, targets.use = c(5:11), comparison = c(1, 2), angle.x = 45) 此外，CellChat 可以识别在一个数据集中上调（增加）和下调（减少）的信号配体-受体对，与另一个数据集进行比较。这可以通过在函数netVisual_bubble 中指定 max.dataset 和 min.dataset 来完成。增加的信号意味着这些信号在第二个数据集中相较于第一个数据集具有更高的通信概率（强度）。气泡图中显示的配体-受体对可以通过 gg1$data 访问。 gg1 &lt;- netVisual_bubble(cellchat, sources.use = 4, targets.use = c(5:11), comparison = c(1, 2), max.dataset = 2, title.name = &quot;Increased signaling in LS&quot;, angle.x = 45, remove.isolate = T) gg2 &lt;- netVisual_bubble(cellchat, sources.use = 4, targets.use = c(5:11), comparison = c(1, 2), max.dataset = 1, title.name = &quot;Decreased signaling in LS&quot;, angle.x = 45, remove.isolate = T) gg1 + gg2 15.4.2 通过使用差异表达分析识别功能失调的信号传导 上述识别上调和下调信号传导的方法是通过比较两个数据集之间每对 L-R 配对和每对细胞组的通信概率来进行的。或者，我们可以基于差异表达分析（DEA）识别上调和下调的信号配体-受体对。具体而言，我们在每个细胞组之间对两种生物条件（即 NL 和 LS）进行差异表达分析，然后根据发送细胞中配体和接收细胞中受体的倍数变化获得上调和下调的信号。 值得注意的是，用户可能会观察到相同的 LR 对出现在上调和下调的结果中，因为在每个细胞组中进行条件之间的 DEA。要在忽略细胞组信息的情况下进行条件之间的 DEA，用户可以在 CellChat v2.1.1 中将 identifyOverExpressedGenes 设置为 group.DE.combined = TRUE 。 # 定义一个正数据集，即相对于另一个数据集具有正倍数变化的数据集 pos.dataset = &quot;LS&quot; # 定义一个字符名称，用于存储差异表达分析的结果 features.name = paste0(pos.dataset, &quot;.merged&quot;) # 执行差异表达分析 # 值得注意的是，与 CellChat 版本 &lt; v2 相比，CellChat v2 现在使用 presto 包执行超快速的 Wilcoxon 检验，这会产生更小的 logFC 值。因此，我们在这里设置了一个比原始值更小的 thresh.fc 值（thresh.fc = 0.1）。用户还可以通过修改 cellchat@var.features$LS.merged 和 cellchat@var.features$LS.merged.info 来提供自定义 DEG 的向量和数据框。 cellchat &lt;- identifyOverExpressedGenes(cellchat, group.dataset = &quot;datasets&quot;, pos.dataset = pos.dataset, features.name = features.name, only.pos = FALSE, thresh.pc = 0.1, thresh.fc = 0.05,thresh.p = 0.05, group.DE.combined = FALSE) # 将差异表达分析的结果映射到推断的细胞间通讯上，以便轻松管理/筛选感兴趣的配体-受体对 net &lt;- netMappingDEG(cellchat, features.name = features.name, variable.all = TRUE) # 提取在 LS 中配体上调的配体-受体对 net.up &lt;- subsetCommunication(cellchat, net = net, datasets = &quot;LS&quot;,ligand.logFC = 0.05, receptor.logFC = NULL) # 提取在 LS 中配体下调的配体-受体对 net.down &lt;- subsetCommunication(cellchat, net = net, datasets = &quot;NL&quot;,ligand.logFC = -0.05, receptor.logFC = NULL) 由于 net.up 和 net.down 中的信号基因可能是由多个亚单位组成的复杂结构，我们可以进一步进行解卷积以获得单个信号基因。 gene.up &lt;- extractGeneSubsetFromPair(net.up, cellchat) gene.down &lt;- extractGeneSubsetFromPair(net.down, cellchat) 用户还可以根据自定义特征和感兴趣的小区组找到所有重要的外发/入站/双向信号 df &lt;- findEnrichedSignaling(object.list[[2]], features = c(&quot;CCL19&quot;, &quot;CXCL12&quot;), idents = c(&quot;Inflam. FIB&quot;, &quot;COL11A1+ FIB&quot;), pattern =&quot;outgoing&quot;) 15.4.3 可视化识别出的上调和下调的信号配体-受体对 CellChat 可以使用气泡图（选项 A）、和弦图（选项 B）或词云（选项 C）可视化识别出的上调和下调的信号配体-受体对。 15.4.3.1 (A) 气泡图 我们使用气泡图或和弦图可视化上调和下调的信号配体-受体对。 pairLR.use.up = net.up[, &quot;interaction_name&quot;, drop = F] gg1 &lt;- netVisual_bubble(cellchat, pairLR.use = pairLR.use.up, sources.use = 4, targets.use = c(5:11), comparison = c(1, 2), angle.x = 90, remove.isolate = T,title.name = paste0(&quot;Up-regulated signaling in &quot;, names(object.list)[2])) pairLR.use.down = net.down[, &quot;interaction_name&quot;, drop = F] gg2 &lt;- netVisual_bubble(cellchat, pairLR.use = pairLR.use.down, sources.use = 4, targets.use = c(5:11), comparison = c(1, 2), angle.x = 90, remove.isolate = T,title.name = paste0(&quot;Down-regulated signaling in &quot;, names(object.list)[2])) gg1 + gg2 15.4.3.2 (B) 和弦图 使用 Chord 图可视化上调和下调的信号配体-受体对 # Chord diagram par(mfrow = c(1,2), xpd=TRUE) netVisual_chord_gene(object.list[[2]], sources.use = 4, targets.use = c(5:11), slot.name = &#39;net&#39;, net = net.up, lab.cex = 0.8, small.gap = 3.5, title.name = paste0(&quot;Up-regulated signaling in &quot;, names(object.list)[2])) netVisual_chord_gene(object.list[[1]], sources.use = 4, targets.use = c(5:11), slot.name = &#39;net&#39;, net = net.down, lab.cex = 0.8, small.gap = 3.5, title.name = paste0(&quot;Down-regulated signaling in &quot;, names(object.list)[2])) 15.4.3.3 (C) 词云图 使用词云可视化在一种条件下与另一种条件相比的富集配体、信号或配体-受体对 # visualize the enriched ligands in the first condition computeEnrichmentScore(net.down, species = &#39;human&#39;, variable.both = TRUE) # visualize the enriched ligands in the second condition computeEnrichmentScore(net.up, species = &#39;human&#39;, variable.both = TRUE) 15.5 使用层次图、圆形图或和弦图可视化比较细胞间通信 类似于对单个数据集的 CellChat 分析，CellChat 可以使用层次图、圆形图、和弦图或热图直观地比较细胞间通信网络。有关可视化的更多细节可以在单个数据集的 CellChat 分析中找到。 边缘颜色/权重，节点颜色/大小/形状：在所有可视化图中，边缘颜色与作为发送者的源一致，边缘权重与交互强度成正比。边缘线越粗表示信号越强。在层次图和圆形图中，圆的大小与每个细胞组中的细胞数量成正比。在层次图中，实心圆和空心圆分别表示源和目标。在和弦图中，内侧较细的条形颜色表示接收来自相应外侧条形信号的目标。内侧条形的大小与目标接收到的信号强度成正比。这种内侧条形有助于解释复杂的和弦图。请注意，某些细胞组存在没有和弦的内侧条形，请忽略它，因为这是 circlize 包尚未解决的问题。 pathways.show &lt;- c(&quot;CXCL&quot;) weight.max &lt;- getMaxWeight(object.list, slot.name = c(&quot;netP&quot;), attribute = pathways.show) # control the edge weights across different datasets par(mfrow = c(1,2), xpd=TRUE) for (i in 1:length(object.list)) { netVisual_aggregate(object.list[[i]], signaling = pathways.show, layout = &quot;circle&quot;, edge.weight.max = weight.max[1], edge.width.max = 10, signaling.name = paste(pathways.show, names(object.list)[i])) } pathways.show &lt;- c(&quot;CXCL&quot;) par(mfrow = c(1,2), xpd=TRUE) ht &lt;- list() for (i in 1:length(object.list)) { ht[[i]] &lt;- netVisual_heatmap(object.list[[i]], signaling = pathways.show, color.heatmap = &quot;Reds&quot;,title.name = paste(pathways.show, &quot;signaling &quot;,names(object.list)[i])) } ComplexHeatmap::draw(ht[[1]] + ht[[2]], ht_gap = unit(0.5, &quot;cm&quot;)) # Chord diagram pathways.show &lt;- c(&quot;CXCL&quot;) par(mfrow = c(1,2), xpd=TRUE) for (i in 1:length(object.list)) { netVisual_aggregate(object.list[[i]], signaling = pathways.show, layout = &quot;chord&quot;, signaling.name = paste(pathways.show, names(object.list)[i])) } 对于和弦图，CellChat 具有独立的功能 netVisual_chord_cell ，可以通过调整 circlize 包中的不同参数灵活地可视化信号网络。例如，我们可以定义一个命名的字符向量 group 来创建多组和弦图，例如，将细胞簇分组为不同的细胞类型。 # Chord diagram group.cellType &lt;- c(rep(&quot;FIB&quot;, 4), rep(&quot;DC&quot;, 4), rep(&quot;TC&quot;, 4)) # grouping cell clusters into fibroblast, DC and TC cells names(group.cellType) &lt;- levels(object.list[[1]]@idents) pathways.show &lt;- c(&quot;CXCL&quot;) par(mfrow = c(1,2), xpd=TRUE) for (i in 1:length(object.list)) { netVisual_chord_cell(object.list[[i]], signaling = pathways.show, group = group.cellType, title.name = paste0(pathways.show, &quot; signaling network - &quot;, names(object.list)[i])) } 使用和弦图，CellChat 提供了两个功能 netVisual_chord_cell 和 netVisual_chord_gene 用于以不同目的和不同层次可视化细胞间通信。 netVisual_chord_cell 用于可视化不同细胞组之间的细胞间通信（和弦图中的每个扇区是一个细胞组），而 netVisual_chord_gene 用于可视化由多个配体-受体或信号通路介导的细胞间通信（和弦图中的每个扇区是一个配体、受体或信号通路）。 par(mfrow = c(1, 2), xpd=TRUE) # 比较从 Inflam.FIB 发送到 DC 细胞的所有交互 for (i in 1:length(object.list)) { netVisual_chord_gene(object.list[[i]], sources.use = 4, targets.use = c(5:8), lab.cex = 0.5, title.name = paste0(&quot;Signaling from Inflam.FIB - &quot;, names(object.list)[i])) } # 比较所有从成纤维细胞发送到炎症性免疫细胞的相互作用 par(mfrow = c(1, 2), xpd=TRUE) for (i in 1:length(object.list)) { netVisual_chord_gene(object.list[[i]], sources.use = c(1,2, 3, 4), targets.use = c(8,10), title.name = paste0(&quot;Signaling received by Inflam.DC and .TC - &quot;, names(object.list)[i]), legend.pos.x = 10) } # 显示从成纤维细胞到免疫细胞的所有重要信号通路 par(mfrow = c(1, 2), xpd=TRUE) for (i in 1:length(object.list)) { netVisual_chord_gene(object.list[[i]], sources.use = c(1,2,3,4), targets.use = c(5:11),slot.name = &quot;netP&quot;, title.name = paste0(&quot;Signaling pathways sending from fibroblast - &quot;, names(object.list)[i]), legend.pos.x = 10) } 注意：生成图表时请忽略诸如“注意：第一个链接端绘制在‘MIF’扇区外。”的注释。如果基因名称重叠，可以通过减小参数 small.gap 的值来进行调整。 15.6 比较不同数据集之间信号基因表达分布 我们可以使用 Seurat 包装函数 plotGeneExpression 绘制与 L-R 对或信号通路相关的信号基因的基因表达分布。 cellchat@meta$datasets = factor(cellchat@meta$datasets, levels = c(&quot;NL&quot;, &quot;LS&quot;)) # set factor level plotGeneExpression(cellchat, signaling = &quot;CXCL&quot;, split.by = &quot;datasets&quot;, colors.ggplot = T, type = &quot;violin&quot;) 15.7 保存合并的 CellChat 对象 save(object.list, file = &quot;cellchat_object.list_humanSkin_NL_LS.RData&quot;) save(cellchat, file = &quot;cellchat_merged_humanSkin_NL_LS.RData&quot;) "],["细胞通讯分析.html", "第 16 章 细胞通讯分析 16.1 R包和数据 16.2 了解参考数据 16.3 构建cellchat对象 16.4 细胞通讯网络分析 16.5 画图展示 16.6 细胞通讯模式和信号网络", " 第 16 章 细胞通讯分析 背景知识 细胞通讯是单细胞数据高级分析中比较常见的一个，我们习惯使用的R包是CellChat。 这个是CellChat的一手教程： https://htmlpreview.github.io/?https://github.com/jinworks/CellChat/blob/master/tutorial/CellChat-vignette.html 让AI来告诉我们做细胞通讯分析的用途： 细胞通讯分析是生物学研究中的一个重要领域，它涉及研究细胞之间如何通过信号传递来协调它们的功能和行为。以下是一些细胞通讯分析的主要用途： 疾病诊断和治疗：了解细胞如何交流可以帮助诊断和治疗疾病，特别是那些与细胞通讯失调有关的疾病，如癌症、自身免疫疾病和神经退行性疾病。 药物开发：通过研究细胞间通讯的机制，可以发现新的药物靶点，从而开发出更有效的治疗药物。 发育生物学：细胞通讯在胚胎发育和组织形成中起着关键作用。研究这些过程有助于我们理解正常和异常发育的机制。 组织工程：在组织工程中，细胞通讯对于细胞的增殖、分化和组织结构的形成至关重要。 细胞信号传导研究：细胞通讯分析有助于揭示细胞内信号传导的复杂网络，这对于理解细胞如何响应外界刺激非常重要。 生物防御机制：研究细胞如何通过通讯来协调免疫反应，可以帮助我们更好地理解生物体如何抵御病原体。 神经科学：在神经科学领域，细胞通讯分析有助于我们理解大脑如何通过神经细胞间的信号传递来处理信息。 生物信息学和系统生物学：通过分析细胞通讯网络，可以构建生物系统的数学模型，帮助我们从系统层面理解生物过程。 环境生物学：研究细胞如何响应环境变化，例如温度、光照和化学物质，可以揭示生物如何适应环境。 农业和植物科学：在植物科学中，了解植物细胞如何通过通讯来协调生长、发育和对环境的响应，对于提高作物产量和抗逆性至关重要。 细胞通讯分析是一个多学科交叉的领域，它结合了分子生物学、细胞生物学、生物化学、生物信息学和其他学科的知识和技术。通过这种分析，科学家可以更深入地理解生命过程，并开发出新的生物技术和治疗方法。 16.1 R包和数据 使用的数据sce.all.Rdata是Seurat降维聚类分群注释的结果，有两个样本。和多样本拟时序用的是同一个数据。 rm(list = ls()) if(!require(NMF))install.packages(&quot;NMF&quot;,update = F,ask = F) if(!require(presto))devtools::install_local(&#39;presto-master.zip&#39;,upgrade = F,dependencies = T) if(!require(CellChat))devtools::install_local(&quot;CellChat-main/&quot;,upgrade = F,dependencies = T) if(!require(ggalluvial))install.packages(&quot;ggalluvial&quot;,update = F,ask = F) library(CellChat) library(ggplot2) library(Seurat) library(ggalluvial) load(&quot;../5.monocle_mulitisample/sce.all.Rdata&quot;) table(Idents(sce.all)) ## ## CD14 Mono pDC CD4 Memory T T activated CD4 Naive T CD8 T ## 100 100 100 100 100 100 ## Mk B Activated B DC CD16 Mono NK ## 100 100 100 100 100 100 scRNA = sce.all 因为细胞通讯更更更费计算资源，我们还是抽样，实战中不能抽样的。 set.seed(112) scRNA = subset(scRNA,downsample = 100) table(Idents(scRNA)) ## ## CD14 Mono pDC CD4 Memory T T activated CD4 Naive T CD8 T ## 100 100 100 100 100 100 ## Mk B Activated B DC CD16 Mono NK ## 100 100 100 100 100 100 16.2 了解参考数据 CellChatDB.human,CellChatDB.mouse分别是人和小鼠的配受体数据库 str(CellChatDB.human,max.level = 1) ## List of 4 ## $ interaction:&#39;data.frame&#39;: 1939 obs. of 11 variables: ## $ complex :&#39;data.frame&#39;: 157 obs. of 4 variables: ## $ cofactor :&#39;data.frame&#39;: 31 obs. of 16 variables: ## $ geneInfo :&#39;data.frame&#39;: 41787 obs. of 6 variables: table(CellChatDB.human$interaction$annotation) ## ## Cell-Cell Contact ECM-Receptor Secreted Signaling ## 319 421 1199 PPI.human和PPI.mouse是稀疏矩阵，是STRING数据库里高等级证据的相互作用关系组成的0-1矩阵。 class(PPI.human) ## [1] &quot;dgCMatrix&quot; ## attr(,&quot;package&quot;) ## [1] &quot;Matrix&quot; dim(PPI.human) ## [1] 4815 4815 table(as.numeric(PPI.human)) ## ## 0 1 ## 23156523 27702 16.3 构建cellchat对象 seurat对象可以直接转换。在@DB加上要使用的配体受体数据库，注意物种 cellchat &lt;- createCellChat(sce.all, group.by = &quot;ident&quot;, assay = &quot;RNA&quot;) ## [1] &quot;Create a CellChat object from a Seurat object&quot; ## The `meta.data` slot in the Seurat object is used as cell meta information ## Set cell identities for the new CellChat object ## The cell groups used for CellChat analysis are CD14 Mono pDC CD4 Memory T T activated CD4 Naive T CD8 T Mk B Activated B DC CD16 Mono NK cellchat@DB &lt;- subsetDB(CellChatDB.human, search = &quot;Secreted Signaling&quot;) #search可以选择的值是： table(CellChatDB.human$interaction$annotation) # 提取数据库支持的基因的表达矩阵子集 cellchat &lt;- subsetData(cellchat) dim(cellchat@data.signaling) ## [1] 337 1200 16.4 细胞通讯网络分析 # 识别过表达基因 cellchat &lt;- identifyOverExpressedGenes(cellchat) # 识别配体-受体对 cellchat &lt;- identifyOverExpressedInteractions(cellchat) # 将配体、受体投射到PPI网络 cellchat &lt;- projectData(cellchat, PPI.human)#慢 ## 推测细胞通讯网络 cellchat &lt;- computeCommunProb(cellchat) #慢 ## triMean is used for calculating the average gene expression per cell group. ## [1] &quot;&gt;&gt;&gt; Run CellChat on sc/snRNA-seq data &lt;&lt;&lt; [2025-04-07 20:21:48.305586]&quot; ## [1] &quot;&gt;&gt;&gt; CellChat inference is done. Parameter values are stored in `object@options$parameter` &lt;&lt;&lt; [2025-04-07 20:22:10.138138]&quot; cellchat &lt;- computeCommunProbPathway(cellchat) cellchat &lt;- aggregateNet(cellchat) 16.5 画图展示 分析出来的重要信号通路如下 cellchat@netP$pathways ## [1] &quot;GALECTIN&quot; &quot;CCL&quot; &quot;ANNEXIN&quot; &quot;CXCL&quot; &quot;IL1&quot; 每个通路都可以画多种图出来，图中线的颜色与发射信号的细胞一致，线的粗细代表的是信号强弱，线越粗信号越强。点的大小一般是按照每种细胞的数量来分配。 pathways.show是要画的信号通路，可以换成cellchat@netP$pathways显示的其他通路 pathways.show &lt;- &quot;GALECTIN&quot; 16.5.0.0.1 hierarchy plot groupSize &lt;- as.numeric(table(cellchat@idents)) vertex.receiver = seq(1,nlevels(scRNA)/2);vertex.receiver ## [1] 1 2 3 4 5 6 netVisual_aggregate(cellchat, signaling = pathways.show, layout = &quot;hierarchy&quot;, vertex.receiver = vertex.receiver, vertex.weight = groupSize) 这个图分了两张子图，其实是分两次说明了所有细胞类型之间的互作。两张子图的差别是中间的圆圈，第一张子图中，第二列的圆圈意义同第一列，第二张子图中，第二列的圆圈意义同第三列，从”Target”这个单词的颜色和哪个”source”一致可以看出。 互作方向也有了，是从两边的source到中间的target。 16.5.1 circle plot circle plot 只是换了一个布局，一张图展示出来。 par(mfrow = c(1,1), xpd=TRUE,mar = c(2, 2, 2, 2)) netVisual_aggregate(cellchat, signaling = pathways.show, layout = &quot;circle&quot;, vertex.receiver = vertex.receiver, vertex.weight = groupSize) 16.5.2 chord plot 弦图还是很有细节的，内圈小短线代表发射出的信号被谁接收，和接受者颜色一致，发射端是平的且有小短线，接收端是尖的。 netVisual_aggregate(cellchat, signaling = pathways.show, layout = &quot;chord&quot;, vertex.receiver = vertex.receiver, vertex.weight = groupSize) 16.5.3 heatmap 热图，纵坐标是发射端，横坐标是接收端，有颜色代表横纵坐标所指的两类细胞之间有通讯，颜色深浅代表通讯概率。右侧和上方的条形图是该行/列通讯概率之和 netVisual_heatmap(cellchat, signaling = pathways.show, color.heatmap = &quot;Reds&quot;) 计算配体-受体对信号网络的贡献度 netAnalysis_contribution(cellchat, signaling = pathways.show) 16.5.4 热图-展示每一类细胞是什么角色 分析细胞在信号网络中角色：发送者、接收者、调解者和影响者。 cellchat &lt;- netAnalysis_computeCentrality(cellchat, slot.name = &quot;netP&quot;) # the slot &#39;netP&#39; means the inferred intercellular communication network of signaling pathways netAnalysis_signalingRole_network(cellchat, signaling = pathways.show, width = 12, height = 5, font.size = 10) 16.5.5 气泡图-显示所有的显著的配体-受体对 只有p&lt;0.05的才会被画出来，颜色仍然是通讯概率，圈的大小是按照p值，p值越小圈越大。 #可以分开，也可以合到一起 netVisual_bubble(cellchat, sources.use = 1, targets.use = 1:nlevels(scRNA), remove.isolate = FALSE) #从第一类细胞到全部细胞 netVisual_bubble(cellchat, sources.use = 1:nlevels(scRNA), targets.use = 1:nlevels(scRNA), remove.isolate = FALSE)#从全部细胞到全部细胞 16.6 细胞通讯模式和信号网络 传出模式，揭示了发射端细胞如何相互协调，以及它们如何与某些信号通路协调以驱动通信。 传入模式，显示接收端细胞如何相互协调，以及它们如何与某些信号通路协调以响应输入信号。 16.6.1 选择合适的partten（细胞通讯模式）的数量 library(NMF) selectK(cellchat, pattern = &quot;outgoing&quot;) selectK(cellchat, pattern = &quot;incoming&quot;) 在帮助文档里面有解释：For a range of the number of patterns, a suitable number of patterns is the one at which Cophenetic and Silhouette values begin to drop suddenly。 这两个指标都是评估聚类稳定性的，二者都突然下降的值对应的横坐标就是合适的聚类数 这里是用parttern-细胞，parttern-通路矩阵画的热图。identifyCommunicationPatterns函数识别通讯模式，并画出热图 #传出 cellchat &lt;- identifyCommunicationPatterns(cellchat, pattern = &quot;outgoing&quot;, k = 3)# k是parttern的数量，根据上图选择的，嫌麻烦也可以用默认值5 #传入 cellchat &lt;- identifyCommunicationPatterns(cellchat, pattern = &quot;incoming&quot;, k = 3)# k是parttern的数量，根据上图选择的，嫌麻烦也可以用默认值5 用桑基图和气泡图展示每种细胞传入/传出的信号都是属于哪些通路的 # 桑基图 netAnalysis_river(cellchat, pattern = &quot;outgoing&quot;) netAnalysis_river(cellchat, pattern = &quot;incoming&quot;) # 气泡图 netAnalysis_dot(cellchat, pattern = &quot;outgoing&quot;,dot.size = 4) netAnalysis_dot(cellchat, pattern = &quot;incoming&quot;,dot.size = 4) 气泡图的颜色是按照细胞类型来分配，大小按照每个通路对每个细胞类型的贡献程度分配。 "],["gsva-分析.html", "第 17 章 GSVA 分析 17.1 加载数据和R包 17.2 做GSVA 17.3 热图可视化", " 第 17 章 GSVA 分析 单细胞数据的GSVA和芯片、bulk转录组的GSVA没有本质区别，就使用AverageExpression获取平均表达量得到新的表达矩阵再计算即可。 17.1 加载数据和R包 获得每种细胞的平均表达量. 这里的示例数据seu.obj.Rdata是GSE218208降维聚类分群的结果，因为文件太大，没有直接放进文件夹里，如果load报错就自己运行一下隔壁GSE218208的代码得到这个文件再跑。 rm(list = ls()) library(Seurat) library(GSVA) library(clusterProfiler) load(&quot;../2.GSE218208/seu.obj.Rdata&quot;) table(Idents(seu.obj)) ## ## Naive CD4 T CD14+ Mono B CD8 T NK FCGR3A+ Mono ## 1675 1206 598 406 337 125 ## Platelet DC ## 48 88 exp = AverageExpression(seu.obj)[[1]] #exp = AggregateExpression(seu.obj)[[1]] exp = as.matrix(exp) exp = exp[rowSums(exp)&gt;0,] exp[1:4,1:4] ## Naive CD4 T CD14+ Mono B CD8 T ## TSPAN6 0.01890007 0.000000000 0.00000000 0.00446691 ## DPM1 0.50764534 0.398461857 0.52602493 0.49951298 ## SCYL3 0.10701976 0.049771894 0.10397003 0.12101561 ## C1orf112 0.02653607 0.005093801 0.05426134 0.02747031 Seurat v5 提示建议用AggregateExpression做伪bulk转录组分析，那个是用来求和的，目前查到的文献和教程都是使用平均值，这里就木有改动. 17.2 做GSVA gmt文件下载自GSEA-msigdb官网 h_df = read.gmt(&quot;h.all.v2023.2.Hs.symbols.gmt&quot;)[,c(2,1)] h_list = unstack(h_df) # ES = gsva(exp, h_list) #⭐R 语言版本4.3运行这一句，代替下面的两句 gsvapar &lt;- gsvaParam(exp, h_list, maxDiff=TRUE) ES &lt;- gsva(gsvapar) ES[1:4,1:4] 17.3 热图可视化 library(pheatmap) pheatmap(ES, scale = &quot;row&quot;,angle_col = &quot;45&quot;, color = colorRampPalette(c(&quot;navy&quot;, &quot;white&quot;, &quot;firebrick3&quot;))(50)) "],["细胞周期.html", "第 18 章 细胞周期 18.1 读取数据并做好前期的质控 18.2 计算细胞周期评分 18.3 比较两个数据的细胞周期评分和PCA 18.4 比较去除和不去处细胞周期影响的下游注释", " 第 18 章 细胞周期 怎么知道我的单细胞数据需不需要去除细胞周期的影响呢 背景知识 尘封的高中生物学知识，细胞的有丝分裂，分为分裂期（M）和分裂间期（G1，S，G2），细胞处于不同的细胞周期时，代谢活跃状态和染色体的状态大不相同，直接比较表达量是不公平的。 在一些数据中，细胞周期的影响很大，大到每个周期的细胞各自聚成一簇，严重影响下游的聚类和分群。有的数据中，细胞周期的影响非常之低，可以忽略不记。 Seurat有自带的方法，根据在各个周期高表达的基因来计算细胞周期评分，根据评分的高低来推断细胞属于什么周期。 让我们来康一康如何探索细胞周期，以及有影响和没影响的数据各自长什么样。 18.1 读取数据并做好前期的质控 来自Seurat Vignette的示例数据 https://satijalab.org/seurat/articles/cell_cycle_vignette 18.1.1 GSE218208 #untar(&quot;GSE218208_RAW.tar&quot;) rm(list = ls()) a = data.table::fread(&quot;GSM6736629_10x-PBMC-1_ds0.1974_CountMatrix.tsv.gz&quot;,data.table = F) a[1:4,1:4] ## alias:gene AAACCCAAGTAGGGTC AAACCCACACCATTCC AAACCCATCTACACTT ## 1 TSPAN6:ENSG00000000003 0 0 0 ## 2 DPM1:ENSG00000000419 0 1 0 ## 3 SCYL3:ENSG00000000457 0 0 0 ## 4 C1orf112:ENSG00000000460 0 0 0 library(tidyverse) a$`alias:gene` = str_split_i(a$`alias:gene`,&quot;:&quot;,i = 1) a = distinct(a,`alias:gene`,.keep_all = T) a = column_to_rownames(a,var = &quot;alias:gene&quot;) a[1:4,1:4] ## AAACCCAAGTAGGGTC AAACCCACACCATTCC AAACCCATCTACACTT AAACGAAAGCACGTCC ## TSPAN6 0 0 0 0 ## DPM1 0 1 0 0 ## SCYL3 0 0 0 0 ## C1orf112 0 0 0 0 library(Seurat) pbmc &lt;- CreateSeuratObject(counts = a, project = &quot;a&quot;, min.cells = 3, min.features = 200) pbmc[[&quot;percent.mt&quot;]] &lt;- PercentageFeatureSet(pbmc, pattern = &quot;^MT-&quot;) head(pbmc@meta.data, 3) ## orig.ident nCount_RNA nFeature_RNA percent.mt ## AAACCCAAGTAGGGTC a 10768 3213 7.030089 ## AAACCCACACCATTCC a 4102 1676 5.046319 ## AAACCCATCTACACTT a 4694 1740 6.305922 VlnPlot(pbmc, features = c(&quot;nFeature_RNA&quot;, &quot;nCount_RNA&quot;, &quot;percent.mt&quot;), ncol = 3,pt.size = 0.5) pbmc = subset(pbmc,nFeature_RNA &lt; 4200 &amp; nCount_RNA &lt; 18000 &amp; percent.mt &lt; 10) 18.1.2 marrow exp.mat &lt;- read.delim(&quot;nestorawa_forcellcycle_expressionMatrix.txt&quot;,row.names = 1) marrow &lt;- CreateSeuratObject(counts = exp.mat, project = &quot;b&quot;, min.cells = 3, min.features = 200) marrow[[&quot;percent.mt&quot;]] &lt;- PercentageFeatureSet(marrow, pattern = &quot;^MT-&quot;) head(marrow@meta.data, 3) ## orig.ident nCount_RNA nFeature_RNA percent.mt ## Prog_013 Prog 2563086 10208 5.187809 ## Prog_019 Prog 3030619 9990 5.965877 ## Prog_031 Prog 1293487 10192 5.664456 VlnPlot(marrow, features = c(&quot;nFeature_RNA&quot;, &quot;nCount_RNA&quot;, &quot;percent.mt&quot;), ncol = 3,pt.size = 0.5) #从图上可以看出这个数据已经过滤了 18.2 计算细胞周期评分 check_cc = function(ob){ s.genes &lt;- intersect(cc.genes$s.genes,rownames(ob)) g2m.genes &lt;- intersect(cc.genes$g2m.genes,rownames(ob)) ob = ob %&gt;% NormalizeData() %&gt;% FindVariableFeatures() %&gt;% CellCycleScoring(s.features = s.genes, g2m.features = g2m.genes) %&gt;% ScaleData(features = rownames(.)) %&gt;% RunPCA(features = c(s.genes,g2m.genes)) return(ob) } ob1 = check_cc(pbmc) head(ob1@meta.data) ## orig.ident nCount_RNA nFeature_RNA percent.mt S.Score ## AAACCCAAGTAGGGTC a 10768 3213 7.030089 -0.049741327 ## AAACCCACACCATTCC a 4102 1676 5.046319 0.077834857 ## AAACCCATCTACACTT a 4694 1740 6.305922 -0.042199858 ## AAACGAAAGCACGTCC a 5584 2055 4.512894 -0.005870195 ## AAACGAAGTTCAAACC a 2917 1548 2.673980 -0.036017674 ## AAACGAAGTTGGACTT a 3755 1408 5.219707 -0.008708112 ## G2M.Score Phase ## AAACCCAAGTAGGGTC -0.078938340 G1 ## AAACCCACACCATTCC -0.036964594 S ## AAACCCATCTACACTT -0.033518345 G1 ## AAACGAAAGCACGTCC -0.026582838 G1 ## AAACGAAGTTCAAACC 0.006352434 G2M ## AAACGAAGTTGGACTT -0.060231178 G1 18.3 比较两个数据的细胞周期评分和PCA 可以看到这个函数处理完后，meta.data里面多了4列，分别是s和g2m的评分以及推断的细胞周期。 table(ob1$Phase) ## ## G1 G2M S ## 1821 1224 1294 ob2 = check_cc(marrow) table(ob2$Phase) ## ## G1 G2M S ## 279 183 312 PCAPlot(ob1,group.by = &quot;Phase&quot;)+ PCAPlot(ob2,group.by = &quot;Phase&quot;) 这样的比较不太直观，把坐标调到相同范围 library(patchwork) PCAPlot(ob1,group.by = &quot;Phase&quot;)+ PCAPlot(ob2,group.by = &quot;Phase&quot;)&amp; xlim(-10,10)&amp; ylim(-10,10) 再比较一下S.Score和G2M.Score p1 = VlnPlot(ob1,&quot;S.Score&quot;,group.by = &quot;Phase&quot;) p2 = VlnPlot(ob2,&quot;S.Score&quot;,group.by = &quot;Phase&quot;) wrap_plots(p1,p2,nrow = 1) &amp; ylim(-0.6,0.6) p1 = VlnPlot(ob1,&quot;G2M.Score&quot;,group.by = &quot;Phase&quot;) p2 = VlnPlot(ob2,&quot;G2M.Score&quot;,group.by = &quot;Phase&quot;) wrap_plots(p1,p2,nrow = 1) &amp; ylim(-0.5,1) 这个周期的判断还是比较粗暴的，哪个分高就是那个周期，两个分都是负的那就G1期。 因此虽然GSE218208的数据也是有周期区别，但是分数相差很小，影响很小。 所以像这样的大多数点都集中在0点附近的数据，就可以不用去除细胞周期的影响！ ok，你不踏实。那我们来比较一下去除和不去除细胞周期影响的下游注释看有没有区别吧。 18.4 比较去除和不去处细胞周期影响的下游注释 18.4.1 不考虑细胞周期的降维聚类分群 f = &quot;ob1.Rdata&quot; if(!file.exists(f)){ ob1 = pbmc %&gt;% NormalizeData() %&gt;% FindVariableFeatures() %&gt;% ScaleData(features = rownames(.)) %&gt;% RunPCA(features = VariableFeatures(.)) %&gt;% FindNeighbors(dims = 1:15) %&gt;% FindClusters(resolution = 0.5) %&gt;% RunUMAP(dims = 1:15) %&gt;% RunTSNE(dims = 1:15) save(ob1,file = f) } ## Modularity Optimizer version 1.3.0 by Ludo Waltman and Nees Jan van Eck ## ## Number of nodes: 4339 ## Number of edges: 151523 ## ## Running Louvain algorithm... ## Maximum modularity in 10 random starts: 0.8942 ## Number of communities: 12 ## Elapsed time: 0 seconds load(f) 18.4.2 考虑细胞周期的降维聚类分群 s.genes &lt;- intersect(cc.genes$s.genes,rownames(pbmc)) g2m.genes &lt;- intersect(cc.genes$g2m.genes,rownames(pbmc)) f = &quot;ob2.Rdata&quot; if(!file.exists(f)){ ob2 = pbmc %&gt;% NormalizeData() %&gt;% FindVariableFeatures() %&gt;% CellCycleScoring(s.features = s.genes, g2m.features = g2m.genes) %&gt;% ScaleData(vars.to.regress = c(&quot;S.Score&quot;, &quot;G2M.Score&quot;),features = rownames(.)) %&gt;% #运行极其慢 RunPCA(features = VariableFeatures(.)) %&gt;% FindNeighbors(dims = 1:15) %&gt;% FindClusters(resolution = 0.5) %&gt;% RunUMAP(dims = 1:15) %&gt;% RunTSNE(dims = 1:15) save(ob2,file = f) } ## Modularity Optimizer version 1.3.0 by Ludo Waltman and Nees Jan van Eck ## ## Number of nodes: 4339 ## Number of edges: 146175 ## ## Running Louvain algorithm... ## Maximum modularity in 10 random starts: 0.8902 ## Number of communities: 13 ## Elapsed time: 0 seconds load(f) p1 &lt;- DimPlot(ob1, reduction = &quot;umap&quot;,label = T)+NoLegend() p2 &lt;- DimPlot(ob2, reduction = &quot;umap&quot;,label = T)+NoLegend() p1+p2 简单点用singleR来注释 library(celldex) library(SingleR) ls(&quot;package:celldex&quot;) ## [1] &quot;BlueprintEncodeData&quot; &quot;DatabaseImmuneCellExpressionData&quot; ## [3] &quot;defineTextQuery&quot; &quot;fetchLatestVersion&quot; ## [5] &quot;fetchMetadata&quot; &quot;fetchReference&quot; ## [7] &quot;HumanPrimaryCellAtlasData&quot; &quot;ImmGenData&quot; ## [9] &quot;listReferences&quot; &quot;listVersions&quot; ## [11] &quot;MonacoImmuneData&quot; &quot;MouseRNAseqData&quot; ## [13] &quot;NovershternHematopoieticData&quot; &quot;saveReference&quot; ## [15] &quot;searchReferences&quot; &quot;surveyReferences&quot; f = &quot;../supp/single_ref/ref_Human_all.RData&quot; if(!file.exists(f)){ ref &lt;- celldex::HumanPrimaryCellAtlasData() save(ref,file = f) } ref &lt;- get(load(f)) library(BiocParallel) scRNA = ob1 test = scRNA@assays$RNA$data pred.scRNA &lt;- SingleR(test = test, ref = ref, labels = ref$label.main, clusters = scRNA@active.ident) new.cluster.ids &lt;- pred.scRNA$pruned.labels names(new.cluster.ids) &lt;- levels(scRNA) scRNA &lt;- RenameIdents(scRNA,new.cluster.ids) p3 &lt;- DimPlot(scRNA, reduction = &quot;umap&quot;,label = T,pt.size = 0.5) + NoLegend() m = scRNA 解释一下为什么会有scRNA = ob1,m = scRNA这样的代码： 当然是为了少改代码犯错误啦。两次注释的代码是一样的，如果把scRNA这个变量名替换掉就麻烦，别说可以全部替换，万一你替换的变量名称是函数或者文件名等东西的一部分，那不还得报错还得改回去？所以移花接木另行赋值是个更好的选择。 scRNA = ob2 test = scRNA@assays$RNA$data pred.scRNA &lt;- SingleR(test = test, ref = ref, labels = ref$label.main, clusters = scRNA@active.ident) new.cluster.ids &lt;- pred.scRNA$pruned.labels names(new.cluster.ids) &lt;- levels(scRNA) scRNA &lt;- RenameIdents(scRNA,new.cluster.ids) p4 &lt;- DimPlot(scRNA, reduction = &quot;umap&quot;,label = T,pt.size = 0.5) + NoLegend() p3+p4 # table(Idents(m)==Idents(scRNA)) 去不去除当然还是有区别的，只不过影响不大，可以忽略不计啊。 "],["404.html", "Page not found", " Page not found The page you requested cannot be found (perhaps it was moved or renamed). You may want to try searching to find the page's new location, or use the table of contents to find the page you are looking for. "]]
